module.exports =[{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#назовите-основные-парадигмы-программирования","title":"<p>Назовите основные парадигмы программирования</p>","answer":"<p><strong>Императивное программирование</strong> — это парадигма программирования (стиль написания исходного кода компьютерной программы), для которой характерно следующее:</p>\n<ul>\n<li>в исходном коде программы записываются инструкции (команды);</li>\n<li>инструкции должны выполняться последовательно;</li>\n<li>данные, получаемые при выполнении предыдущих инструкций, могут читаться из памяти последующими инструкциями;</li>\n<li>данные, полученные при выполнении инструкции, могут записываться в память.</li>\n</ul>\n<p>Императивная программа похожа на приказы (англ. imperative — приказ, повелительное наклонение), выражаемые повелительным наклонением в естественных языках, то есть представляют собой последовательность команд, которые должен выполнить компьютер.</p>\n<p>К императивной парадигме относятся <em>процедурное</em>, <em>структурное</em>, <em>объектно-ориентированное программирование (ООП)</em> и некоторые другие.</p>\n<p><strong>Декларативное программирование</strong> — это парадигма программирования, в которой задаётся спецификация решения задачи, то есть описывается, что представляет собой проблема и ожидаемый результат. Противоположностью декларативного является императивное программирование, описывающее на том или ином уровне детализации, как решить задачу и представить результат. В общем и целом, декларативное программирование идёт от человека к машине, тогда как императивное — от машины к человеку. Как следствие, декларативные программы не используют понятия состояния, то есть не содержат переменных и операторов присваивания (см. также ссылочная прозрачность).</p>\n<p>К декларативной парадигме относится и <em>функциональное программирование (ФП)</em>.</p>\n<p><strong>Реактивное программирование</strong> — парадигма программирования, ориентированная на потоки данных и распространение изменений. Это означает, что должна существовать возможность легко выражать статические и динамические потоки данных, а также то, что нижележащая модель исполнения должна автоматически распространять изменения благодаря потоку данных.</p>\n<p>Может сочетаться с императивной парадигмой, ООП и ФП.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-ооп","title":"<p>Что такое <em>ООП</em>?</p>","answer":"<p><strong>Объектно-ориентированное программирование (ООП)</strong> — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.</p>\n<ul>\n<li>объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты,\nа не алгоритмы;</li>\n<li>каждый объект является экземпляром определенного класса</li>\n<li>классы образуют иерархии.</li>\n</ul>\n<p>Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности,\nпрограммирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью\nабстрактных типов данных.</p>\n<p>Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием,\nединственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить\nсобственное состояние.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#назовите-основные-принципы-ооп","title":"<p>Назовите основные принципы <em>ООП</em></p>","answer":"<ul>\n<li><em>Инкапсуляция</em> - сокрытие реализации.</li>\n<li><em>Наследование</em> - создание новой сущности на базе уже существующей.</li>\n<li><em>Полиморфизм</em> - возможность иметь разные формы для одной и той же сущности.</li>\n<li><em>Абстракция</em> - набор общих характеристик.</li>\n<li><em>Переиспользование</em>- всё, что перечислено выше работает на повторное использование кода.</li>\n</ul>\n<p>Это единственно верный порядок парадигм ООП, так как каждая последующая использует предыдущие.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-инкапсуляция","title":"<p>Что такое <em>«инкапсуляция»</em>?</p>","answer":"<p><strong>Инкапсуляция</strong> – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. Не стоит путать со <em>сокрытием данных</em>,\nхотя в некоторых языках программирования эти понятия тождественны.</p>\n<p>Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение\nв классе не влекло за собой изменение внешнего поведения класса.</p>\n<blockquote>\n  <p>Представим на минутку, что мы оказались в конце позапрошлого века, когда Генри Форд ещё не придумал конвейер, а первые попытки создать автомобиль сталкивались с критикой властей по поводу того, что эти коптящие монстры загрязняют воздух и пугают лошадей. Представим, что для управления первым паровым автомобилем необходимо было знать, как устроен паровой котёл, постоянно подбрасывать уголь, следить за температурой, уровнем воды. При этом для поворота колёс использовать два рычага, каждый из которых поворачивает одно колесо в отдельности. Думаю, можно согласиться с тем, что вождение автомобиля того времени было весьма неудобным и трудным занятием.</p>\n  <p>Теперь вернёмся в сегодняшний день к современным чудесам автопрома с коробкой-автоматом. На самом деле, по сути, ничего не изменилось. Бензонасос всё так же поставляет бензин в двигатель, дифференциалы обеспечивают поворот колёс на различающиеся углы, коленвал превращает поступательное движение поршня во вращательное движение колёс. Прогресс в другом. Сейчас все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит с инжектором, дроссельной заслонкой и распредвалом. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название инкапсуляции.</p>\n</blockquote>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">public class SomePhone {\n\n    private int year;\n    private String company;\n    public SomePhone(int year, String company) {\n        this.year = year;\n        this.company = company;\n    }\n    private void openConnection(){\n        //findComutator\n        //openNewConnection...\n    }\n    public void call() {\n        openConnection();\n        System.out.println(\"Вызываю номер\");\n    }\n\n    public void ring() {\n        System.out.println(\"Динь-динь\");\n    }\n\n}\n</code></pre>\n<p>Модификатор private делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к private полям из вне невозможно, как и нет возможности вызвать private методы.</p>\n<p>Сокрытие доступа к методу openConnection, оставляет нам также возможность к свободному изменению внутренней реализации этого метода, так как этот метод гарантированно не используется другими объектами и не нарушит их работу.</p>\n<p>Для работы с нашим объектом мы оставляем открытыми методы call и ring с помощью модификатора public. Предоставление открытых методов для работы с объектом также является частью механизма инкапсуляции, так как если полностью закрыть доступ к объекту – он станет бесполезным.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-наследование","title":"<p>Что такое <em>«наследование»</em>?</p>","answer":"<p><strong>Наследование</strong> – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.</p>\n<p>Класс, от которого производится наследование, называется <em>предком</em>, <em>базовым</em> или <em>родительским</em>. Новый класс – <em>потомком</em>, <em>наследником</em> или <em>производным</em> классом.</p>\n<blockquote>\n  <p>Представим себя, на минуту, инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя в течение многолетнего использования. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.</p>\n  <p>Нам необходимо выпустить целый модельный ряд автомобилей: седан, универсал и малолитражный хэтчбэк. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений. Например, добавим гидроусилитель руля и уменьшим зазоры между крыльями и крышкой капота, поставим противотуманные фонари. Кроме того, в каждой модели будет изменена форма кузова.</p>\n  <p>Очевидно, что все три модификации будут иметь большинство свойств прежней модели (старый добрый двигатель 1970 года, непробиваемая ходовая часть, зарекомендовавшая себя отличным образом на отечественных дорогах, коробку передач и т.д.). При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.</p>\n</blockquote>\n<p>Пример:\nРассмотрим пример создания класса смартфон с помощью наследования. Все беспроводные телефоны работают от аккумуляторных батарей, которые имеют определенный ресурс работы в часах. Поэтому добавим это свойство в класс беспроводных телефонов:</p>\n<pre><code class=\"java language-java\">public abstract class WirelessPhone extends AbstractPhone {\n\n    private int hour;\n\n    public WirelessPhone(int year, int hour) {\n        super(year);\n        this.hour = hour;\n    }\n}\n</code></pre>\n<p>Сотовые телефоны наследуют свойства беспроводного телефона, мы также добавили в этот класс реализацию методов call и ring:</p>\n<pre><code class=\"java language-java\">public class CellPhone extends WirelessPhone {\n    public CellPhone(int year, int hour) {\n        super(year, hour);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вызываю номер \" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Вам звонит абонент \" + inputNumber);\n    }\n}\n</code></pre>\n<p>И, наконец, класс смартфон, который в отличие от классических сотовых телефонов имеет полноценную операционную систему. В смартфон можно добавлять новые программы, поддерживаемые данной операционной системой, расширяя, таким образом, его функциональность. С помощью кода класс можно описать так:</p>\n<pre><code class=\"java language-java\">public class Smartphone extends CellPhone {\n\n    private String operationSystem;\n\n    public Smartphone(int year, int hour, String operationSystem) {\n        super(year, hour);\n        this.operationSystem = operationSystem;\n    }\n\n    public void install(String program){\n        System.out.println(\"Устанавливаю \" + program + \"для\" + operationSystem);\n    }\n\n}\n</code></pre>\n<p>Как видите, для описания класса Smartphone мы создали совсем немного нового кода, но получили новый класс с новой функциональностью. Использование этого принципа ООП java позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-полиморфизм","title":"<p>Что такое <em>«полиморфизм»</em>?</p>","answer":"<p><strong>Полиморфизм</strong> – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</p>\n<p>Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).</p>\n<blockquote>\n  <p>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, ВАЗ 2106 не мог потом водить ВАЗ 2110 или BMW X3. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик.</p>\n  <p>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию и принцип действия. Водитель точно знает, что для того, чтобы повернуть налево, он должен повернуть руль, независимо от того, есть там гидроусилитель или нет.\n  Если человеку надо доехать с работы до дома, то он сядет за руль автомобиля и будет выполнять одни и те же действия, независимо от того, какой именно тип автомобиля он использует. По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Если водителю предстоит ехать по немецкому автобану, он, вероятно, выберет быстрый автомобиль с низкой посадкой, а если предстоит возвращаться из отдалённого маральника в Горном Алтае после дождя, скорее всего, будет выбран УАЗ с армейскими мостами. Но, независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.</p>\n</blockquote>\n<p><em>Полиморфная переменная</em>, это переменная, которая может принимать значения разных типов, а <em>полиморфная функция</em>, это функция у которой хотя бы один аргумент является полиморфной переменной.\nВыделяют два вида полиморфных функций:</p>\n<ul>\n<li><em>ad hoc</em>, функция ведет себя по разному для разных типов аргументов (например, функция <code>draw()</code> — рисует по разному фигуры разных типов);</li>\n<li><em>параметрический</em>, функция ведет себя одинаково для аргументов разных типов (например, функция <code>add()</code> — одинаково кладет в контейнер элементы разных типов).</li>\n</ul>\n<p>Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.</p>\n<p>Пример:</p>\n<p>Давайте представим, что нам в программе нужно описать пользователя, который может пользоваться любыми моделями телефона, чтобы позвонить другому пользователю. Вот как можно это сделать:</p>\n<pre><code class=\"java language-java\">public class User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public void callAnotherUser(int number, AbstractPhone phone) {\n// вот он полиморфизм - использование в коде абстрактного типа AbstractPhone phone!\n        phone.call(number);\n    }\n}\n</code></pre>\n<p>Теперь опишем различные модели телефонов. Одна из первых моделей телефонов:</p>\n<pre><code class=\"java language-java\">public class ThomasEdisonPhone extends AbstractPhone {\n\n    public ThomasEdisonPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вращайте ручку\");\n        System.out.println(\"Сообщите номер абонента, сэр\");\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}\n</code></pre>\n<p>Обычный стационарный телефон:</p>\n<pre><code class=\"java language-java\">public class Phone extends AbstractPhone {\n\n    public Phone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Вызываю номер\" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"Телефон звонит\");\n    }\n}\n</code></pre>\n<p>И, наконец, крутой видеотелефон:</p>\n<pre><code class=\"java language-java\">public class VideoPhone extends AbstractPhone {\n\n    public VideoPhone(int year) {\n        super(year);\n    }\n\n    @Override\n    public void call(int outputNumber) {\n        System.out.println(\"Подключаю видеоканал для абонента \" + outputNumber);\n    }\n\n    @Override\n    public void ring(int inputNumber) {\n        System.out.println(\"У вас входящий видеовызов...\" + inputNumber);\n    }\n}\n</code></pre>\n<p>Создадим объекты в методе main() и протестируем метод callAnotherUser:</p>\n<pre><code class=\"java language-java\">AbstractPhone firstPhone = new ThomasEdisonPhone(1879);\nAbstractPhone phone = new Phone(1984);\nAbstractPhone videoPhone=new VideoPhone(2018);\nUser user = new User(\"Андрей\");\nuser.callAnotherUser(224466,firstPhone);\n// Вращайте ручку\n//Сообщите номер абонента, сэр\nuser.callAnotherUser(224466,phone);\n//Вызываю номер 224466\nuser.callAnotherUser(224466,videoPhone);\n//Подключаю видеоканал для абонента 224466\n</code></pre>\n<p>Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе выполнения программы.</p>\n<p>В примерах классов телефонов, приведенных выше, мы использовали переопределение методов – прием, при котором изменяется реализация метода, определенная в базовом классе, без изменения сигнатуры метода. По сути это является заменой метода, и именно новый метод, определенный в подклассе, вызывается при выполнении программы.</p>\n<p>Обычно, при переопределении метода, используется аннотация @Override, которая подсказывает компилятору о необходимости проверить сигнатуры переопределяемого и переопределяющего методов.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-абстракция","title":"<p>Что такое <em>«абстракция»</em>?</p>","answer":"<p><em>Абстрагирование</em> – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, <strong>абстракция</strong> – это набор всех таких характеристик.</p>\n<blockquote>\n  <p>Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако руль, педали, указатель поворота он будет использовать регулярно.</p>\n</blockquote>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">// Abstract class\nabstract class Animal {\n    // Abstract method (does not have a body)\n    public abstract void animalSound();\n\n    // Regular method\n    public void sleep() {\n        System.out.println(\"Zzz\");\n    }\n}\n\n// Subclass (inherit from Animal)\nclass Pig extends Animal {\n    public void animalSound() {\n        // The body of animalSound() is provided here\n        System.out.println(\"The pig says: wee wee\");\n    }\n}\n\nclass MyMainClass {\n    public static void main(String[] args) {\n        Pig myPig = new Pig(); // Create a Pig object\n        myPig.animalSound();\n        myPig.sleep();\n    }\n}\n</code></pre>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#расскажите-про-основные-понятия-ооп-класс-объект-интерфейс","title":"<p>Расскажите про основные понятия ООП: <em>«класс»</em>, <em>«объект»</em>, <em>«интерфейс»</em></p>","answer":"<p><strong>Класс</strong> – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также\nправила для взаимодействия с данной сущностью (контракт).</p>\n<p>С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций\nдля работы с ними (методов).</p>\n<p>С точки зрения структуры программы, класс является сложным типом данных.</p>\n<p><strong>Объект (экземпляр)</strong> – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью\nопределяемое классом. Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на\nоснове правил, заданных в классе.</p>\n<p><strong>Интерфейс</strong> – это набор методов класса, доступных для использования. Интерфейсом класса будет являться набор всех его\nпубличных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя\nвсе возможные действия над ним.</p>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#в-чем-заключаются-преимущества-и-недостатки-объектно-ориентированного-подхода-в-программировании","title":"<p>В чем заключаются преимущества и недостатки объектно-ориентированного подхода в программировании?</p>","answer":"<p>Преимущества:</p>\n<ul>\n<li>Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.</li>\n<li>Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.</li>\n<li>Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.</li>\n<li>Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.</li>\n<li>Возможность создавать расширяемые системы.</li>\n<li>Использование полиморфизма оказывается полезным при:<ul>\n<li>Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что существенно\nупрощает код. Новые виды могут быть добавлены в любой момент.</li>\n<li>Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что позволяет\nлегко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.</li>\n<li>Реализации работы с наследниками. Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с\nодним видом объектов.</li>\n<li>Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или\nфреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.</li></ul></li>\n<li>Повторное использование кода:<ul>\n<li>Сокращается время на разработку, которое может быть отдано другим задачам.</li>\n<li>Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они\nуже не раз подвергались проверке.</li>\n<li>Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно\nоказывают положительное влияние и на множество работающих с ним программ.</li>\n<li>Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более\nунифицированными, что облегчает ее понимание и упрощает использование.</li></ul></li>\n</ul>\n<p>Недостатки:</p>\n<ul>\n<li>В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.</li>\n<li>Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).</li>\n<li>Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.</li>\n<li>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).</li>\n<li>Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.</li>\n</ul>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-подразумевают-в-плане-принципов-ооп-выражения-является-и-имеет","title":"<p>Что подразумевают в плане принципов ООП выражения <em>«является»</em> и <em>«имеет»</em>?</p>","answer":"<ul>\n<li><strong>«Является»</strong> подразумевает наследование.</li>\n<li><strong>«Имеет»</strong> подразумевает ассоциацию (агрегацию или композицию).</li>\n</ul>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#в-чем-разница-между-композицией-и-агрегацией","title":"<p>В чем разница между <em>композицией</em> и <em>агрегацией</em>?</p>","answer":"<p>Ассоциация обозначает связь между объектами. Композиция и агрегация — частные случаи ассоциации «часть-целое».</p>\n<p>Агрегация предполагает, что объекты связаны взаимоотношением «part-of» (часть). Композиция более строгий вариант агрегации. Дополнительно к требованию «part-of» накладывается условие, что экземпляр «части» может входить только в одно целое (или никуда не входить), в то время как в случае агрегации экземпляр «части» может входить в несколько целых.</p>\n<blockquote>\n  <p>Например, книга состоит из страниц и мы не можем вырвать страницу из книги и вложить в другую книгу. Страницы четко привязаны к конкретной книге, поэтому это композиция.\n  В тоже время мы можем взять и перенести книгу из одной библиотеки в другую - это уже агрегация.</p>\n</blockquote>"},{"subject":"Объектно-ориентированное программирование","url":"001-oop.html#что-такое-статическое-и-динамическое-связывание","title":"<p>Что такое <em>статическое</em> и <em>динамическое связывание</em>?</p>","answer":"<p>Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором (компоновщиком) перед запуском программы, то оно называется <em>статическим</em> или <em>ранним связыванием (early binding)</em>.</p>\n<p>В свою очередь, <em>позднее связывание (late binding)</em> это связывание, проводимое непосредственно во время выполнения программы, в зависимости от типа объекта. Позднее связывание также называют <em>динамическим (dynamic)</em> или <em>связыванием на стадии выполнения (runtime binding)</em>. В языках, реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова методов определяет его и вызывает соответствующее тело метода. Механизм позднего связывания зависит от конкретного языка, но нетрудно предположить, что для его реализации в объекты должна включаться какая-то дополнительная информация.</p>\n<p>Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был объявлен как <code>final</code> (приватные методы являются <code>final</code> по умолчанию).</p>\n<p><a href=\"#объектно-ориентированное-программирование\">к оглавлению</a></p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-интернационализация-локализация","title":"<p>Что такое <em>«интернационализация»</em>, <em>«локализация»</em>?</p>","answer":"<p><strong>Интернационализация (internationalization)</strong> - способ создания приложений, при котором их можно легко адаптировать для разных аудиторий, говорящих на разных языках.</p>\n<p><strong>Локализация (localization)</strong> -  адаптация интерфейса приложения под несколько языков. Добавление нового языка может внести определенные сложности в локализацию интерфейса.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-big-o-o-большое","title":"<p>Что такое Big O («O большое»)?</p>","answer":"<p><strong>Big O («O большое»)</strong> - математическое обозначение для сравнения асимптотического поведения функций. Другими словами в программировании Big O показывает <em>верхнюю границу</em> зависимости между <em>входными параметрами</em> функции и <em>количеством операций</em>, которое выполнит процессор.</p>\n<p>При расчёте Big O:</p>\n<ul>\n<li>отбрасываем константы и неважную сложность,</li>\n<li>последовательные действия — сложение, вложенные действия — умножения.</li>\n</ul>\n<p>В алгоритмах, где каждую итерацию берётся половина элементов, сложность будет включать O(log N), так как максимальное количество итераций равно 2^N,\nгде N - количество элементов.</p>\n<p>Существует также Θ («тета») для точной верхней и нижней оценки, Ω («омега большое») для неточной нижней оценки границы.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#рассчитайте-сложность-следующей-функции","title":"<p>Рассчитайте сложность следующей функции</p>","answer":"<pre><code class=\"java language-java\">int[] a = int[N]; //N - натуральное число\nint s = 0;\nfor (int i = 0; i &lt; a.length; i++) {\n    for (int j = i; i &lt; a.length; i++) {\n        s = i + j;\n    }\n}\n</code></pre>\n<p>Первый массив O(N), второй массив O(N + (N-1) + (N-2) + … + 2 + 1), т.е. общий будет равен O (N^2/2). Отбрасывая константы, получаем в итоге <strong>O (\nN^2)</strong>.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#какие-вы-знаете-алгоритмы-сортировки","title":"<p>Какие Вы знаете алгоритмы сортировки?</p>","answer":"<p>В таблице ниже приведены основные виды сортировок и оценка времени выполнения</p>\n<table>\n<thead>\n<tr>\n<th><strong>Название</strong></th>\n<th><strong>Лучшее</strong></th>\n<th><strong>Среднее</strong></th>\n<th><strong>Худшее</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Quicksort</td>\n<td>Ω(n log(n))</td>\n<td>Θ(n log(n))</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Mergesort</td>\n<td>Ω(n log(n))</td>\n<td>Θ(n log(n))</td>\n<td>O(n log(n))</td>\n</tr>\n<tr>\n<td>Timsort</td>\n<td>Ω(n)</td>\n<td>Θ(n log(n))</td>\n<td>O(n log(n))</td>\n</tr>\n<tr>\n<td>Heapsort</td>\n<td>Ω(n log(n))</td>\n<td>Θ(n log(n))</td>\n<td>O(n log(n))</td>\n</tr>\n<tr>\n<td>Bubble Sort</td>\n<td>Ω(n)</td>\n<td>Θ(n^2)</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Insertion Sort</td>\n<td>Ω(n)</td>\n<td>Θ(n^2)</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Selection Sort</td>\n<td>Ω(n^2)</td>\n<td>Θ(n^2)</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Tree Sort</td>\n<td>Ω(n log(n))</td>\n<td>Θ(n log(n))</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Shell Sort</td>\n<td>Ω(n log(n))</td>\n<td>Θ(n(log(n))^2)</td>\n<td>O(n(log(n))^2)</td>\n</tr>\n<tr>\n<td>Bucket Sort</td>\n<td>Ω(n+k)</td>\n<td>Θ(n+k)</td>\n<td>O(n^2)</td>\n</tr>\n<tr>\n<td>Radix Sort</td>\n<td>Ω(nk)</td>\n<td>Θ(nk)</td>\n<td>O(nk)</td>\n</tr>\n<tr>\n<td>Counting Sort</td>\n<td>Ω(n+k)</td>\n<td>Θ(n+k)</td>\n<td>O(n+k)</td>\n</tr>\n<tr>\n<td>Cubesort</td>\n<td>Ω(n)</td>\n<td>Θ(n log(n))</td>\n<td>O(n log(n))</td>\n</tr>\n</tbody>\n</table>"},{"subject":"Проектирование ПО","url":"002-sd.html#опишите-термин-технический-долг","title":"<p>Опишите термин «технический долг»</p>","answer":"<p><strong>Технический долг</strong> (Technical debt) — это метафора программной инженерии, обозначающая накопленные в программном коде или архитектуре проблемы, связанные с пренебрежением к качеству при разработке программного обеспечения и вызывающие дополнительные затраты труда в будущем. Технический долг обычно незаметен для конечных пользователей продукта, а связан с недостатками в сопровождаемости, тестируемости, понятности, модифицируемости, переносимости.</p>\n<p>Общие причины технического долга (может быть несколько):</p>\n<ul>\n<li><em>Давление заказчика</em>, когда требуется выпустить что-то раньше, чем будут сделаны все необходимые изменения, может вылиться в накопление технического\nдолга.</li>\n<li><em>Отсутствие процессов или понимания</em>, когда заказчик не имеет понятия о технической задолженности и принимает решения без учёта последствий.</li>\n<li><em>Сильное зацепление компонентов</em>, когда декомпозиция системы выполнена неправильно или недостаточно гибко, чтобы адаптироваться к изменениям\nбизнес-потребностей.</li>\n<li><em>Отсутствие тестов</em> — ускоренная разработка и применение быстрых рискованных исправлений («костылей») для исправления ошибок.</li>\n<li><em>Отсутствие взаимодействия между командами</em>, неэффективное управление знаниями в организации. Например, отсутствие наставничества в команде\nразработчиков.</li>\n<li><em>Отложенный рефакторинг</em> — чем дольше задерживается рефакторинг, и чем больше написано кода, использующего текущее состояние проекта, тем больше\nнакапливается технический долг, который нужно \"оплатить\" при следующем рефакторинге.</li>\n<li><em>Отсутствие опыта</em>, когда разработчики просто не умеют проектировать программные системы или писать качественный код.</li>\n</ul>\n<p>Рефакторингом называют процедуру переработки внутренней структуры без изменения внешнего контракта, например для снижения технического долга.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-означает-унаследованный-код","title":"<p>Что означает «унаследованный код»?</p>","answer":"<p><strong>Унаследованный код</strong> (legacy code) нередко употребляется как жаргонное обозначение трудноизменяемого кода, который совершенно непонятен. На самом\nделе унаследованный код — это просто код без тестов.</p>\n<p>Изменения в коде делаются двумя основными способами:</p>\n<ul>\n<li><em>правка наудачу (Edit and Pray)</em></li>\n<li><em>покрытие и модификация (Cover and Modify)</em></li>\n</ul>\n<p>В основу метода Cover and Modify положен принцип работы с «сеткой безопасности». Это своего рода покров из тестов, который мы надеваем на код в\nпроцессе работы, чтобы исключить из него утечку неудачных изменений. Имея в своем распоряжении хороший набор тестов, окружающий фрагмент кода, мы\nможем вносить изменения и быстро обнаруживать их положительное или отрицательное воздействие на код.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-uml","title":"<p>Что такое <em>UML</em>?</p>","answer":"<p><strong>UML</strong> – это унифицированный графический язык моделирования для описания, визуализации, проектирования и документирования объектно-ориентированных систем. UML призван поддерживать процесс моделирования на основе объектно-ориентированного подхода, организовывать взаимосвязь концептуальных и программных понятий, отражать проблемы масштабирования сложных систем.</p>\n<p>Отличительной особенностью UML является то, что словарь этого языка образуют графические элементы. Каждому графическому символу соответствует конкретная семантика, поэтому модель, созданная одним человеком, может однозначно быть понята другим человеком или программным средством, интерпретирующим UML. Отсюда, в частности, следует, что модель системы, представленная на UML, может автоматически быть переведена на объектно-ориентированный язык программирования, то есть, при наличии хорошего инструментального средства визуального моделирования, поддерживающего UML, построив модель, мы получим и заготовку программного кода, соответствующего этой модели.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-диаграмма-нотация-и-метамодель-в-uml","title":"<p>Что такое <em>«диаграмма»</em>, <em>«нотация»</em> и <em>«метамодель»</em> в UML?</p>","answer":"<p><strong>Диаграмма</strong> - графическое представление совокупности элементов модели в форме связного графа, вершинам и ребрам (дугам) которого приписывается определенная семантика</p>\n<p><strong>Нотация</strong> – совокупность символов и правила их применения, используются для представления понятий и связей между ними.\nНотация диаграммы определяет способ представления, ассоциации, множественности. Причем эти понятия должны быть точно определены.</p>\n<p><strong>Метамодель</strong> – диаграмма, определяющая нотацию.\nМетамодель помогает понять, что такое хорошо организованная, т.е. синтаксически правильная, модель.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#какие-существуют-типы-диаграмм-в-uml","title":"<p>Какие существуют типы диаграмм в UML?</p>","answer":"<h3 id=\"\">Структурные диаграммы:</h3>\n<p><strong>классов (Class diagram)</strong> описывает структуру системы, демонстрирующая классы системы, их атрибуты, методы и зависимости между классами.</p>\n<p><strong>объектов (Object diagram)</strong> демонстрирует полный или частичный снимок моделируемой системы в заданный момент времени. На диаграмме объектов отображаются экземпляры классов (объекты) системы с указанием текущих значений их атрибутов и связей между объектами.</p>\n<p><strong>компонентов (Component diagram)</strong> показывает разбиение программной системы на структурные компоненты и связи (зависимости) между компонентами.</p>\n<ul>\n<li><p><strong>развёртывания/размещения (Deployment diagram)</strong> служит для моделирования работающих узлов и артефактов, развёрнутых на них.</p></li>\n<li><p><strong>пакетов (Package diagram)</strong> используется для организации элементов в группы по какому-либо признаку с целью упрощения структуры и организации работы с моделью системы.</p></li>\n<li><p><strong>профилей (Profile diagram)</strong> действует на уровне метамодели и показывает стереотип класса или пакета.</p></li>\n<li><p><strong>композитной/составной структуры (Composite structure diagram)</strong> демонстрирует внутреннюю структуру класса и, по возможности, взаимодействие элементов (частей) его внутренней структуры.</p></li>\n<li><p><strong>кооперации (Collaboration diagram)</strong> показывает роли и взаимодействие классов в рамках кооперации.</p></li>\n</ul>\n<h3 id=\"-1\">Диаграммы поведения:</h3>\n<p><strong>деятельности (Activity diagram)</strong> показывает разложение некоторой деятельности на её составные части. Под деятельностью понимается спецификация исполняемого поведения в виде координированного последовательного и параллельного выполнения подчинённых элементов — вложенных видов деятельности и отдельных действий, соединённых между собой потоками, которые идут от выходов одного узла к входам другого. Диаграммы деятельности используются при моделировании бизнес-процессов, технологических процессов, последовательных и параллельных вычислений.</p>\n<p><strong>состояний/автомата/конечного автомата (State Machine diagram)</strong> представляет конечный автомат с простыми состояниями, переходами и композитными состояниями. Конечный автомат (State machine) — спецификация последовательности состояний, через которые проходит объект или взаимодействие в ответ на события своей жизни, а также ответные действия объекта на эти события. Конечный автомат прикреплён к исходному элементу (классу, кооперации или методу) и служит для определения поведения его экземпляров.</p>\n<p><strong>вариантов использования/прецедентов (Use case diagram)</strong> отражает отношения существующие между актёрами и вариантами использования. Основная задача — представлять собой единое средство, дающее возможность заказчику, конечному пользователю и разработчику совместно обсуждать функциональность и поведение системы.</p>\n<p><strong>взаимодействия (Interaction diagram)</strong>:</p>\n<ul>\n<li><p><strong>коммуникации (Communication diagram)</strong> изображает взаимодействия между частями композитной структуры или ролями кооперации при этом явно указываются отношения между элементами (объектами), а время как отдельное измерение не используется (применяются порядковые номера вызовов).</p></li>\n<li><p><strong>последовательности (Sequence diagram)</strong> показывает взаимодействия объектов, упорядоченные по времени их проявления.</p></li>\n<li><p><strong>обзора взаимодействия (Interaction overview diagram)</strong> — разновидность диаграммы деятельности, включающая фрагменты диаграммы последовательности и конструкции потока управления.</p></li>\n<li><p><strong>синхронизации (Timing diagram)</strong> — альтернативное представление диаграммы последовательности, явным образом показывающее изменения состояния на линии жизни с заданной шкалой времени. Может быть полезна в приложениях реального времени.</p></li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#какие-виды-отношений-существуют-в-структурной-диаграмме-классов-в-uml","title":"<p>Какие виды отношений существуют в структурной диаграмме классов в UML?</p>","answer":"<h3 id=\"\">Взаимосвязи классов</h3>\n<p><strong>Обобщение (Generalization)</strong> показывает, что один из двух связанных классов (подтип) является частной формой другого (супертипа), который называется обобщением первого. На практике это означает, что любой экземпляр подтипа является также экземпляром супертипа. Обобщение также известно как <em>наследование</em>, <em>«is a» взаимосвязь</em> или <em>отношение «является»</em>.</p>\n<blockquote>\n  <p>«Табурет» является подтипом «Мебели».</p>\n</blockquote>\n<p><strong>Реализация (Implementation)</strong> — отношение между двумя элементами модели, в котором один элемент (клиент) реализует поведение, заданное другим (поставщиком). Реализация — отношение целое-часть. Поставщик, как правило, является абстрактным классом или классом-интерфейсом.</p>\n<blockquote>\n  <p>«Кровать» реализует поведение «Мебели для сна»</p>\n</blockquote>\n<h3 id=\"-1\">Взаимосвязи объектов классов</h3>\n<p><strong>Зависимость (Dependency)</strong> обозначает такое отношение между классами, что изменение спецификации класса-поставщика может повлиять на работу зависимого класса, но не наоборот.</p>\n<blockquote>\n  <p>«Расписание занятий» имеет зависимость от «Списка предметов». При изменении списка предметов расписание занятий будет вынуждено изменится. Однако изменение расписания занятий никак не влияет на список предметов.</p>\n</blockquote>\n<p><strong>Ассоциация (Association)</strong> показывает, что объекты одной сущности (класса) связаны с объектами другой сущности таким образом, что можно перемещаться от объектов одного класса к другому. Является общим случаем композиции и агрегации.</p>\n<blockquote>\n  <p>«Студент» и «Университет» имеют ассоциацию т.к. студент может учиться в университете и этой ассоциации можно присвоить имя «учится в».</p>\n</blockquote>\n<p><strong>Агрегация (Aggregation)</strong> — это разновидность ассоциации в отношении между целым и его частями. Как тип ассоциации агрегация может быть именованной. Одно отношение агрегации не может включать более двух классов (контейнер и содержимое). Агрегация встречается, когда один класс является коллекцией или контейнером других. Причём по умолчанию, агрегацией называют агрегацию по ссылке, то есть когда время существования содержащихся классов не зависит от времени существования содержащего их класса. Если контейнер будет уничтожен, то его содержимое — нет.</p>\n<blockquote>\n  <p>«Студент» не является неотъемлемой частью «Группы», но в то же время, группа состоит из студентов, поэтому следует использовать агрегацию.</p>\n</blockquote>\n<p><strong>Композиция (Composition)</strong> — более строгий вариант агрегации. Известна также как агрегация по значению. Композиция имеет жёсткую зависимость времени существования экземпляров класса контейнера и экземпляров содержащихся классов. Если контейнер будет уничтожен, то всё его содержимое будет также уничтожено.</p>\n<blockquote>\n  <p>«Факультет» является частью «Университета» и факультет без университета существовать не может, следовательно, здесь подходит композиция.</p>\n</blockquote>\n<h3 id=\"-2\">Общие взаимосвязи</h3>\n<p><strong>Зависимость</strong> — это слабая форма отношения использования, при котором изменение в спецификации одного влечёт за собой изменение другого, причём обратное не обязательно. Возникает, когда объект выступает, например, в форме параметра или локальной переменной. Существует несколько именованных вариантов. Зависимость может быть между экземплярами, классами или экземпляром и классом.</p>\n<p><strong>Уточнение отношений</strong> имеет отношение к уровню детализации. Один пакет уточняет другой, если в нём содержатся те же самые элементы, но в более подробном представлении.</p>\n<p><strong>Мощность/кратность/мультипликатор отношения</strong> означает число связей между каждым экземпляром класса (объектом) в начале линии с экземпляром класса в её конце. Различают следующие типичные случаи:</p>\n<table>\n<thead>\n<tr>\n<th>Нотация</th>\n<th>Объяснение</th>\n<th>Пример</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0..1</td>\n<td>Ноль или один экземпляр</td>\n<td>кошка имеет или не имеет хозяина</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Обязательно один экземпляр</td>\n<td>у кошки одна мать</td>\n</tr>\n<tr>\n<td>0..<em>или</em></td>\n<td>Ноль или более экземпляров</td>\n<td>у кошки могут быть, а может и не быть котят</td>\n</tr>\n<tr>\n<td>1..*</td>\n<td>Один или более экземпляров</td>\n<td>у кошки есть хотя бы одно место, где она спит</td>\n</tr>\n</tbody>\n</table>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-solid","title":"<p>Что такое SOLID?</p>","answer":"<p>SOLID (сокр. от англ. single responsibility, open-closed, Liskov substitution, interface segregation и dependency inversion) в программировании — мнемонический акроним, введённый Michael Feathers для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов объектно-ориентированного программирования и проектирования. При создании программных систем использование принципов SOLID способствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени. Принципы SOLID — это руководства, которые также могут применяться во время работы над существующим программным обеспечением для его улучшения - например для удаления «дурно пахнущего кода».</p>\n<ul>\n<li><strong>Принцип единственной ответственности (The Single Responsibility Principle, SRP)</strong> — принцип ООП, обозначающий, что каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.</li>\n<li><strong>При́нцип откры́тости/закры́тости (The Open Closed Principle, OCP)</strong> - принцип ООП, устанавливающий следующее положение: «программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения».</li>\n<li><strong>Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)</strong> - в объектно-ориентированном программировании является специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под названием Абстракция данных и иерархия.</li>\n<li><strong>Принцип разделения интерфейса (Interface Segregation Principle, ISP)</strong> - данный принцип говорит, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе.</li>\n<li><strong>Принцип инверсии зависимостей (Dependency inversion principle, DIP)</strong> - важный принцип объектно-ориентированного программирования, используемый для уменьшения зацепления в компьютерных программах. Является частным случаем «Инверсии контроля» (Inversion of Control).</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-шаблон-проектирования","title":"<p>Что такое <em>«шаблон проектирования»</em>?</p>","answer":"<p><strong>Шаблон (паттерн) проектирования (design pattern)</strong> — это проверенное и готовое к использованию решение. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее - он не зависит от языка программирования, не является законченным образцом, который может быть прямо преобразован в код и может быть реализован по разному в разных языках программирования.</p>\n<p>Плюсы использования шаблонов:</p>\n<ul>\n<li>снижение сложности разработки за счёт готовых абстракций для решения целого класса проблем.</li>\n<li>облегчение коммуникации между разработчиками, позволяя ссылаться на известные шаблоны.</li>\n<li>унификация деталей решений: модулей и элементов проекта.</li>\n<li>возможность отыскав удачное решение, пользоваться им снова и снова.</li>\n<li>помощь в выборе выбрать наиболее подходящего варианта проектирования.</li>\n</ul>\n<p>Минусы:</p>\n<ul>\n<li>слепое следование некоторому выбранному шаблону может привести к усложнению программы.</li>\n<li>желание попробовать некоторый шаблон в деле без особых на то оснований.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#назовите-основные-характеристики-шаблонов","title":"<p>Назовите основные характеристики шаблонов</p>","answer":"<ul>\n<li><strong>Имя</strong> - все шаблоны имеют уникальное имя, служащее для их идентификации;</li>\n<li><strong>Назначение</strong> назначение данного шаблона;</li>\n<li><strong>Задача</strong> - задача, которую шаблон позволяет решить;</li>\n<li><strong>Способ решения</strong> - способ, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;</li>\n<li><strong>Участники</strong> - сущности, принимающие участие в решении задачи;</li>\n<li><strong>Следствия</strong> - последствия от использования шаблона как результат действий, выполняемых в шаблоне;</li>\n<li><strong>Реализация</strong> - возможный вариант реализации шаблона.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#типы-шаблонов-проектирования","title":"<p>Типы шаблонов проектирования</p>","answer":"<ul>\n<li>Основные (Fundamental) - основные строительные блоки других шаблонов. Большинство других шаблонов использует эти\nшаблоны в той или иной форме.</li>\n<li>Порождающие шаблоны (Creational) — шаблоны проектирования, которые абстрагируют процесс создание экземпляра. Они\nпозволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий\nклассы, использует наследование, чтобы изменять созданный объект, а шаблон, порождающий объекты, делегирует создание\nобъектов другому объекту.</li>\n<li>Структурные шаблоны (Structural) определяют различные сложные структуры, которые изменяют интерфейс уже существующих\nобъектов или его реализацию, позволяя облегчить разработку и оптимизировать программу.</li>\n<li>Поведенческие шаблоны (Behavioral) определяют взаимодействие между объектами, увеличивая таким образом его гибкость.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#приведите-примеры-основных-шаблонов-проектирования","title":"<p>Приведите примеры основных шаблонов проектирования</p>","answer":"<ul>\n<li><strong>Делегирование (Delegation pattern)</strong> - Сущность внешне выражает некоторое поведение, но в реальности передаёт\nответственность за выполнение этого поведения связанному объекту.</li>\n<li><strong>Функциональный дизайн (Functional design)</strong> - Гарантирует, что каждая сущность имеет только одну обязанность и\nисполняет её с минимумом побочных эффектов на другие.</li>\n<li><strong>Неизменяемый интерфейс (Immutable interface)</strong> - Создание неизменяемого объекта.</li>\n<li><strong>Интерфейс (Interface)</strong> - Общий метод структурирования сущностей облегчающий их понимание.</li>\n<li><strong>Интерфейс-маркер (Marker interface)</strong> - В качестве атрибута (как пометки объектной сущности) применяется наличие или\nотсутствие реализации интерфейса-маркера. В современных языках программирования вместо этого применяются атрибуты или\nаннотации.</li>\n<li><strong>Контейнер свойств (Property container)</strong> - Позволяет добавлять дополнительные свойства сущности в контейнер внутри\nсебя, вместо расширения новыми свойствами.</li>\n<li><strong>Канал событий (Event channel)</strong> - Создаёт централизованный канал для событий. Использует сущность-представитель для\nподписки и сущность-представитель для публикации события в канале. Представитель существует отдельно от реального\nиздателя или подписчика. Подписчик может получать опубликованные события от более чем одной сущности, даже если он\nзарегистрирован только на одном канале.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#приведите-примеры-порождающих-шаблонов-проектирования","title":"<p>Приведите примеры порождающих шаблонов проектирования</p>","answer":"<ul>\n<li><strong>Абстрактная фабрика (Abstract factory)</strong> - Класс, который представляет собой интерфейс для создания других классов.</li>\n<li><strong>Строитель (Builder)</strong> - Класс, который представляет собой интерфейс для создания сложного объекта.</li>\n<li><strong>Фабричный метод (Factory method)</strong> - Делегирует создание объектов наследникам родительского класса. Это позволяет\nиспользовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком\nуровне.</li>\n<li><strong>Прототип (Prototype)</strong> - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания\nчерез конструктор.</li>\n<li><strong>Одиночка (Singleton)</strong> - Класс, который может иметь только один экземпляр.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#приведите-примеры-структурных-шаблонов-проектирования","title":"<p>Приведите примеры структурных шаблонов проектирования</p>","answer":"<ul>\n<li><strong>Адаптер (Adapter)</strong> - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а\nдругой предоставляет несовместимый с первым интерфейс.</li>\n<li><strong>Мост (Bridge)</strong> - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.</li>\n<li><strong>Компоновщик (Composite)</strong> - Объект, который объединяет в себе объекты, подобные ему самому.</li>\n<li><strong>Декоратор(Decorator)</strong> - Класс, расширяющий функциональность другого класса без использования наследования.</li>\n<li><strong>Фасад (Facade)</strong> - Объект, который абстрагирует работу с несколькими классами, объединяя их в единое целое.</li>\n<li><strong>Приспособленец (Flyweight)</strong> - Это объект, представляющий себя как уникальный экземпляр в разных местах программы,\nно по факту не являющийся таковым.</li>\n<li><strong>Заместитель (Proxy)</strong> - Объект являющийся посредником между двумя другими объектами и реализующий/ограничивающий\nдоступ к объекту, к которому обращаются через него.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#приведите-примеры-поведенческих-шаблонов-проектирования","title":"<p>Приведите примеры поведенческих шаблонов проектирования</p>","answer":"<ul>\n<li><strong>Цепочка обязанностей (Chain of responsibility)</strong> - Предназначен для организации в системе уровней ответственности.</li>\n<li><strong>Команда (Command)</strong> - Представляет действие. Объект команды заключает в себе само действие и его параметры.</li>\n<li><strong>Интерпретатор (Interpreter)</strong> - Решает часто встречающуюся, но подверженную изменениям, задачу.</li>\n<li><strong>Итератор(Iterator)</strong> - Представляет собой объект, позволяющий получить последовательный доступ к элементам\nобъекта-агрегата без использования описаний каждого + __из объектов, входящих в состав агрегации.</li>\n<li><strong>Посредник (Mediator)</strong> - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и\nизбавляя объекты от необходимости явно ссылаться друг на друга.</li>\n<li><strong>Хранитель (Memento)</strong> - Позволяет не нарушая инкапсуляцию зафиксировать и сохранить внутренние состояния объекта\nтак, чтобы позднее восстановить его в этих состояниях.</li>\n<li><strong>Наблюдатель(Observer)</strong> - Определяет зависимость типа «один ко многим» между объектами таким образом, что при\nизменении состояния одного объекта все зависящие от него оповещаются об этом событии.</li>\n<li><strong>Состояние (State)</strong> - Используется в тех случаях, когда во время выполнения программы объект должен менять своё\nповедение в зависимости от своего состояния.</li>\n<li><strong>Стратегия (Strategy)</strong> - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и\nобеспечения их взаимозаменяемости.</li>\n<li><strong>Шаблонный метод (Template method)</strong> - Определяет основу алгоритма и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.</li>\n<li><strong>Посетитель (Visitor)</strong> - Описывает операцию, которая выполняется над объектами других классов. При изменении класса Visitor нет необходимости изменять обслуживаемые классы.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-шаблон-mvc","title":"<p>Что такое шаблон MVC?</p>","answer":"<p><strong>Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер»)</strong>— схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо.</p>\n<ul>\n<li><strong>Модель (Model)</strong> - предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.</li>\n<li><strong>Представление (View)</strong> - отвечает за отображение данных модели пользователю, реагируя на изменения модели.</li>\n<li><strong>Контроллер (Controller)</strong> - интерпретирует действия пользователя, оповещая модель о необходимости изменений.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-grasp","title":"<p>Что такое GRASP?</p>","answer":"<p><strong>GRASP (англ. general responsibility assignment software patterns)</strong> — шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам. В книге Крейга Лармана «Применение UML и шаблонов проектирования» описано 9 таких шаблонов: каждый помогает решить некоторую проблему, возникающую как в объектно-ориентированном анализе, так и в практически любом проекте по разработке программного обеспечения. Таким образом, шаблоны «G.R.A.S.P.» — хорошо документированные, стандартизированные и проверенные временем принципы объектно-ориентированного анализа, а не попытка привнести что-то принципиально новое.</p>\n<ul>\n<li><strong>Информационный эксперт (Information Expert)</strong> - ответственность должна быть назначена тому, кто владеет максимумом необходимой информации для исполнения. Если его не учесть — получится спагетти-код, в котором трудно разобраться.</li>\n<li><strong>Создатель (Creator)</strong> - класс должен создавать экземпляры тех классов, которые он может <em>содержать или агрегировать</em>, <em>записывать</em>, <em>использовать</em>, <em>инициализировать, имея нужные данные</em>.</li>\n<li><strong>Контроллер (Controller)</strong> - отвечает за операции, запросы на которые приходят от пользователя, и может выполнять сценарии одного или нескольких вариантов использования (например, создание и удаление). Не выполняет работу самостоятельно, а делегирует компетентным исполнителям.</li>\n<li><strong>Слабое зацепление (Low Coupling)</strong> - мера неотрывности элемента от других элементов (либо мера данных, имеющихся у него о них).</li>\n<li><strong>Высокая связность (High Cohesion)</strong> - мера сфокусированности предметных областей его методов.</li>\n<li><strong>Полиморфизм (Polymorphism)</strong> - <a href=\"001-oop.md#Что-такое-полиморфизм\">Что такое <em>«полиморфизм»</em>?</a>.</li>\n<li><strong>Чистая выдумка (Pure Fabrication)</strong> - Не относится к предметной области, но уменьшает зацепление, повышает связность, упрощает повторное использование,  отражает концепцию сервисов в модели проблемно-ориентированного проектирования.</li>\n<li><strong>Посредник (Indirection)</strong> - слабое зацепление между элементами системы (и возможность повторного использования) обеспечивается назначением промежуточного объекта их посредником.</li>\n<li><strong>Устойчивость к изменениям (Protected Variations)</strong> - Шаблон защищает элементы от изменения другими элементами (объектами или подсистемами) с помощью вынесения взаимодействия в фиксированный интерфейс, через который (и только через который) возможно взаимодействие между элементами. Поведение может варьироваться лишь через создание другой реализации интерфейса.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-антипаттерн-какие-антипаттерны-вы-знаете","title":"<p>Что такое <em>«антипаттерн»</em>? Какие антипаттерны вы знаете?</p>","answer":"<p><strong>Антипаттерн (anti-pattern)</strong> — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.</p>\n<p><strong>Poltergeists (полтергейсты)</strong> - это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие классы задумываются как классы-контроллеры, которые существуют только для вызова методов других классов, зачастую в предопределенной последовательности.</p>\n<p>Признаки появления и последствия антипаттерна</p>\n<ul>\n<li>Избыточные межклассовые связи.</li>\n<li>Временные ассоциации.</li>\n<li>Классы без состояния (содержащие только методы и константы).</li>\n<li>Временные объекты и классы (с непродолжительным временем жизни).</li>\n<li>Классы с единственным методом, который предназначен только для создания или вызова других классов посредством временной ассоциации.</li>\n<li>Классы с именами методов в стиле «управления», такие как startProcess.</li>\n</ul>\n<p>Типичные причины</p>\n<ul>\n<li>Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).</li>\n<li>Неправильный выбор пути решения задачи.</li>\n<li>Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.</li>\n</ul>\n<p><strong>Внесенная сложность (Introduced complexity)</strong>: Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».</p>\n<p><strong>Инверсия абстракции (Abstraction inversion)</strong>: Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.</p>\n<p><strong>Неопределённая точка зрения (Ambiguous viewpoint)</strong>: Представление модели без спецификации её точки рассмотрения.</p>\n<p><strong>Большой комок грязи (Big ball of mud)</strong>: Система с нераспознаваемой структурой.</p>\n<p><strong>Божественный объект (God object)</strong>: Концентрация слишком большого количества функций в одной части системы (классе).</p>\n<p><strong>Затычка на ввод данных (Input kludge)</strong>: Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.</p>\n<p><strong>Раздувание интерфейса (Interface bloat)</strong>: Разработка интерфейса очень мощным и очень сложным для реализации.</p>\n<p><strong>Волшебная кнопка (Magic pushbutton)</strong>: Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.</p>\n<p><strong>Перестыковка (Re-Coupling)</strong>: Процесс внедрения ненужной зависимости.</p>\n<p><strong>Дымоход (Stovepipe System)</strong>: Редко поддерживаемая сборка плохо связанных компонентов.</p>\n<p><strong>Состояние гонки (Race hazard)</strong>: отсутствие предвидения возможности наступления событий в порядке, отличном от ожидаемого.</p>\n<p><strong>Членовредительство (Mutilation)</strong>: Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.</p>\n<p><strong>Сохранение или смерть (Save or die)</strong>: Сохранение изменений лишь при завершении приложения.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-domain-driven-design","title":"<p>Что такое Domain-driven design?</p>","answer":"<p>Предметно-ориентированное проектирование (реже проблемно-ориентированное, англ. Domain-driven design, DDD) — это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом. Предметно-ориентированное проектирование не является какой-либо конкретной технологией или методологией. DDD — это набор правил, которые позволяют принимать правильные проектные решения. Данный подход позволяет значительно ускорить процесс проектирования программного обеспечения в незнакомой предметной области. Подход DDD особо полезен в ситуациях, когда разработчик не является специалистом в области разрабатываемого продукта. К примеру: программист не может знать все области, в которых требуется создать ПО, но с помощью правильного представления структуры, посредством предметно-ориентированного подхода, может без труда спроектировать приложение, основываясь на ключевых моментах и знаниях рабочей области.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#какие-бывают-гарантии-доставки-сообщений","title":"<p>Какие бывают гарантии доставки сообщений?</p>","answer":"<ul>\n<li><strong>At-most-once delivery</strong> (“как максимум однократная доставка”). Это значит, что сообщение не может быть доставлено больше одного раза. При этом сообщение может быть потеряно.</li>\n<li><strong>At-least-once delivery</strong> (“как минимум однократная доставка”). Это значит, что сообщение никогда не будет потеряно. При этом сообщение может быть доставлено более одного раза.</li>\n<li><strong>Exactly-once delivery</strong> (“строго однократная доставка”). Все сообщения доставляются строго единожды.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-event-driven-architecture","title":"<p>Расскажите про Event-driven Architecture</p>","answer":"<p><strong>Архитектура, управляемая событиями</strong> (англ. <em>event-driven architecture, EDA</em>) является шаблоном архитектуры программного обеспечения, позволяющим создание, определение, потребление и реакцию на события.</p>\n<p>Событие можно определить как «существенное изменение состояния». Например, когда покупатель приобретает автомобиль, состояние автомобиля изменяется с «продаваемого» на «проданный». Системная архитектура продавца автомобилей может рассматривать это изменение состояния как событие, создаваемое, публикуемое, определяемое и потребляемое различными приложениями в составе архитектуры.</p>\n<p>Этот архитектурный шаблон может применяться при разработке и реализации приложений и систем, передающих события среди слабосвязанных программных компонентов и служб. Система, управляемая событиями, обычно содержит источники событий (или агентов) и потребителей событий (или стоков). Стоки ответственны за ответную реакцию, как только событие возникло. Реакция может полностью или не полностью создаваться стоком. К примеру, сток может отвечать лишь за фильтрацию, преобразование и доставку события другому компоненту, либо он может создать собственную реакцию на это событие. Первая категория стоков может основываться на традиционных компонентах, таких как промежуточное программное обеспечение для обмена сообщениями, а вторая категория стоков (формирующая собственную реакцию в процессе работы) может потребовать наличия более подходящей платформы выполнения транзакций.</p>\n<p>Создание приложений и систем в рамках архитектуры, управляемой событиями, позволяет им быть сконструированными способом, способствующим лучшей интерактивности, поскольку системы, управляемые событиями, по структуре более ориентированы на непредсказуемые и асинхронные окружения.</p>\n<p>Архитектура, управляемая событиями соответствует <em>сервисно-ориентированной архитектуре (SOA)</em>, поскольку сервисы могут активироваться триггерами, срабатывающими от входящих событий.</p>\n<p>Эта парадигма особенно полезна в случае, когда сток не предоставляет собственного исполнения действий.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-service-oriented-architecture-soa","title":"<p>Расскажите про Service-oriented Architecture (SOA)?</p>","answer":"<p><strong>Сервис-ориентированная архитектура</strong> (англ. <em>service-oriented architecture, SOA</em>) — модульный подход к разработке программного обеспечения, основанный на использовании распределённых, слабо связанных (англ. loose coupling) заменяемых компонентов, оснащённых стандартизированными интерфейсами для взаимодействия по стандартизированным протоколам.</p>\n<p>Программные комплексы, разработанные в соответствии с сервис-ориентированной архитектурой, обычно реализуются как набор веб-служб, взаимодействующих по протоколу SOAP, но существуют и другие реализации (например, на базе jini, CORBA, на основе REST).</p>\n<p>Интерфейсы компонентов в сервис-ориентированной архитектуре инкапсулируют детали реализации (операционную систему, платформу, язык программирования) от остальных компонентов, таким образом обеспечивая комбинирование и многократное использование компонентов для построения сложных распределённых программных комплексов, обеспечивая независимость от используемых платформ и инструментов разработки, способствуя масштабируемости и управляемости создаваемых систем.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-микросервисы","title":"<p>Что такое <em>микросервисы</em>?</p>","answer":"<p><strong>Микросервисная архитектура</strong> (англ. microservice architecture, MSA) — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — <em>микросервисов</em>.</p>\n<p>Свойства, характерные для микросервисной архитектуры:</p>\n<ul>\n<li>модули можно легко заменить в любое время: акцент на простоту, независимость развёртывания и обновления каждого из микросервисов;</li>\n<li>модули организованы вокруг функций: микросервис по возможности выполняет только одну достаточно элементарную функцию;</li>\n<li>модули могут быть реализованы с использованием различных языков программирования, фреймворков, связующего программного обеспечения, выполняться в различных средах контейнеризации, виртуализации, под управлением различных операционных систем на различных аппаратных платформах: приоритет отдаётся в пользу наибольшей эффективности для каждой конкретной функции, нежели стандартизации средств разработки и исполнения;\nархитектура симметричная, а не иерархическая: зависимости между микросервисами одноранговые.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-enterprise-integration-patterns-eip","title":"<p>Расскажите про Enterprise Integration Patterns (EIP)?</p>","answer":"<p><strong>Шаблоны интеграции корпоративных приложений</strong> (англ. <em>enterprise integration patterns, EIP</em>) состоят из 65 шаблонов, которые описывают использование приложений уровня предприятия и <em>связующего программное обеспечения, ориентированного на обработку сообщений</em> (англ. <em>message-oriented middleware, MOM</em>).</p>\n<p>Реализуются такими продуктами, как Spring Integration, Apache Camel, Red Hat Fuse, Mule ESB and Guarana DSL.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-patterns-of-enterprise-applications-architecture-poeaa","title":"<p>Расскажите про Patterns of Enterprise Applications Architecture (PoEAA)?</p>","answer":"<p>Каталог архитектурных шаблонов приложений уровня предприятия, состоит из следующих категорий:</p>\n<ul>\n<li><strong>Domain Logic Patterns</strong></li>\n<li><strong>Data Source Architectural Patterns</strong></li>\n<li><strong>Object-Relational Behavioral Patterns</strong></li>\n<li><strong>Object-Relational Structural Patterns</strong></li>\n<li><strong>Object-Relational Metadata Mapping Patterns</strong></li>\n<li><strong>Web Presentation Patterns</strong></li>\n<li><strong>Distribution Patterns</strong></li>\n<li><strong>Offline Concurrency Patterns</strong></li>\n<li><strong>Session State Patterns</strong></li>\n<li><strong>Base Patterns</strong></li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-cqrs","title":"<p>Расскажите про CQRS?</p>","answer":"<p><strong>Разделение ответственности на команды и запросы</strong> (англ. command-query responsibility segregation, CQRS) — шаблон проектирования для разделения операций чтения и записи, где первый - это запрос, а второй - команда. Команды изменяют состояние и, следовательно, приблизительно эквивалентны вызову метода для агрегатных корней / сущностей. Запрашивает состояние запроса, но не изменяет его. CQRS является производным архитектурным шаблоном из шаблона проектирования под названием «Разделение команд и запросов» (CQS), который был придуман Бертраном Мейером. В то время как CQRS не требует DDD, проектирование на основе домена делает явным различие между командами и запросами вокруг концепции совокупного корня. Идея состоит в том, что данный агрегатный корень имеет метод, соответствующий команде, и обработчик команд вызывает метод в агрегатном корне. Совокупный корень отвечает за выполнение логики операции и выдачу либо количества событий, либо ответа об ошибке (перечисление / номер исключения или результата выполнения) ИЛИ (если не используется Event Sourcing (ES)), просто изменяющего свое состояние для сохранить реализацию, такую ​​как ORM, для записи в хранилище данных, в то время как обработчик команд отвечает за рассмотрение проблем инфраструктуры, связанных с сохранением состояния или событий совокупного корня, и создание необходимых контекстов (например, транзакций).</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#расскажите-про-event-sourcing","title":"<p>Расскажите про Event Sourcing?</p>","answer":"<p><strong>(англ. event sourcing, ES)</strong> - шаблон проектирования, который гарантирует, что ваши сущности (согласно <em>DDD</em>) не\nотслеживают свое внутреннее состояние посредством прямой сериализации или ORM, а посредством чтения и фиксации событий в\nхранилище событий. В тех случаях, когда ES объединяется с CQRS и DDD, совокупные корни отвечают за тщательную проверку и\nприменение команд (часто с помощью вызова методов их экземпляров из обработчика команд), а затем за публикацию одного\nили нескольких событий, которые также являются основой для которые агрегированные корни основывают свою логику для\nработы с вызовами методов. Следовательно, входные данные представляют собой команду, а выходные данные представляют\nсобой одно или несколько событий, которые транзакционно (единая фиксация) сохраняются в хранилище событий, а затем часто\nпубликуются в брокере сообщений для пользы тех, кто заинтересован (часто представления интересуются; они затем\nзапрашиваются с помощью Query-сообщений). При моделировании ваших агрегатных корней для выходных событий вы можете\nизолировать внутреннее состояние даже дальше, чем это было бы возможно при проецировании данных чтения из ваших\nсущностей, как это делается в стандартных n-уровневых архитектурах передачи данных. Одним из существенных преимуществ\nэтого является то, что такие инструменты, как средства аксиоматической проверки теорем (например, Microsoft Contracts и\nCHESS), проще в применении, поскольку совокупный корень полностью скрывает свое внутреннее состояние. События часто\nсохраняются в зависимости от версии совокупного корневого экземпляра, что дает модель предметной области, которая\nсинхронизируется в распределенных системах вокруг концепции оптимистичного параллелизма.</p>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-acid","title":"<p>Что такое ACID?</p>","answer":"<p>В информатике акроним ACID описывает требования к транзакционной системе (например, к СУБД), обеспечивающие наиболее надёжную и предсказуемую её работу.</p>\n<ul>\n<li><p><strong>Атомарность (англ. atomicity)</strong> - гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние — со стороны будет казаться, что транзакции и не было. (Естественно, счётчики, индексы и другие внутренние структуры могут измениться, но, если СУБД запрограммирована без ошибок, это не повлияет на внешнее её поведение.)</p></li>\n<li><p><strong>Согласованность (англ. consistency)</strong>. Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки четвёртого свойства.</p></li>\n</ul>\n<p>Согласованность является более широким понятием. Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.</p>\n<p>Наконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.</p>\n<ul>\n<li><p><strong>Изолированность (англ. isolation)</strong>. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).</p></li>\n<li><p><strong>Стойкость (англ. durability)</strong>\nНезависимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.</p></li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#в-чем-смысл-cap-теоремы","title":"<p>В чем смысл CAP теоремы?</p>","answer":"<p><strong>Теорема CAP</strong> — эвристическое утверждение, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:</p>\n<ul>\n<li><strong>C - (англ. consistency) согласованность данных</strong> — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;</li>\n<li><strong>A - (англ. availability) доступность</strong> — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;</li>\n<li><strong>P - (англ. partition tolerance) устойчивость к разделению</strong> — расщепление распределённой системы на несколько изолированных секций не приводит к некорректности отклика от каждой из секций.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-base-архитектура","title":"<p>Что такое BASE-архитектура?</p>","answer":"<p><strong>BASE (англ. Basically Available, Soft-state, Eventually consistent)</strong>  — базовая доступность, неустойчивое состояние, согласованность в конечном счёте - подход построения распределённых систем. Такой подход напрямую противопоставляется ACID.</p>\n<ul>\n<li><strong>Basically Available (базовая доступность)</strong> - подразумевается такой подход к проектированию приложения, чтобы сбой в некоторых узлах приводил к отказу в обслуживании только для незначительной части сессий при сохранении доступности в большинстве случаев.</li>\n<li><strong>Soft-state (неустойчивое состояние)</strong>  - подразумевает возможность жертвовать долговременным хранением состояния сессий (таких, как промежуточные результаты выборок, информация о навигации, контексте), при этом концентрируясь на фиксации обновлений только критичных операций.</li>\n<li><strong>Eventually consistent (согласованность в конечном счёте)</strong> - трактуется, как возможность противоречивости данных в некоторых случаях, но при обеспечении согласования в практически обозримое время, посвящено значительное количество самостоятельных исследований.</li>\n</ul>"},{"subject":"Проектирование ПО","url":"002-sd.html#что-такое-crdt","title":"<p>Что такое CRDT?</p>","answer":"<p><strong>Бесконфликтные реплицированные типы данных (англ. Conflict-free replicated data type, CRDT)</strong> - структуры, в которых обеспечивается сильная согласованность в конечном счёте (англ. strong eventual consistency,SEC) и монотонность состояний. Из известных, описанных в работах и реализованных в библиотеках, есть такие структуры:</p>\n<ul>\n<li><strong>G-Counter</strong> - (grow-only) монотонно увеличивающийся счётчик</li>\n<li><strong>PN-Counter</strong> - (positive-negative) счётчик, который можно уменьшать</li>\n<li><strong>LWW-Register</strong> - (last-writer-wins) регистр с принципом последняя запись приоритетнее</li>\n<li><strong>MV-Register</strong> - (multi-value) регистр с несколькими значениями</li>\n<li><strong>G-Set</strong> - множество элементов без удаления</li>\n<li><strong>2P-Set</strong> - с приоритетным удалением</li>\n<li><strong>PN-Set</strong> - использует счётчик операций включения-удаления</li>\n<li><strong>LWW-Set</strong> - с приоритетом времени операции</li>\n<li><strong>OR-Set</strong> - (observed-remove) список с идентификаторами</li>\n</ul>\n<p><a href=\"#проектирование-по\">к оглавлению</a></p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#что-такое-java","title":"<p>Что такое Java?</p>","answer":"<p><strong>Java</strong> (произноситься как \"джава\") — строго типизированный объектно-ориентированный язык программирования и одноимённая платформа, разработанные компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process, язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.</p>\n<p>Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация JVM (виртуальной Java-машины). Дата официального выпуска — 23 мая 1995 года. На текущий момент один из самых популярных языков программирования и де-факто платформа по умолчанию в разработке ПО уровня предприятия.</p>\n<p>Основные области применения: приложения для Android-устройств, веб-сервисы и сайты, промежуточное ПО, микропрограммы для встраиваемых систем.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#почему-стоить-использовать-java","title":"<p>Почему стоить использовать Java?</p>","answer":"<ul>\n<li>Независимость от аппаратной архитектуры.</li>\n<li>Автоматическое управление памятью.</li>\n<li>Расширенные возможности обработки исключительных ситуаций.</li>\n<li>Богатый набор средств фильтрации ввода-вывода.</li>\n<li>Набор стандартных коллекций: массив, список, стек и т. п.</li>\n<li>Наличие простых средств создания сетевых приложений (в том числе с использованием протокола RMI).</li>\n<li>Наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы.</li>\n<li>Встроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки (например\nPython).</li>\n<li>Унифицированный доступ к базам данных:<ul>\n<li>на уровне отдельных SQL-запросов — на основе JDBC, SQLJ;</li>\n<li>на уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе Java Data Objects (\nангл.) и Java Persistence API.</li></ul></li>\n<li>Поддержка обобщений (начиная с версии 1.5).</li>\n<li>Поддержка лямбд, замыканий, встроенные возможности функционального программирования (с 1.8)</li>\n<li>Экосистема содержит громадное количество библиотек, реализующих различные протоколы, подходы и API, как открытые так и\nпроприетарные.</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#какие-основные-отличия-в-версиях-java","title":"<p>Какие основные отличия в версиях Java?</p>","answer":"<h5 id=\"10231996\">Версия 1.0 - 23 января 1996</h5>\n<h5 id=\"11191997\">Версия 1.1 - 19 февраля 1997</h5>\n<ul>\n<li><strong>Inner Classes</strong>.</li>\n<li><strong>Reflection API</strong>.</li>\n<li><strong>JavaBeans</strong>.</li>\n<li><strong>JDBC</strong>.</li>\n<li><strong>Collections framework</strong>.</li>\n</ul>\n<h5 id=\"1281998\">Версия 1.2 - 8 декабря 1998</h5>\n<ul>\n<li><strong><code>strictfp</code> keyword</strong>.</li>\n<li><strong>JDBC</strong>.</li>\n</ul>\n<h5 id=\"1382000\">Версия 1.3 - 8 мая 2000</h5>\n<ul>\n<li><strong>HotSpot VM included</strong>.</li>\n</ul>\n<h5 id=\"1462002\">Версия 1.4 - 6 февраля 2002</h5>\n<ul>\n<li><strong><code>assert</code> keyword</strong>.</li>\n<li><strong>NIO.2 library</strong>  - API для работы с неблокирующим вводом-выводом.</li>\n<li><strong>Logging API</strong>.</li>\n</ul>\n<h5 id=\"5302004\">Версия 5 - 30 сентября 2004 года</h5>\n<ul>\n<li><strong>Enum</strong> - перечислимые типы.</li>\n<li><strong>Annotations</strong> - аннотации, специальные интерфейсы.</li>\n<li><strong>Generics</strong> - средства обобщённого программирования.</li>\n<li><strong>Varargs</strong> - методы с неопределённым числом параметров.</li>\n<li><strong>Autoboxing/Unboxing</strong> — автоматическое преобразование между скалярными типами Java и соответствующими\nтипами-обёртками.</li>\n<li><strong>Static import</strong> - импорт статических полей и методов.</li>\n<li><strong>Foreach</strong> - итератор по коллекции объектов.</li>\n<li><strong>Javadoc comments</strong> - Javadoc-комментариев.</li>\n</ul>\n<h5 id=\"6112006\">Версия 6 - 11 декабря 2006 года</h5>\n<ul>\n<li><strong>Scripting Language Support</strong> - общий API для скриптовых языков и встроенный JS-движок Mozilla Rhino.</li>\n<li><strong>JDBC 4.0</strong>.</li>\n<li><strong>Java Compiler API</strong> - возможность программного вызова java-компилятора.</li>\n<li><strong>JAXB 2.0</strong>.</li>\n<li><strong>PLuggable Annotations</strong>.</li>\n<li><strong>@Override</strong> - использование аннотации для маркирования методов, реализующих интерфейс или расширяющих родительский\nкласс.</li>\n</ul>\n<h5 id=\"772011\">Версия 7 - 7 июля 2011 года</h5>\n<ul>\n<li><strong>InvokeDynamic</strong> - поддержка динамических языков программирования.</li>\n<li><strong>Strings in switch</strong>. - строки в switch-выражениях.</li>\n<li><strong>The try-with-resources statement</strong> - автоматическое управление ресурсами, реализующими интерфейс\njava.lang.AutoCloseable.</li>\n<li><strong>Diamond operator <></strong> - улучшенное вычисление типов при создании обобщенных экземпляров.</li>\n<li><strong>Simplified varargs method declaration</strong> - перенос предупреждения \"unsafe operation\" вместо объявления метода с\nпеременным количеством аргументов.</li>\n<li><strong>Binary integer literals</strong> - префикс <em>0b</em> (int i = 0b0101)</li>\n<li><strong>Underscores in numeric literals</strong> - подчеркивания в числах (int i = 1_000)</li>\n<li><strong>Catching multiple exception types</strong> - перехват нескольких типов исключений в одном блоке catch (catch(SQLException |\nIOException e)).</li>\n<li><strong>DualPivotQuickSort</strong> - в качестве стандартного алгоритма для сортировки примитивов.</li>\n<li><strong>TimSort</strong> - в качестве стандартного алгоритма для сортировки объектов.</li>\n<li><strong>Concurrency utilities</strong> - новый синхронизатор Phaser, включён легковесный механизм fork/join.</li>\n<li><strong>NIO.2 library</strong> - добавлены пакеты java.nio.file, java.nio.file.attribute и java.nio.file.spi.</li>\n</ul>\n<h5 id=\"8182014\">Версия 8 - 18 марта 2014 года</h5>\n<ul>\n<li><strong>Lambda expressions</strong> - выражения в функциональном стиле.</li>\n<li><strong>@FunctionalInterface</strong> - функциональные интерфейсы.</li>\n<li><strong>Stream API</strong>. - возможность выполнения последовательности операций над элементами массива, а также возможность\nпроизводить их параллельно (parallelStream).</li>\n<li><strong>Method Reference</strong> - ссылки на методы и конструкторы, оператор <code>::</code>.</li>\n<li><strong>Repeatable annotations</strong> - возможность использовать аннотации одного типа несколько раз над одним объектом.</li>\n<li><strong>Interface default method</strong> - методы по умолчанию для интерфейсов.</li>\n<li><strong>Annotation on Java types</strong> - аннотации на типы данных.</li>\n<li><strong>Reflection for method parameters</strong> - рефлексия для параметров методов.</li>\n<li><strong>Date & Time API (java.time)</strong> - новое api для работы с датами и временем.</li>\n<li><strong>Remove the PermGen</strong> - удален <em>PermGen</em>, изменен способ хранения мета-данных классов.</li>\n</ul>\n<h5 id=\"9212017\">Версия 9 - 21 сентября 2017 года</h5>\n<ul>\n<li><strong>HTTP/2 support</strong>.</li>\n<li><strong>Jshell</strong> - поддержка REPL-подхода (Read-Eval-Print-Loop) в Java.</li>\n<li><strong>JigSaw project</strong> - поддержка модуляризации в Java.</li>\n<li><strong>Stream API updates</strong>.</li>\n<li><strong>Immutable collevtions</strong> - создании и инициализация коллекций в одну строку.</li>\n<li><strong>Concurrency updates</strong> - реализация Reactive Streams (в т.ч. класс <code>Flow</code>).</li>\n<li><strong>class Optional</strong>  - класс для сбора not-null объектов.</li>\n<li><strong>Complete the removal of underscore from the set of legal identifier names</strong> - запрет подчёркивания в именах классов.</li>\n<li><strong>Support for private methods in interfaces</strong>- private и static private методы в интерфейсах.</li>\n<li><strong>Compact strings</strong> - хранение строк в кодировке LATIN-1, если это возможно.</li>\n</ul>\n<h5 id=\"10202018\">Версия 10 - 20 марта 2018 года</h5>\n<ul>\n<li><strong>Local-variable type inference</strong> - ключевое слово <code>var</code>, что избавляет от необходимости указывать тип локальной\nпеременной явно.</li>\n<li><strong>Stream API updates</strong>.</li>\n<li><strong>Concurrency updates</strong>.</li>\n</ul>\n<h5 id=\"11252018\">Версия 11 - 25 сентября 2018 года</h5>\n<ul>\n<li><strong>Local-Variable Syntax for Lambda Parameters</strong> - ключевое слово <code>var</code> в локальных Лямбда-переменных, например при\nиспользовании аннотаций.</li>\n<li><strong>Launch Single-File Source-Code Programs</strong> - запуск приложения одной командой <code>java HelloWorld.java</code>.</li>\n<li><strong>Remove The Java EE and CORBA Modules</strong> — удалены модули Java EE и COBRA.</li>\n</ul>\n<h5 id=\"12192019\">Версия 12 - 19 марта 2019 года</h5>\n<ul>\n<li><strong>Switch Expressions</strong> - новая форма метки switch “case L -&gt;” чтобы очевидным образом показать, что будет выполняться\nтолько код справа от метки, если эта метка – подходящая.</li>\n</ul>\n<h5 id=\"13172019\">Версия 13 - 17 сентября 2019 года</h5>\n<ul>\n<li><strong>Text Blocks</strong> - Использование <code>\"\"\"</code> для создания текстовых блоков без экранирования спец. символов.</li>\n<li><strong>Reimplement the legacy Socket API</strong> - новая реализацию <code>NioSocketImpl</code>. Она больше не требует нативного кода, тем\nсамым упрощая перенос на разные платформы.</li>\n</ul>\n<h5 id=\"14172020\">Версия 14 - 17 марта 2020 года</h5>\n<ul>\n<li><strong>Records</strong> - записи похожи на перечисления и позволяют упростить код. По сути, они заменяют классы, у которых есть\nсостояние, но нет поведения - есть поля, нет методов.</li>\n<li><strong>Pattern Matching for instanceof</strong>.</li>\n<li><strong>Remove the Concurrent Mark Sweep (CMS) Garbage Collector</strong>.</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#чем-различаются-jre-jvm-и-jdk","title":"<p>Чем различаются JRE, JVM и JDK?</p>","answer":"<p><strong>JVM</strong>, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE).\nВиртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы\nкомпилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.</p>\n<p><strong>JRE</strong>, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.</p>\n<p><strong>JDK</strong>, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.</p>\n<p>Коротко: <strong>JDK</strong> - среда для разработки программ на Java, включающая в себя <strong>JRE</strong> - среду для обеспечения запуска Java программ, которая в свою очередь содержит <strong>JVM</strong> - интерпретатор кода Java программ.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#за-что-отвечает-jvm","title":"<p>За что отвечает <em>JVM</em>?</p>","answer":"<ul>\n<li>Загрузка, проверка и исполнение байт-кода;</li>\n<li>Предоставление среды выполнения для выполнения байт-кода;</li>\n<li>Управление памятью и очисткой мусора (Garbage collection);</li>\n</ul>\n<p>Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями.\nВиртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,\nбез влияния ОС на выполняемую программу.</p>\n<p>JVM работает с 2 типами данных:  примитивные типы (<strong>primitive types</strong>) и ссылочные типы (<strong>reference types</strong>).</p>\n<p><strong>Примитивы</strong></p>\n<p>JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина.\nТипы <code>long</code> и <code>double</code>, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в <code>frame's local</code>\nили стеке операндов, поскольку каждая единица составляет 32 бита.\nТипы <code>boolean</code>, <code>byte</code>, <code>short</code> и <code>char</code> имеют расширенный знак (кроме <code>char</code> с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы <code>int</code>.\nМеньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.\n<code>boolean</code> значение работает как 8-битное <code>byte</code> значения, где 0 представляет значение <strong>false</strong>, а 1 - значение <strong>true</strong>.</p>\n<p><strong>Типы ссылок и значения</strong></p>\n<p>Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.\nИх значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов,\nкоторые реализуют интерфейсы соответственно.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#расскажите-про-classloader","title":"<p>Расскажите про Classloader</p>","answer":"<p>Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM.\nОбычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах\nблагодаря загрузчику классов. <strong>Делегирование является важной концепцией</strong>, которую выполняет загрузчик. Загрузчик классов\nотвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках.\nЭта <strong>загрузка</strong> обычно выполняется <strong>«по требованию»</strong>, поскольку она не происходит до тех пор, пока программа не вызовет класс.\n<strong>Класс с именем может быть загружен только один раз данным загрузчиком классов.</strong></p>\n<p>При запуске JVM, используются три загрузчика классов:</p>\n<ul>\n<li>Bootstrap class loader (Загрузчик класса Bootstrap)</li>\n<li>Extensions class loader (Загрузчик класса расширений)</li>\n<li>System class loader (Системный загрузчик классов)</li>\n</ul>\n<p><strong>Загрузчик класса Bootstrap</strong> загружает основные библиотеки Java, расположенные в папке <code>&lt;JAVA_HOME&gt;/jre/lib</code>.\nЭтот загрузчик является частью ядра JVM, написан на нативном коде.</p>\n<p><strong>Загрузчик класса расширений</strong> загружает код в каталоги расширений\n(<code>&lt;JAVA_HOME&gt;/jre/lib/ext</code>, или любой другой каталог, указанный системным свойством <code>java.ext.dirs</code>).</p>\n<p><strong>Системный загрузчик</strong> загружает код, найденный в <code>java.class.path</code>, который сопоставляется с переменной среды <code>CLASSPATH</code>.\nЭто реализуется классом <code>sun.misc.Launcher$AppClassLoader</code>.</p>\n<p>Загрузчик классов выполняет три основных действия в строгом порядке:</p>\n<ul>\n<li>Загрузка: находит и импортирует двоичные данные для типа.</li>\n<li>Связывание: выполняет проверку, подготовку и (необязательно) разрешение.<ul>\n<li>Проверка: обеспечивает правильность импортируемого типа.</li>\n<li>Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.</li>\n<li>Разрешение: преобразует символические ссылки из типа в прямые ссылки.</li></ul></li>\n<li>Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.</li>\n</ul>\n<p><strong>Пользовательский загрузчик классов</strong></p>\n<p>Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM.\nУ каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового\nзагрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.</p>\n<p>Что делает возможным следующее:</p>\n<ul>\n<li>загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения,\nдаже из ресурса HTTP).\nЭто важная особенность для:<ul>\n<li>реализация скриптовых языков;</li>\n<li>использование bean builders;</li>\n<li>добавить пользовательскую расширение;</li>\n<li>позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;</li></ul></li>\n<li>изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);</li>\n<li>модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании\nаспектно-ориентированного программирования);</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#расскажите-о-run-time-data-area","title":"<p>Расскажите о Run-Time Data Area</p>","answer":"<p>Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных\nсозданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.</p>\n<p><strong>The pc Register (PCR)</strong></p>\n<p>Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (programm counter).\nВ любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока.\nЕсли этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.</p>\n<p>Коротко говоря: для одного потока существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.</p>\n<p><strong>Java Virtual Machine Stacks</strong></p>\n<p>Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames.\nСтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.</p>\n<p><strong>Heap</strong></p>\n<p>JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java.\nКуча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.\nКуча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой\nуправления данными (известной как сборщик мусора); объекты никогда не освобождаются явно.\nJVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных,\nи метод управления может быть выбран в соответствии с системными требованиями разработчика.\nКуча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена,\nесли большая куча становится ненужной. Память для кучи не должна быть смежной.</p>\n<p><strong>Method Area</strong></p>\n<p>JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов,\nа также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса.\nХотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора. Область метода может иметь\nфиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.</p>\n<p><strong>Run-Time Constant Pool</strong></p>\n<p>A run-time constant pool существует для каждого класса или интерфейса в рантайме и представлено constant_pool таблицей в *.class файле.\n Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля,\n которые должны быть разрешены во время выполнения.  Сам run-time constant pool выполняет функцию,\n аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов.\n Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.</p>\n<p><strong>Native Method Stacks</strong></p>\n<p>Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#как-рассчитать-объем-который-занимают-объекты-в-памяти","title":"<p>Как рассчитать объем, который занимают объекты в памяти?</p>","answer":"<p>Заголовок объекта занимает 12 байт:</p>\n<table>\n<thead>\n<tr>\n<th>Название</th>\n<th>Размер, байт</th>\n<th>Описание</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Class pointer</td>\n<td>4</td>\n<td>Ссылка на описание класса</td>\n</tr>\n<tr>\n<td>Mark word</td>\n<td>8</td>\n<td>Набор флагов, описывающих состояние объекта</td>\n</tr>\n</tbody>\n</table>\n<p>Пример приведен для x32 или x64 систем c размером Heap меньше 32 Гбайт и включенной <code>-XX:UseCompressedOops</code>. Иначе размер ссылки буде 8 байт. Также в структуре объекта есть поля. Размер объекта выравнивается по 8 байт.</p>\n<p>Пример:</p>\n<ul>\n<li><code>new Integer()</code> - 12 байт (заголовок) + 4 байта (int) = 16 байт</li>\n<li><code>new Long()</code> - 12 байт (заголовок) + 8 байта (long) + 4 байта (выравнивание) = 24 байта</li>\n<li><code>new int[N]</code> - 12 байт (заголовок) + 4 байта (поле размер) + N <em>4 байта (значения) = 16 + N</em> 4 байт</li>\n<li><code>new byte[N]</code> - 12 байт (заголовок) + 4 байта (поле размер) + N <em>1 байта (значения) = 16 + N</em> 1 байт</li>\n<li><code>new Integer[N]</code> - 12 байт (заголовок) + 4 байта (поле размер) + N <em>4 байта (ссылки на значения) + N</em> 16 байт (\nзначения) = 16 + N * 20 байт</li>\n<li><code>new String()</code> - 12 байт (заголовок) + 4 байта (ссылка на массив byte[]) + 4 байта (hash) + 1 байт (coder) + 3 байта (\nвыравнивание)  = 24 байта</li>\n</ul>\n<p>Размер объектов в можно узнать, воспользовавшись утилитой <code>Java Object Layout</code>.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#расскажите-о-frames","title":"<p>Расскажите о Frames</p>","answer":"<p>Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.\nНовый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода,\nявляется ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame.\nКаждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.\nРазмеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.\nТаким образом, размер структуры данных frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.</p>\n<p>Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.\nКласс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.</p>\n<p>Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим,\nкогда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame.\nТекущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком,\nявляется локальным для этого потока и на него не может ссылаться ни один другой поток.</p>\n<p><strong>Локальные переменные</strong></p>\n<p>Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции\nи предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом.\nЕдиничная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress.\nПара локальных переменных может хранить значение типов: long или double.</p>\n<p>Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.</p>\n<p>Значение типа long или типа double занимает две последовательные локальные переменные.</p>\n<p>JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных,\nначиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект,\nдля которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.</p>\n<p><strong>Стеки операндов (Operand Stacks)</strong></p>\n<p>Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a\nопределяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.</p>\n<p>Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант\nили значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов,\nоперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров\nдля передачи в методы и для получения результатов метода.</p>\n<p>Для примера, инструкция <strong>iadd</strong>  суммирует два int значения. От стека операндов требуется, чтобы два int значения были наверху стека.\nЗначения удаляются из стека, операция <strong>pop</strong>. Суммируются и их сумма помещается в стек операндов.</p>\n<p><strong>Динамическое связывание (Dynamic Linking)</strong></p>\n<p>Каждый frame содержит ссылку на  run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода.\nДоступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла.\nДинамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости\nдля разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения,\nсвязанных с расположением этих переменных во время выполнения.</p>\n<p>Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.</p>\n<p><strong>Нормальное завершение вызова метода</strong></p>\n<p>Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw.\nЕсли вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу.\nЭто происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).</p>\n<p>Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов,\nс соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода.\nЗатем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.</p>\n<p><strong>Резкое завершение вызова метода</strong></p>\n<p>Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе.\nВыполнение команды <strong>athrow</strong> также приводит к явному выбрасыванию исключения, и если исключение не перехватывается текущим методом,\nприводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#что-такое-execution-engine","title":"<p>Что такое Execution Engine?</p>","answer":"<p>Байт-код, назначенный <strong>run-time data areas</strong>, будет выполнен <strong>execution engine</strong>. Механизм выполнения считывает байт-код и выполняет его по частям.</p>\n<p><strong>Interpreter</strong></p>\n<p>Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.</p>\n<p><strong>JIT Compiler</strong></p>\n<p>JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода,\nно когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код.\nЭтот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.</p>\n<ul>\n<li>Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.</li>\n<li>Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.</li>\n<li>Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.</li>\n<li>Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.</li>\n</ul>\n<p><strong>Garbage Collector</strong>\nGarbage Collector (\"сборщик мусора\") функционирует в фоновом режиме во время работы твоей программы, собирает ставшие ненужными объекты, которые в дальнейшем будут удалены. Таким образом, он освобождает память для создания новых объектов в будущем. На самом деле сборщик мусора не один, а несколько.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#для-чего-нужен-сборщик-мусора","title":"<p>Для чего нужен сборщик мусора?</p>","answer":"<p>Сборщик мусора (Garbage Collector) должен делать всего две вещи:</p>\n<ul>\n<li>Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);</li>\n<li>Освобождать память от мусора.</li>\n</ul>\n<p>Существует два подхода к обнаружению мусора:</p>\n<ul>\n<li><em>Reference counting</em>;</li>\n<li><em>Tracing</em></li>\n</ul>\n<p><strong>Reference counting</strong> (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.</p>\n<p>Главная идея подхода <strong>Tracing</strong> (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (<em>GC Root</em>) или других с живых объектов. Всё остальное - мусор.</p>\n<p>Существует 4 типа корневых точки:</p>\n<ul>\n<li>Локальные переменные и параметры методов;</li>\n<li>Потоки;</li>\n<li>Статические переменные;</li>\n<li>Ссылки из JNI.</li>\n</ul>\n<p>Самое простое java приложение будет иметь корневые точки:</p>\n<ul>\n<li>Локальные переменные внутри <code>main()</code> метода и параметры <code>main()</code> метода;</li>\n<li>Поток, который выполняет <code>main()</code>;</li>\n<li>Статические переменные класса, внутри которого находится <code>main()</code> метод.</li>\n</ul>\n<p>Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.</p>\n<hr />\n<p>Для очистки памяти от мусора существуют два основных метода:</p>\n<ul>\n<li><em>Copying collectors</em></li>\n<li><em>Mark-and-sweep</em></li>\n</ul>\n<p>При <strong>copying collectors</strong> подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:</p>\n<ul>\n<li>Объекты создаются в «from-space»;</li>\n<li>Когда «from-space» заполняется, приложение приостанавливается;</li>\n<li>Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;</li>\n<li>Когда все объекты скопированы «from-space» полностью очищается;</li>\n<li>«to-space» и «from-space» меняются местами.</li>\n</ul>\n<p>Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:</p>\n<ol>\n<li>Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;</li>\n<li>В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.</li>\n</ol>\n<p>Алгоритм работы <strong>mark-and-sweep</strong> можно описать так:</p>\n<ul>\n<li>Объекты создаются в памяти;</li>\n<li>В момент, когда нужно запустить сборщик мусора приложение приостанавливается;</li>\n<li>Сборщик проходится по дереву объектов, помечая живые объекты;</li>\n<li>Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;</li>\n<li>Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».</li>\n</ul>\n<p>Минусы этого способа:</p>\n<ol>\n<li>Приложение не работает, пока происходит сборка мусора;</li>\n<li>Время остановки напрямую зависит от размеров памяти и количества объектов;</li>\n<li>Если не использовать «compacting», то память будет использоваться не эффективно.</li>\n</ol>\n<p>Сборщики мусора HotSpot VM используют комбинированный подход <strong>Generational Garbage Collection</strong>, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:</p>\n<ul>\n<li>большинство создаваемых объектов быстро становятся мусором;</li>\n<li>существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#как-работает-сборщик-мусора","title":"<p>Как работает сборщик мусора?</p>","answer":"<p>Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.</p>\n<p>Объекты создаются посредством оператора <code>new</code>, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например присвоив переменной ссылку на другой объект или значение <code>null</code>; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, на которые отсутствуют ссылки, принято называть мусором (<em>garbage</em>).</p>\n<p>Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (<em>GC Root</em>) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.</p>\n<p>Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.</p>\n<p>Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot","title":"<p>Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?</p>","answer":"<p>Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:</p>\n<ul>\n<li><strong>Serial (последовательный)</strong> — самый простой вариант для приложений с небольшим объемом данных и не требовательных к\nзадержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной\nмашиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией <code>-XX:+UseSerialGC</code>.</li>\n<li><strong>Parallel (параллельный)</strong> — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в\nнекоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.\nПараллельный сборщик включается опцией <code>-XX:+UseParallelGC</code>.</li>\n<li><strong>Concurrent Mark Sweep (CMS)</strong> — нацелен на снижение максимальных задержек путем выполнения части работ по сборке\nмусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в\nпамяти. Использование CMS GC включается опцией <code>-XX:+UseConcMarkSweepGC</code>.</li>\n<li><strong>Garbage-First (G1)</strong> — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных\nсерверах и оперирующих большими объемами данных. <em>G1</em> включается опцией Java <code>-XX:+UseG1GC</code>.</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot","title":"<p>Опишите алгоритм работы какого-нибудь сборщика мусора реализованного в виртуальной машине HotSpot</p>","answer":"<p><strong>Serial Garbage Collector (Последовательный сборщик мусора)</strong> был одним из первых сборщиков мусора в HotSpot VM. Во\nвремя работы этого сборщика приложения приостанавливается и продолжает работать только после прекращение сборки мусора.</p>\n<p>Память приложения делится на три пространства:</p>\n<ul>\n<li><em>Young generation</em>. Объекты создаются именно в этом участке памяти.</li>\n<li><em>Old generation</em>. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».</li>\n<li><em>Permanent generation</em>. Тут хранятся метаданные об объектах, <em>Class data sharing (CDS)</em>, <em>пул строк (String pool)</em>.\nPermanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только\nдля чтения не чистится сборщиком мусора никогда. В Java 8 и выше отсутствует, пул строке переехал в основную память,\nметаданные в нативную память JVM.</li>\n</ul>\n<p>Область памяти Young generation состоит из трёх областей: <em>Eden</em> и двух меньших по размеру <em>Survivor spaces</em> - <em>To\nspace</em> и <em>From space</em>. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не\nмогут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые\nпережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (<em>tenuring threshold</em>), чтобы быть\nперемещенными в Old generation.</p>\n<p>Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (<em>minor collection</em>), в отличие от процесса сборки, проводимого над всей кучей (<em>full collection</em>). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.</p>\n<p>Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.</p>\n<p>Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется <em>copying</em> (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).</p>\n<p>Однако для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.</p>\n<p>В Old generation сборка мусора происходит с использованием алгоритма <em>mark-sweep-compact</em>, который состоит из трёх фаз. В фазе <em>Mark</em> (пометка) сборщик мусора помечает все живые объекты, затем, в фазе <em>Sweep</em> (очистка) все не помеченные объекты удаляются, а в фазе <em>Compact</em> (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.</p>\n<p>Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм <em>bump-the-pointer</em>: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.</p>\n<p>Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#что-такое-safepoints-применительно-к-hotspot-jvm","title":"<p>Что такое Safepoints (применительно к HotSpot JVM)?</p>","answer":"<p>В HotSpot JVM механизм паузы «stop-the-world» называется <strong>safepoint</strong>. Во время safepoint все потоки, исполняющие java-код приостанавливаются. Потоки, исполняющие нативный код, могут продолжать работать пока, не будут прерваны JVM (попытка доступа к объектам Java через JNI, вызов метода Java или возврат из нативного кода в Java приостановит поток до конца safepoint). Остановка всех потоков необходима, чтобы убедиться, что safepoint-инициатор имеет эксклюзивный доступ к структурам данных JVM и может делать всё что угодно, например перемещение объектов в куче или замена кода метода, который в настоящее время выполняется (перемещение в стеке).</p>\n<p><strong>Как работают safepoints?</strong>\nПротокол Safepoint в HotSpot JVM является общим. Каждый поток приложения проверяет статус safepoint и паркуется в безопасном состоянии в этой точке. Для скомпилированного кода JIT вставляет в код проверки safepoint в определенных точках (обычно после возврата вызовов или при обратном переходе цикла). Для интерпретируемого кода JVM имеет две таблицы диспетчеризации байт-кода, и если требуется safepoint, JVM переключает таблицы, чтобы включить его проверку.</p>\n<p>Сама проверка статуса Safepoint реализована очень нетривиально. Обычная проверка переменных памяти потребует дорогостоящих барьеров памяти. Хотя проверка safepoints реализована через барьер. Затем требуется безопасная точка, JVM отключает отображение страницы с этим адресом, вызывая сбой страницы в потоке приложения (который обрабатывается обработчиком JVM). Таким образом, HotSpot поддерживает свой JITed-код, совместимый с конвейером процессора, но при этом обеспечивает правильную семантику памяти (unmap страницы создает барьер памяти для ядер обработки).</p>\n<p><strong>Когда safepoint используется?</strong></p>\n<ul>\n<li>Пауза GC</li>\n<li>Деоптимизация кода</li>\n<li>Flushing code cache</li>\n<li>Class redefinition (e.g. hot swap or instrumentation)</li>\n<li>Biased lock revocation</li>\n<li>Various debug operation (e.g. deadlock check or stacktrace dump)</li>\n</ul>\n<p>Источник: <a href=\"http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html\">http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html</a></p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#что-такое-heapdump-и-treaddump","title":"<p>Что такое HeapDump и TreadDump?</p>","answer":"<p><strong>HeapDump</strong> - снимок текущей памяти, позволяет разобраться в потребление памяти, например, при её утечке.</p>\n<p><strong>ThreadDump</strong> - снимок стеков всех поток, позволяет разбираться в проблемах многопоточности, например, находить взаимные блокировки.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#что-такое-профилирование","title":"<p>Что такое профилирование?</p>","answer":"<p><strong>Профилирование</strong> — сбор характеристик работы программы, таких как время выполнения отдельных фрагментов (обычно подпрограмм), число верно предсказанных условных переходов, число кэш-промахов и т. д. Инструмент, используемый для анализа работы, называют профилировщиком или профайлером (англ. profiler). Обычно выполняется совместно с оптимизацией программы.</p>\n<p><strong>Профилировщики</strong> - программы, производящие профилирование, делятся на 2 типа:</p>\n<ul>\n<li><em>Инструментирующие</em> - модифицируют программный код, оказывают значительное влияние н производительность.</li>\n<li><em>Сэмплирующие</em> - не влияют напрямую на исполняемый код.</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#как-обнаружить-причину-утечки-памяти-memory-leak","title":"<p>Как обнаружить причину утечки памяти (memory leak)?</p>","answer":"<p>Как правило, следствием утечки памяти становится замедление приложения и/или появление <code>OutOfMemoryError: xxx</code>.</p>\n<p>Что может быть причиной:</p>\n<ul>\n<li><strong>Неверно сконфигурированная JVM</strong> - удалите все ключи jvm, и попробуйте воспроизвести проблему.</li>\n<li><strong>Объективная нехватка памяти</strong> - добавьте ее в Heap (<code>-Xmx</code> / <code>-Xms</code>) и PermGen (<code>-XX:PermSize</code> / <code>-XX:MaxPermSize</code>) для версий Java 7 и ниже.</li>\n<li><strong>Утечка в загрузчике классов (class loader)</strong> - ограничьте Metaspace <code>-XX:MaxMetaSpaceSize={unlimited}</code> для версий Java 8 и выше, чтобы ограничить потребление физической памяти и локализовать проблему.</li>\n<li><strong>Ошибки проектирования</strong> - незакрытые потоки ввод-вывода, зависшие потоки (threads), …</li>\n</ul>\n<p>Рекомендации по диагностированию:</p>\n<ul>\n<li><strong>Утилиты VisaulVM, MissonControl, jstat, jmap</strong> - для анализа состояния JVM в моменте.</li>\n<li><strong>Включение GC-логов</strong> - <code>-XX:PrintGCDetails</code> и других. Их можно анализировать с помощью GCLogAnalyzer или GCViewer.</li>\n<li><strong>Включение создания дампа памяти при ошибке <code>OutOfMememoryError: xxx</code></strong> <code>- XX:HeadDumpOnOutOfMemoryError</code> и <code>-XX:HeapDumpPath=&lt;file_name&gt;</code>. Анализ дампа можно производить с помощью Memory Analyzer (MAT).</li>\n</ul>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#какие-существуют-рекомендации-к-стилю-кода-на-java","title":"<p>Какие существуют рекомендации к стилю кода на Java?</p>","answer":"<p>Рекомендации к стилю кода отражены в документе <strong>Java Code Conventions</strong>.</p>"},{"subject":"Java Virtual Machine","url":"003-jvm.html#какие-языки-кроме-java-могут-быть-использованы-в-разработке-по-исполняемого-в-среде-jvm","title":"<p>Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?</p>","answer":"<p><em>Компилируемые в байт-код Java</em>:\n<em>Scala</em> — объектно-ориентированный и функциональный язык;\n<em>Kotlin</em> — объектно-ориентированный язык, используется, в том числе для разработки Android-приложений;\n<em>Clojure</em> — функциональный язык, диалект Lisp;\n<em>Ceylon</em> — объектно-ориентированный язык со строгой статической типизацией.</p>\n<p><strong>Интерпретируемые</strong>:\n<em>Jacl</em> - реализация TCL;\n<em>Jython</em> — реализация Python;\n<em>JRuby</em> — реализация Ruby;\n<em>Groovy</em> — сценарный язык;\n<em>Nashorn</em> — реализация JavaScript.</p>\n<p><a href=\"#java-virtual-machine\">к оглавлению</a></p>"},{"subject":"Java Core","url":"004-core.html#какие-примитивы-есть-в-java","title":"<p>Какие примитивы есть в Java?</p>","answer":"<p><strong>«Пустой» тип</strong> - <code>void</code>.\n <strong>Логический (булевый) тип</strong>.</p>\n<table>\n<thead>\n<tr>\n<th><em>Тип</em></th>\n<th><em>Размерность</em></th>\n<th><em>Нач. значение</em></th>\n<th><em>Мин. значение</em></th>\n<th><em>Макс. значение</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>bolean</code></td>\n<td>1 бит</td>\n<td>false</td>\n<td>false</td>\n<td>ture</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Целы числа</strong></p>\n<table>\n<thead>\n<tr>\n<th><em>Тип</em></th>\n<th><em>Размерность</em></th>\n<th><em>Нач. значение</em></th>\n<th><em>Мин. значение</em></th>\n<th><em>Макс. значение</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>byte</code></td>\n<td>8 бит</td>\n<td>0</td>\n<td>-2<sup>7</sup></td>\n<td>2<sup>7</sup>-1</td>\n</tr>\n<tr>\n<td><code>short</code></td>\n<td>16 бит</td>\n<td>0</td>\n<td>-2<sup>15</sup></td>\n<td>2<sup>15</sup>-1</td>\n</tr>\n<tr>\n<td><code>int</code></td>\n<td>32 бита</td>\n<td>0</td>\n<td>-2<sup>31</sup></td>\n<td>2<sup>31</sup>-1</td>\n</tr>\n<tr>\n<td><code>long</code></td>\n<td>64 бита</td>\n<td>0l</td>\n<td>-2<sup>63</sup></td>\n<td>2<sup>63</sup>-1</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Числа с плавающей запятой</strong>. Например <code>float f = -45.05f;</code></p>\n<table>\n<thead>\n<tr>\n<th><em>Тип</em></th>\n<th><em>Размерность</em></th>\n<th><em>Нач. значение</em></th>\n<th><em>Стандарт</em></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>float</code></td>\n<td>32 бита</td>\n<td>0.0f</td>\n<td>32 бита IEEE 754</td>\n</tr>\n<tr>\n<td><code>double</code></td>\n<td>64 бита</td>\n<td>0.0d</td>\n<td>64 бита IEEE 754</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Символы</strong> - для хранения литералов. Например <code>char c = 'A';</code></p>\n<p>c</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-autoboxing-автоупаковка-в-java-и-каковы-правила-упаковки-примитивных-типов-в-классы-обертки","title":"<p>Что такое <em>autoboxing («автоупаковка»)</em> в Java и каковы правила упаковки примитивных типов в классы-обертки?</p>","answer":"<p><strong>Автоупаковка</strong> - это механизм неявной инициализации объектов классов-оберток (<code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>) значениями соответствующих им исходных примитивных типов (<code>byte</code>, <code>short</code>, <code>int</code>…), без явного использования конструктора класса.</p>\n<ul>\n<li><p>Автоупаковка происходит при прямом присваивании примитива классу-обертке (с помощью оператора <code>=</code>), либо при передаче примитива в параметры метода (типа класса-обертки).</p></li>\n<li><p>Автоупаковке в классы-обертки могут быть подвергнуты как переменные примитивных типов, так и константы времени компиляции (литералы и <code>final</code>-примитивы). При этом литералы должны быть синтаксически корректными для инициализации переменной исходного примитивного типа.</p></li>\n<li><p>Автоупаковка переменных примитивных типов требует точного соответствия типа исходного примитива типу класса-обертки. Например, попытка упаковать переменную типа <code>byte</code> в <code>Short</code>, без предварительного явного приведения <code>byte</code> в <code>short</code> вызовет ошибку компиляции.</p></li>\n<li><p>Автоупаковка констант примитивных типов допускает более широкие границы соответствия. В этом случае компилятор способен предварительно осуществлять неявное расширение/сужение типа примитивов:\n1) неявное расширение/сужение исходного типа примитива до типа примитива соответствующего классу-обертке (для преобразования <code>int</code> в <code>Byte</code>, сначала компилятор самостоятельно неявно сужает <code>int</code> к <code>byte</code>)\n2) автоупаковку примитива в соответствующий класс-обертку. Однако в этом случае существуют два дополнительных ограничения:\n    a) присвоение примитива обертке может производится только оператором <code>=</code> (нельзя передать такой примитив в параметры метода без явного приведения типов)\n    b) тип левого операнда не должен быть старше чем <code>Character</code>, тип правого не должен старше, чем <code>int</code>: допустимо расширение/сужение <code>byte</code> в/из <code>short</code>, <code>byte</code> в/из <code>char</code>, <code>short</code> в/из <code>char</code> и только сужение <code>byte</code> из <code>int</code>, <code>short</code> из <code>int</code>, <code>char</code> из <code>int</code>. Все остальные варианты требуют явного приведения типов).</p></li>\n</ul>\n<p>Дополнительной особенностью целочисленных классов-оберток созданных автоупаковкой констант в диапазоне <code>-128 ... +127</code> является то, что они кэшируются JVM. Поэтому такие обертки с одинаковыми значениями будут являться ссылками на один объект.</p>"},{"subject":"Java Core","url":"004-core.html#в-каком-порядке-выбирается-кандидат-из-списка-перегруженных-методов-при-вызове-с-примитивным-аргументом","title":"<p>В каком порядке выбирается кандидат из списка перегруженных методов при вызове с примитивным аргументом?</p>","answer":"<p>Например, если мы хотим вызываем метод <code>myMethod(10)</code>, где 10 - переменная типа int. То перегруженные методы будут выбраны для вызова в следующем порядке:</p>\n<ul>\n<li><code>myMethod(int i)</code> - метод с точным соответствием типа аргумента (<em>exact</em>).</li>\n<li><code>myMethod(float i)</code> - метод с аргументом примитивного типа, шире данного (<em>widening</em>). Последовательность следующая <code>byte</code> &lt; <code>short</code> &lt; <code>int</code> &lt; <code>long</code> &lt; <code>float</code> &lt; <code>double</code>. Для типа <code>char</code>: <code>char</code> &lt; <code>int</code> &lt; <code>long</code> &lt; <code>float</code> &lt; <code>double</code>.</li>\n<li><code>myMethod(Integer i)</code> - метод с аргументом типа класса-обертки (<em>autoboxing</em>).</li>\n<li><code>myMethod(int i...)</code> - метод с точным соответсвием типа и переменным количеством аргументов (<em>varargs</em>).</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-массив-в-java","title":"<p>Что такое массив в Java?</p>","answer":"<p><strong>Массив</strong> — это структура данных, в которой хранятся элементы одного типа. Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить какие-то данные (один элемент данных в одну ячейку). Доступ к конкретной ячейке осуществляется через её номер. Номер элемента в массиве также называют <em>индексом</em>.</p>\n<p>Длина массива может быть получена через свойство <code>length</code>. Нумерация индексов начинается с 0, последний элемент массива имеет индекс <code>length - 1</code>.</p>\n<p>Массив является наследником класса <code>java.lang.Object</code>. Java поддерживает N-мерные массивы, также имеет класс Arrays, который содержит вспомогательные оперции для работы с массивами.</p>\n<p>Примеры создания массивов:</p>\n<pre><code class=\"java language-java\">int[] myArray;  //Java стиль, предпочтителен\nint myArray[];  //C++ стиль, тоже раюотает\nString[] array = (String[]) Array.newInstance(String.class, 3);\n\nint[] myArray = new int[5]; //массив из 5 нулевых элементов\nint[] myArray = {1, 2, 3}; //массив из 3 ненулевых элементов\n\nmyArray[2] //доступ к элементам массива по индексу\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#какие-алгоритмы-сортировки-массивов-используются-в-java","title":"<p>Какие алгоритмы сортировки массивов используются в Java?</p>","answer":"<table>\n<thead>\n<tr>\n<th><strong>Версия</strong></th>\n<th><strong>Array.sort(primitives)</strong></th>\n<th><strong>Array.sort(objects)</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Java …-6</td>\n<td>Quicksort</td>\n<td>MergerSort</td>\n</tr>\n<tr>\n<td>Java 7-…</td>\n<td>DualPivotQuicksort</td>\n<td>TimSort</td>\n</tr>\n</tbody>\n</table>"},{"subject":"Java Core","url":"004-core.html#что-будет-результатом-выполнения-операции-int-array-8-3-10-4-int-result-arraysbinarysearcharray-8","title":"<p>Что будет результатом выполнения операции <code>int[] array = {8, -3, 10, 4}; int result = Arrays.binarySearch(array, 8);</code>?</p>","answer":"<p>Неопределенность, так как массив не отсортирован. Если добавить вызова <code>Arrays.sort(array)</code>, то результат будет равен 2, потому что в отсортироанном массиве <code>{-3, 4, 8, 10}</code> число 8 имеет такой индекс.</p>"},{"subject":"Java Core","url":"004-core.html#что-будет-результатом-выполнения-операции-int-result-arraysbinarysearch-3-4-8-10-9","title":"<p>Что будет результатом выполнения операции <code>int result = Arrays.binarySearch([-3, 4, 8, 10], 9)</code>?</p>","answer":"<p>Результат будет равен -4. Отрицательным он будет, т. к. такго эелемента в массиве нет, а его модуль равен индекску + 1 того места, где он мог бы находиться.</p>"},{"subject":"Java Core","url":"004-core.html#какие-существуют-модификаторы","title":"<p>Какие существуют модификаторы?</p>","answer":"<ul>\n<li><strong>abstact</strong> - указывает на абстрактный метод илил класс.</li>\n<li><strong>default</strong> - начиная с Java 8 используется для объявления поведения по умполчанию в интерфейсах.</li>\n<li><strong>final</strong> - указыает невозможность переопределения.</li>\n<li><strong>native</strong> - указыает на нативную реализацию.</li>\n<li><strong>static</strong> - указыает на статические методы.</li>\n<li><strong>strictfp</strong> - это модификатор, введенный в java 1.2, ограничивающий точность вычислений с float и double по стандарту IEEE. Для чего это нужно? Чтобы обеспечить переносимость. Дело в том, что JVM использует всю возможную точность процессора, а она на разных системах разная, поэтому и результат может получиться разный. Данный модификатор используется в программах требующих точность вычислений превышающих IEEE (обычно, что-нибудь связное с наукой).</li>\n<li><strong>synchronized</strong> - это зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.</li>\n<li><strong>transient</strong> - поля, помеченные таким модификаторовм, пропускаюся при сериализации/десериализации.</li>\n<li><strong>volatile</strong> - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности. Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте, синхронизированы не будут!</li>\n</ul>\n<p><strong>Модификаторы доступа</strong></p>\n<ul>\n<li><strong>private</strong> (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово <code>private</code>.</li>\n<li><strong>(empty)</strong>, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - специальное\nобозначение не требуется.</li>\n<li><strong>protected</strong> (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово <code>protected</code>.</li>\n<li><strong>public</strong> (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово <code>public</code>.</li>\n</ul>\n<p>Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.</p>\n<p>Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия <em>принципу подстановки Барбары Лисков</em>).</p>"},{"subject":"Java Core","url":"004-core.html#в-чём-разница-между-intrinsic-и-native-методами","title":"<p>В чём разница между <code>intrinsic</code> и <code>native</code> методами?</p>","answer":"<p>Методы, помеченные модификатором <strong>native</strong>, реализованны на нативном языке платофрмы (например, C++). Например, <code>Object.hashCode</code>.</p>\n<p><strong>Intrinsic-методы</strong>, у которых нет модификатора <code>native</code>, но которые во время исполнения заменяются нативной реализацией. Например, <code>String.equals</code>. Т.е. скорость работы этого метода будет отличаться в ситуациях, когда вы вызываете его через API или скопируете реализацию в собственный метод.</p>\n<p>Начиная с 9-ой версии в HotSpot JVM существует аннотация <code>@HotSpotIntrinsicCandidate</code> для метода(или конструктора), которая указыает, что аннотируемый метод может (но гарантий в этом нет) стать intrinsic-методом в будущем.</p>"},{"subject":"Java Core","url":"004-core.html#что-значит-ключевое-слово-var","title":"<p>Что значит ключевое слово var?</p>","answer":"<p>Ключево слово <code>var</code>, введённо в Java 10,  избавляет от указания типа локальной переменной (local-variable type inference). Пример. Выражение <code>int i = 0</code> эквивалентно <code>var i = 0;</code>. При объяевления коллекций читаемость кода повышается <code>var list = new ArrayList&lt;Objet&gt;();</code> Но, с другой стороны, при объявлении generics нельзя будет использовать сокращённый вариант без указания типа - <code>&lt;...&gt;</code>. В случаях, когда тип переменной не очевиден компилятору, будет выдана  ошибка <code>error: cannot infer type for local variable ...</code>.</p>"},{"subject":"Java Core","url":"004-core.html#о-чем-говорит-ключевое-слово-final","title":"<p>О чем говорит ключевое слово <code>final</code>?</p>","answer":"<p>Модификатор <code>final</code> может применяться к переменным, параметрам методов, полям и методам класса или самим классам.</p>\n<ul>\n<li>Класс не может иметь наследников;</li>\n<li>Метод не может быть переопределен в классах наследниках;</li>\n<li>Поле не может изменить свое значение после инициализации;</li>\n<li>Параметры методов не могут изменять своё значение внутри метода;</li>\n<li>Локальные переменные не могут быть изменены после присвоения им значения.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#какими-значениями-инициализируются-переменные-по-умолчанию","title":"<p>Какими значениями инициализируются переменные по умолчанию?</p>","answer":"<ul>\n<li>Числа инициализируются <code>0</code> или <code>0.0</code>;</li>\n<li><code>char</code> — <code>\\u0000</code>;</li>\n<li><code>boolean</code> — <code>false</code>;</li>\n<li>Объекты (в том числе <code>String</code>) — <code>null</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-вы-знаете-о-функции-main","title":"<p>Что вы знаете о функции <code>main()</code>?</p>","answer":"<p>Метод <code>main()</code> — точка входа в программу. В приложении может быть несколько таких методов. Если метод отсутствует, то компиляция возможна, но при запуске будет получена ошибка <em>`Error: Main method not found`</em>.</p>\n<pre><code class=\"java language-java\">public static void main(String[] args) {}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#какие-логические-операции-и-операторы-вы-знаете","title":"<p>Какие логические операции и операторы вы знаете?</p>","answer":"<ul>\n<li><code>&amp;</code>: Логическое <em>AND</em> (И);</li>\n<li><code>&amp;&amp;</code>: Сокращённое <em>AND</em>;</li>\n<li><code>|</code>: Логическое <em>OR</em> (ИЛИ);</li>\n<li><code>||</code>: Сокращённое <em>OR</em>;</li>\n<li><code>^</code>: Логическое <em>XOR</em> (исключающее <em>OR</em> (ИЛИ));</li>\n<li><code>!</code>: Логическое унарное <em>NOT</em> (НЕ);</li>\n<li><code>&amp;=</code>: <em>AND</em> с присваиванием;</li>\n<li><code>|=</code>: <em>OR</em> с присваиванием;</li>\n<li><code>^=</code>: <em>XOR</em> с присваиванием;</li>\n<li><code>==</code>: Равно;</li>\n<li><code>!=</code>: Не равно;</li>\n<li><code>?:</code>: Тернарный (троичный) условный оператор.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-тернарный-оператор-выбора","title":"<p>Что такое тернарный оператор выбора?</p>","answer":"<p>Тернарный условный оператор <code>?:</code> - оператор, которым можно заменить некоторые конструкции операторов <code>if-then-else</code>.</p>\n<p>Выражение записывается в следующей форме:</p>\n<blockquote>\n  <p>условие ? выражение 1 : выражение 2</p>\n</blockquote>\n<p>Если <code>условие</code> выполняется, то вычисляется <code>выражение 1</code> и его результат становится результатом выполнения всего оператора. Если же <code>условие</code> равно <code>false</code>, то вычисляется <code>выражение2</code> и его значение становится результатом работы оператора. Оба операнда <code>выражение1</code> и <code>выражение2</code> должны возвращать значение одинакового (или совместимого) типа.</p>"},{"subject":"Java Core","url":"004-core.html#какие-побитовые-операции-вы-знаете","title":"<p>Какие побитовые операции вы знаете?</p>","answer":"<ul>\n<li><code>~</code>: Побитовый унарный оператор NOT;</li>\n<li><code>&amp;</code>: Побитовый AND;</li>\n<li><code>&amp;=</code>: Побитовый AND с присваиванием;</li>\n<li><code>|</code>: Побитовый OR;</li>\n<li><code>|=</code>: Побитовый OR с присваиванием;</li>\n<li><code>^</code>: Побитовый исключающее XOR;</li>\n<li><code>^=</code>: Побитовый исключающее XOR с присваиванием;</li>\n<li><code>&gt;&gt;</code>: Сдвиг вправо (деление на 2 в степени сдвига);</li>\n<li><code>&gt;&gt;=</code>: Сдвиг вправо с присваиванием;</li>\n<li><code>&gt;&gt;&gt;</code>: Сдвиг вправо без учёта знака;</li>\n<li><code>&gt;&gt;&gt;=</code>: Сдвиг вправо без учёта знака с присваиванием;</li>\n<li><code>&lt;&lt;</code>: Сдвиг влево (умножение на 2 в степени сдвига);</li>\n<li><code>&lt;&lt;=</code>: Сдвиг влево с присваиванием.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#как-передается-параметры-в-метод-по-значению-или-по-ссылке","title":"<p>Как передается параметры в метод по значению или по ссылке?</p>","answer":"<p>В Java параметр метода – всегда копия объекта. Значит параметры передаются всегда по значению, просто это значение может быть ссылкой на объект. Код ниже это демонстрирует.</p>\n<pre><code class=\"java language-java\">public static void main(String[] args) {\n    var o = new Object();\n    var i = 10;\n    method(o, i);\n    System.out.println(i + \" \" + o); // 10 and java.lang.Object@....\n}\n\npublic static void method(Object o, int i) {\n    o = null;\n    i = 1000;\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#где-и-для-чего-используется-модификатор-abstract","title":"<p>Где и для чего используется модификатор <code>abstract</code>?</p>","answer":"<p>Класс помеченный модификатором <code>abstract</code> называется абстрактным классом. Такие классы могут выступать только предками для других классов. Создавать экземпляры самого абстрактного класса не разрешается. При этом наследниками абстрактного класса могут быть как другие абстрактные классы, так и классы, допускающие создание объектов.</p>\n<p>Метод помеченный ключевым словом <code>abstract</code> - абстрактный метод, т.е. метод, который не имеет реализации. Если в классе присутствует хотя бы один абстрактный метод, то весь класс должен быть объявлен абстрактным.</p>\n<p>Использование абстрактных классов и методов позволяет описать некий шаблон объекта, который должен быть реализован в других классах. В них же самих описывается лишь некое общее для всех потомков поведение.</p>"},{"subject":"Java Core","url":"004-core.html#дайте-определение-понятию-интерфейс-какие-модификаторы-по-умолчанию-имеют-поля-и-методы-интерфейсов","title":"<p>Дайте определение понятию <em>«интерфейс»</em>. Какие модификаторы по умолчанию имеют поля и методы интерфейсов?</p>","answer":"<p>Ключевое слово <code>interface</code> используется для создания полностью абстрактных классов. Основное предназначение интерфейса - определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как <code>public</code>.</p>\n<p>Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию <code>default</code> и статических <code>static</code> методов.</p>\n<p>Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными <code>public</code>, статическими <code>static</code> и неизменяемыми <code>final</code>.</p>"},{"subject":"Java Core","url":"004-core.html#чем-абстрактный-класс-отличается-от-интерфейса-в-каких-случаях-следует-использовать-абстрактный-класс-а-в-каких-интерфейс","title":"<p>Чем абстрактный класс отличается от интерфейса? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?</p>","answer":"<ul>\n<li>В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только от одного класса.</li>\n<li>Абстрактные классы используются только тогда, когда присутствует тип отношений «is a» (является). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.</li>\n<li>Абстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инструмент для частичной реализации поведения. Интерфейс - это средство выражения семантики класса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как <code>public abstract</code> или (начиная с Java 8) <code>default</code> - методами с реализацией по умолчанию, а поля - <code>public static final</code>.</li>\n<li>Интерфейсы позволяют создавать структуры типов без иерархии.</li>\n<li>Наследуясь от абстрактного, класс «растворяет» собственную индивидуальность. Реализуя интерфейс, он расширяет собственную функциональность.</li>\n</ul>\n<p>Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от абстрактного класса и отличаются лишь в части собственной реализации абстрактных методов родителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень похожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего поведение объекта по умолчанию может быть полезно, так как позволяет избежать написания повторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.</p>"},{"subject":"Java Core","url":"004-core.html#почему-в-некоторых-интерфейсах-вообще-не-определяют-методов","title":"<p>Почему в некоторых интерфейсах вообще не определяют методов?</p>","answer":"<p>Это так называемые <em>маркерные интерфейсы</em>. Они просто указывают что класс относится к определенному типу. Примером может послужить интерфейс <code>Clonable</code>, который указывает на то, что класс поддерживает механизм клонирования.</p>"},{"subject":"Java Core","url":"004-core.html#почему-нельзя-объявить-метод-интерфейса-с-модификатором-final","title":"<p>Почему нельзя объявить метод интерфейса с модификатором <code>final</code>?</p>","answer":"<p>В случае интерфейсов указание модификатора <code>final</code> бессмысленно, т.к. все методы интерфейсов неявно объявляются как абстрактные, т.е. их невозможно выполнить, не реализовав где-то еще, а этого нельзя будет сделать, если у метода идентификатор <code>final</code>.</p>"},{"subject":"Java Core","url":"004-core.html#что-имеет-более-высокий-уровень-абстракции-класс-абстрактный-класс-или-интерфейс","title":"<p>Что имеет более высокий уровень абстракции - <em>класс</em>, <em>абстрактный класс</em> или <em>интерфейс</em>?</p>","answer":"<p>Интерфейс.</p>"},{"subject":"Java Core","url":"004-core.html#может-ли-объект-получить-доступ-к-члену-класса-объявленному-как-private-если-да-то-каким-образом","title":"<p>Может ли объект получить доступ к члену класса объявленному как <code>private</code>? Если да, то каким образом?</p>","answer":"<ul>\n<li>Внутри класса доступ к приватной переменной открыт без ограничений;</li>\n<li>Вложенный класс имеет полный доступ ко всем (в том числе и приватным) членам содержащего его класса;</li>\n<li>Доступ к приватным переменным извне может быть организован через отличные от приватных методы, которые предоставлены разработчиком класса. Например: <code>getX()</code> и <code>setX()</code>.</li>\n<li>Через механизм рефлексии (Reflection API):</li>\n</ul>\n<pre><code class=\"java language-java\">class Victim {\n    private int field = 42;\n}\n//...\nVictim victim = new Victim();\nField field = Victim.class.getDeclaredField(\"field\");\nfield.setAccessible(true);\nint fieldValue = (int) field.get(victim);\n//...\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#каков-порядок-вызова-конструкторов-и-блоков-инициализации-с-учётом-иерархии-классов","title":"<p>Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?</p>","answer":"<p>Сначала вызываются все статические блоки в очередности от первого статического блока корневого предка и выше по цепочке иерархии до статических блоков самого класса.</p>\n<p>Затем вызываются нестатические блоки инициализации корневого предка, конструктор корневого предка и так далее вплоть до нестатических блоков и конструктора самого класса.</p>\n<blockquote>\n  <p>Parent static block(s) → Child static block(s) → Grandchild static block(s)</p>\n  <p>→ Parent non-static block(s) → Parent constructor →</p>\n  <p>→ Child non-static block(s) → Child constructor →</p>\n  <p>→ Grandchild non-static block(s) → Grandchild constructor</p>\n</blockquote>\n<p>Пример 1:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n    public static void main(String args[]) {\n        System.out.println(TestClass.v);\n        new TestClass().a();\n    }\n\n}\n</code></pre>\n<pre><code class=\"java language-java\">public class TestClass {\n\n    public static String v = \"Some val\";\n\n    {\n        System.out.println(\"!!! Non-static initializer\");\n    }\n\n    static {\n        System.out.println(\"!!! Static initializer\");\n    }\n\n    public void a() {\n        System.out.println(\"!!! a() called\");\n    }\n\n}\n</code></pre>\n<p>Результат выполнения:</p>\n<pre><code>!!! Static initializer\nSome val\n!!! Non-static initializer\n!!! a() called\n</code></pre>\n<p>Пример 2:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n    public static void main(String args[]) {\n        new TestClass().a();\n    }\n\n}\n</code></pre>\n<pre><code class=\"java language-java\">public class TestClass {\n\n    public static String v = \"Some val\";\n\n    {\n        System.out.println(\"!!! Non-static initializer\");\n    }\n\n    static {\n        System.out.println(\"!!! Static initializer\");\n    }\n\n    public void a() {\n        System.out.println(\"!!! a() called\");\n    }\n\n}\n</code></pre>\n<p>Результат выполнения:</p>\n<pre><code>!!! Static initializer\n!!! Non-static initializer\n!!! a() called\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#зачем-нужны-и-какие-бывают-блоки-инициализации","title":"<p>Зачем нужны и какие бывают блоки инициализации?</p>","answer":"<p>Блоки инициализации представляют собой код, заключенный в фигурные скобки и размещаемый внутри класса вне объявления методов или конструкторов.</p>\n<ul>\n<li>Существуют статические и нестатические блоки инициализации.</li>\n<li>Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.</li>\n<li>Несколько блоков инициализации выполняются в порядке следования в коде класса.</li>\n<li>Блок инициализации способен генерировать исключения, если их объявления перечислены в <code>throws</code> всех конструкторов класса.</li>\n<li>Блок инициализации возможно создать и в анонимном классе.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#к-каким-конструкциям-java-применим-модификатор-static","title":"<p>К каким конструкциям Java применим модификатор <code>static</code>?</p>","answer":"<ul>\n<li>полям;</li>\n<li>методам;</li>\n<li>вложенным классам;</li>\n<li>членам секции <code>import</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#для-чего-в-java-используются-статические-блоки-инициализации","title":"<p>Для чего в Java используются статические блоки инициализации?</p>","answer":"<p>Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса <code>Class</code>).</p>"},{"subject":"Java Core","url":"004-core.html#что-произойдёт-если-в-блоке-инициализации-возникнет-исключительная-ситуация","title":"<p>Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?</p>","answer":"<p>Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом требуется, чтобы объявления этих исключений были перечислены в <code>throws</code> всех конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.</p>\n<p>В остальных случаях, взаимодействие с исключениями будет проходить так же как и в любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.</p>"},{"subject":"Java Core","url":"004-core.html#какое-исключение-выбрасывается-при-возникновении-ошибки-в-блоке-инициализации-класса","title":"<p>Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?</p>","answer":"<p>Если возникшее исключение - наследник <code>RuntimeException</code>:</p>\n<ul>\n<li>для статических блоков инициализации будет выброшено <code>java.lang.ExceptionInInitializerError</code>;</li>\n<li>для нестатических будет проброшено исключение-источник.</li>\n</ul>\n<p>Если возникшее исключение - наследник <code>Error</code>, то в обоих случаях будет выброшено <code>java.lang.Error</code>. Исключение: <code>java.lang.ThreadDeath</code> - смерть потока. В этом случае никакое исключение выброшено не будет.</p>"},{"subject":"Java Core","url":"004-core.html#может-ли-статический-метод-быть-переопределён-или-перегружен","title":"<p>Может ли статический метод быть переопределён или перегружен?</p>","answer":"<p>Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.</p>\n<p>Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода это вполне корректная языковая конструкция.</p>\n<p>В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.</p>"},{"subject":"Java Core","url":"004-core.html#могут-ли-нестатические-методы-перегрузить-статические","title":"<p>Могут ли нестатические методы перегрузить статические?</p>","answer":"<p>Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.</p>"},{"subject":"Java Core","url":"004-core.html#можно-ли-сузить-уровень-доступатип-возвращаемого-значения-при-переопределении-метода","title":"<p>Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?</p>","answer":""},{"subject":"Java Core","url":"004-core.html#возможно-ли-при-переопределении-метода-изменить-модификатор-доступа-возвращаемый-тип-тип-аргумента-или-их-количество-имена-аргументов-или-их-порядок-убирать-добавлять-изменять-порядок-следования-элементов-секции-throws","title":"<p>Возможно ли при переопределении метода изменить: модификатор доступа, возвращаемый тип, тип аргумента или их количество, имена аргументов или их порядок; убирать, добавлять, изменять порядок следования элементов секции <code>throws</code>?</p>","answer":"<p>При переопределении метода сужать модификатор доступа не разрешается, т.к. это приведёт к нарушению принципа подстановки Барбары Лисков. Расширение уровня доступа возможно.</p>\n<p>Можно изменять все, что не мешает компилятору понять какой метод родительского класса имеется в виду:</p>\n<ul>\n<li>Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).</li>\n<li>При изменении типа, количества, порядка следования аргументов вместо переопределения будет происходить <em>overloading</em> (перегрузка) метода.</li>\n<li>Секцию <code>throws</code> метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения <code>RuntimeException</code>. Порядок следования таких элементов при переопределении значения не имеет.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#как-получить-доступ-к-переопределенным-методам-родительского-класса","title":"<p>Как получить доступ к переопределенным методам родительского класса?</p>","answer":"<p>С помощью ключевого слова <code>super</code> мы можем обратиться к любому члену родительского класса - методу или полю, если они не определены с модификатором <code>private</code>.</p>\n<pre><code class=\"java language-java\">super.method();\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#можно-ли-объявить-метод-абстрактным-и-статическим-одновременно","title":"<p>Можно ли объявить метод абстрактным и статическим одновременно?</p>","answer":"<p>Нет. В таком случае компилятор выдаст ошибку: <em>\"Illegal combination of modifiers: ‘abstract’ and ‘static’\"</em>. Модификатор <code>abstract</code> говорит, что метод будет реализован в другом классе, а <code>static</code> наоборот указывает, что этот метод будет доступен по имени класса.</p>"},{"subject":"Java Core","url":"004-core.html#в-чем-разница-между-членом-экземпляра-класса-и-статическим-членом-класса","title":"<p>В чем разница между членом экземпляра класса и статическим членом класса?</p>","answer":"<p>Модификатор <code>static</code> говорит о том, что данный метод или поле принадлежат самому классу и доступ к ним возможен даже без создания экземпляра класса. Поля помеченные <code>static</code> инициализируются при инициализации класса. На методы, объявленные как <code>static</code>, накладывается ряд ограничений:</p>\n<ul>\n<li>Они могут вызывать только другие статические методы.</li>\n<li>Они должны осуществлять доступ только к статическим переменным.</li>\n<li>Они не могут ссылаться на члены типа <code>this</code> или <code>super</code>.</li>\n</ul>\n<p>в отличие от статических, поля экземпляра класса принадлежат конкретному объекту и могут иметь разные значения для каждого. Вызов метода экземпляра возможен только после предварительного создания объекта класса.</p>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n public static void main(String args[]) {\n  System.out.println(TestClass.v);\n  new TestClass().a();\n  System.out.println(TestClass.v);\n }\n\n}\n</code></pre>\n<pre><code class=\"java language-java\">public class TestClass {\n\n public static String v = \"Initial val\";\n\n {\n  System.out.println(\"!!! Non-static initializer\");\n  v = \"Val from non-static\";\n }\n\n static {\n  System.out.println(\"!!! Static initializer\");\n  v = \"Some val\";\n }\n\n public void a() {\n  System.out.println(\"!!! a() called\");\n }\n\n}\n</code></pre>\n<p>Результат:</p>\n<pre><code>!!! Static initializer\nSome val\n!!! Non-static initializer\n!!! a() called\nVal from non-static\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#где-разрешена-инициализация-статическихнестатических-полей","title":"<p>Где разрешена инициализация статических/нестатических полей?</p>","answer":"<ul>\n<li>Статические поля можно инициализировать при объявлении, в статическом или нестатическом блоке инициализации.</li>\n<li>Нестатические поля можно инициализировать при объявлении, в нестатическом блоке инициализации или в конструкторе.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#какие-типы-классов-бывают-в-java","title":"<p>Какие типы классов бывают в java?</p>","answer":"<ul>\n<li><em>Top level class</em> (Обычный класс):<ul>\n<li><em>Abstract class</em> (Абстрактный класс);</li>\n<li><em>Final class</em> (Финализированный класс).</li></ul></li>\n<li><em>Interfaces</em> (Интерфейс).</li>\n<li><em>Enum</em> (Перечисление).</li>\n<li><em>Nested class</em> (Вложенный класс):<ul>\n<li><em>Static nested class</em> (Статический вложенный класс);</li>\n<li><em>Member inner class</em> (Простой внутренний класс);</li>\n<li><em>Local inner class</em> (Локальный класс);</li>\n<li><em>Anonymous inner class</em> (Анонимный класс).</li></ul></li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#расскажите-про-вложенные-классы-в-каких-случаях-они-применяются","title":"<p>Расскажите про вложенные классы. В каких случаях они применяются?</p>","answer":"<p>Класс называется вложенным (<em>Nested class</em>), если он определен внутри другого класса. Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к некоторому нарушению инкапсуляции.</p>\n<p>Существуют четыре категории вложенных классов:\n    + <em>Static nested class</em> (Статический вложенный класс);\n    + <em>Member inner class</em> (Простой внутренний класс);\n    + <em>Local inner class</em> (Локальный класс);\n    + <em>Anonymous inner class</em> (Анонимный класс).</p>\n<p>Такие категории классов, за исключением первого, также называют внутренними (<em>Inner class</em>). Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.</p>\n<p>Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае, если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим. Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого класса только в этом методе, то используется локальный класс. А, если к тому же применение класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий этот класс, то рекомендуется делать его анонимным классом.</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-статический-класс","title":"<p>Что такое <em>«статический класс»</em>?</p>","answer":"<p>Это вложенный класс, объявленный с использованием ключевого слова <code>static</code>. К классам верхнего уровня модификатор <code>static</code> неприменим.</p>"},{"subject":"Java Core","url":"004-core.html#какие-существуют-особенности-использования-вложенных-классов-статических-и-внутренних-в-чем-заключается-разница-между-ними","title":"<p>Какие существуют особенности использования вложенных классов: статических и внутренних? В чем заключается разница между ними?</p>","answer":"<ul>\n<li>Вложенные классы могут обращаться ко всем членам обрамляющего класса, в том числе и приватным.</li>\n<li>Для создания объекта статического вложенного класса объект внешнего класса не требуется.</li>\n<li>Из объекта статического вложенного класса нельзя обращаться к не статическим членам обрамляющего класса напрямую, а только через ссылку на экземпляр внешнего класса.</li>\n<li>Обычные вложенные классы не могут содержать статических методов, блоков инициализации и классов. Статические вложенные классы - могут.</li>\n<li>В объекте обычного вложенного класса хранится ссылка на объект внешнего класса. Внутри статического такой ссылки нет. Доступ к экземпляру обрамляющего класса осуществляется через указание <code>.this</code> после его имени. Например: <code>Outer.this</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-локальный-класс-каковы-его-особенности","title":"<p>Что такое <em>«локальный класс»</em>? Каковы его особенности?</p>","answer":"<p><strong>Local inner class</strong> (Локальный класс) - это вложенный класс, который может быть декларирован в любом блоке, в котором разрешается декларировать переменные. Как и простые внутренние классы (<em>Member inner class</em>) локальные классы имеют имена и могут использоваться многократно. Как и анонимные классы, они имеют окружающий их экземпляр только тогда, когда применяются в нестатическом контексте.</p>\n<p>Локальные классы имеют следующие особенности:</p>\n<ul>\n<li>Видны только в пределах блока, в котором объявлены;</li>\n<li>Не могут быть объявлены как <code>private</code>/<code>public</code>/<code>protected</code> или <code>static</code>;</li>\n<li>Не могут иметь внутри себя статических объявлений методов и классов, но могут иметь финальные статические поля, проинициализированные константой;</li>\n<li>Имеют доступ к полям и методам обрамляющего класса;</li>\n<li>Могут обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором <code>final</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-анонимные-классы-где-они-применяются","title":"<p>Что такое <em>«анонимные классы»</em>? Где они применяются?</p>","answer":"<p>Это вложенный локальный класс без имени, который разрешено декларировать в любом месте обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного класса происходит одновременно с его объявлением. В зависимости от местоположения анонимный класс ведет себя как статический либо как нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.</p>\n<p>Анонимные классы имеют несколько ограничений:</p>\n<ul>\n<li>Их использование разрешено только в одном месте программы - месте его создания;</li>\n<li>Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;</li>\n<li>Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо новых методов, так как для доступа к ним нет поименованного типа.</li>\n</ul>\n<p>Анонимные классы обычно применяются для:</p>\n<ul>\n<li>создания объекта функции (<em>function object</em>), например реализация интерфейса <code>Comparator</code>;</li>\n<li>создания объекта процесса (<em>process object</em>), такого как экземпляры классов <code>Thread</code>, <code>Runnable</code> и подобных;</li>\n<li>в статическом методе генерации;</li>\n<li>инициализации открытого статического поля <code>final</code>, которое соответствует сложному перечислению типов, когда для каждого экземпляра в перечислении требуется отдельный подкласс.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#каким-образом-из-вложенного-класса-получить-доступ-к-полю-внешнего-класса","title":"<p>Каким образом из вложенного класса получить доступ к полю внешнего класса?</p>","answer":"<p>Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.</p>\n<p>Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую. В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к такому полю следует через ссылку на его экземпляр. Например: <code>Outer.this.field</code>.</p>"},{"subject":"Java Core","url":"004-core.html#для-чего-используется-оператор-assert","title":"<p>Для чего используется оператор <code>assert</code>?</p>","answer":"<p><strong>Assert</strong> (Утверждение) — это специальная конструкция, позволяющая проверять предположения о значениях произвольных данных в произвольном месте программы. Утверждение может автоматически сигнализировать об обнаружении некорректных данных, что обычно приводит к аварийному завершению программы с указанием места обнаружения некорректных данных.</p>\n<p>Утверждения существенно упрощают локализацию ошибок в коде. Даже проверка результатов выполнения очевидного кода может оказаться полезной при последующем рефакторинге, после которого код может стать не настолько очевидным и в него может закрасться ошибка.</p>\n<p>Обычно утверждения оставляют включенными во время разработки и тестирования программ, но отключают в релиз-версиях программ.</p>\n<p>Т.к. утверждения могут быть удалены на этапе компиляции либо во время исполнения программы, они не должны менять поведение программы. Если в результате удаления утверждения поведение программы может измениться, то это явный признак неправильного использования <em>assert</em>. Таким образом, внутри <em>assert</em> нельзя вызывать методы, изменяющие состояние программы, либо внешнего окружения программы.</p>\n<p>В Java проверка утверждений реализована с помощью оператора <code>assert</code>, который имеет форму:</p>\n<p><code>assert [Выражение типа boolean];</code> или <code>assert [Выражение типа boolean] : [Выражение любого типа, кроме void];</code></p>\n<p>Во время выполнения программы в том случае, если поверка утверждений включена, вычисляется значение булевского выражения, и если его результат <code>false</code>, то генерируется исключение <code>java.lang.AssertionError</code>. В случае использования второй формы оператора <code>assert</code> выражение после двоеточия задаёт детальное сообщение о произошедшей ошибке (вычисленное выражение будет преобразовано в строку и передано конструктору <code>AssertionError</code>).</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-heap-и-stack-память-в-java-какая-разница-между-ними","title":"<p>Что такое <em>Heap</em> и <em>Stack</em> память в Java? Какая разница между ними?</p>","answer":"<p><strong>Heap (куча)</strong> используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.</p>\n<p><strong>Stack (стек)</strong> это область хранения данных также находящееся в общей оперативной памяти (<em>RAM</em>). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.\nРазмер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме <em>LIFO</em> (Последний-зашел-Первый-вышел)</p>\n<p>Различия между <em>Heap</em> и <em>Stack</em> памятью:</p>\n<ul>\n<li>Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.</li>\n<li>Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.</li>\n<li>Объекты в куче доступны с любой точке программы, в то время как стековая память не может быть доступна для других потоков.</li>\n<li>Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.</li>\n<li>Если память стека полностью занята, то Java Runtime бросает исключение <code>java.lang.StackOverflowError</code>. Если заполнена память кучи, то бросается исключение <code>java.lang.OutOfMemoryError: Java Heap Space</code>.</li>\n<li>Размер памяти стека намного меньше памяти в куче.</li>\n<li>Из-за простоты распределения памяти, стековая память работает намного быстрее кучи.</li>\n</ul>\n<p>Для определения начального и максимального размера памяти в куче используются <code>-Xms</code> и <code>-Xmx</code> опции JVM. Для стека определить размер памяти можно с помощью опции <code>-Xss</code>.</p>"},{"subject":"Java Core","url":"004-core.html#верно-ли-утверждение-что-примитивные-типы-данных-всегда-хранятся-в-стеке-а-экземпляры-ссылочных-типов-данных-в-куче","title":"<p>Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?</p>","answer":"<p>Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. Любой объект (всё, что явно или неявно создаётся при помощи оператора <code>new</code>) хранится в куче.</p>"},{"subject":"Java Core","url":"004-core.html#каким-образом-передаются-переменные-в-методы-по-значению-или-по-ссылке","title":"<p>Каким образом передаются переменные в методы, по значению или по ссылке?</p>","answer":"<p>В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, указывающую на экземпляр - нет.</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-пул-строк","title":"<p>Что такое «пул строк»?</p>","answer":"<p><strong>Пул строк</strong> – это набор строк хранящийся в <em>Heap</em>.</p>\n<ul>\n<li>Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;</li>\n<li>Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;</li>\n<li>Когда для создания строки используются <code>\"</code>, то сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;</li>\n<li>При использовании оператора <code>new</code> создаётся новый объект <code>String</code>. Затем при помощи метода <code>intern()</code> эту строку можно поместить в пул или же получить из пула ссылку на другой объект <code>String</code> с таким же значением;</li>\n<li>Пул строк является примером паттерна <em>«Приспособленец» (Flyweight)</em>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-finalize-зачем-он-нужен","title":"<p>Что такое <code>finalize()</code>? Зачем он нужен?</p>","answer":"<p>Через вызов метода <code>finalize()</code> (который наследуется от Java.lang.Object) JVM реализуется функциональность аналогичная функциональности деструкторов в С++, используемых для очистки памяти перед возвращением управления операционной системе. Данный метод вызывается при уничтожении объекта сборщиком мусора (<em>garbage collector</em>) и переопределяя <code>finalize()</code> можно запрограммировать действия необходимые для корректного удаления экземпляра класса - например, закрытие сетевых соединений, соединений с базой данных, снятие блокировок на файлы и т.д.</p>\n<p>После выполнения этого метода объект должен быть повторно собран сборщиком мусора (и это считается серьезной проблемой метода <code>finalize()</code> т.к. он мешает сборщику мусора освобождать память). Вызов этого метода не гарантируется, т.к. приложение может быть завершено до того, как будет запущена сборка мусора.</p>\n<p>Объект не обязательно будет доступен для сборки сразу же - метод <code>finalize()</code> может сохранить куда-нибудь ссылку на объект. Подобная ситуация называется «возрождением» объекта и считается антипаттерном. Главная проблема такого трюка - в том, что «возродить» объект можно только 1 раз.</p>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n public static void main(String args[]) {\n  TestClass a = new TestClass();\n  a.a();\n  a = null;\n  a = new TestClass();\n  a.a();\n  System.out.println(\"!!! done\");\n }\n}\n</code></pre>\n<pre><code class=\"java language-java\">public class TestClass {\n\n public void a() {\n  System.out.println(\"!!! a() called\");\n }\n\n @Override\n protected void finalize() throws Throwable {\n  System.out.println(\"!!! finalize() called\");\n  super.finalize();\n }\n}\n</code></pre>\n<p>Так как в данном случае сборщик мусора может и не быть вызван (в силу простоты приложения), то результат выполнения программы с большой вероятностью будет следующий:</p>\n<pre><code>!!! a() called\n!!! a() called\n!!! done\n</code></pre>\n<p>Теперь несколько усложним программу, добавив принудительный вызов Garbage Collector:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n public static void main(String args[]) {\n  TestClass a = new TestClass();\n  a.a();\n  a = null;\n  System.gc(); // Принудительно зовём сборщик мусора\n  a = new TestClass();\n  a.a();\n  System.out.println(\"!!! done\");\n }\n\n}\n</code></pre>\n<p>Как и было сказано ранее, Garbage Collector может в разное время отработать, поэтому результат выполнения может разниться от запуска к запуску:\nВариант а:</p>\n<pre><code>!!! a() called\n!!! a() called\n!!! done\n!!! finalize() called\n</code></pre>\n<p>Вариант б:</p>\n<pre><code>!!! a() called\n!!! a() called\n!!! finalize() called\n!!! done\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#что-произойдет-со-сборщиком-мусора-если-выполнение-метода-finalize-требует-ощутимо-много-времени-или-в-процессе-выполнения-будет-выброшено-исключение","title":"<p>Что произойдет со сборщиком мусора, если выполнение метода <code>finalize()</code> требует ощутимо много времени, или в процессе выполнения будет выброшено исключение?</p>","answer":"<p>Непосредственно вызов <code>finalize()</code> происходит в отдельном потоке <em>Finalizer</em> (<code>java.lang.ref.Finalizer.FinalizerThread</code>), который создаётся при запуске виртуальной машины (в статической секции при загрузке класса <code>Finalizer</code>). Методы <code>finalize()</code> вызываются последовательно в том порядке, в котором были добавлены в список сборщиком мусора. Соответственно, если какой-то <code>finalize()</code> зависнет, он подвесит поток <em>Finalizer</em>, но не сборщик мусора. Это в частности означает, что объекты, не имеющие метода <code>finalize()</code>, будут исправно удаляться, а вот имеющие будут добавляться в очередь, пока поток <em>Finalizer</em> не освободится, не завершится приложение или не кончится память.</p>\n<p>То же самое применимо и выброшенным в процессе <code>finalize()</code> исключениям: метод <code>runFinalizer()</code> у потока <em>Finalizer</em> игнорирует все исключения выброшенные в момент выполнения <code>finalize()</code>. Таким образом возникновение исключительной ситуации никак не скажется на работоспособности сборщика мусора.</p>"},{"subject":"Java Core","url":"004-core.html#чем-отличаются-final-finally-и-finalize","title":"<p>Чем отличаются <code>final</code>, <code>finally</code> и <code>finalize()</code>?</p>","answer":"<p>Модификатор <code>final</code>:</p>\n<ul>\n<li>Класс не может иметь наследников;</li>\n<li>Метод не может быть переопределен в классах наследниках;</li>\n<li>Поле не может изменить свое значение после инициализации;</li>\n<li>Локальные переменные не могут быть изменены после присвоения им значения;</li>\n<li>Параметры методов не могут изменять своё значение внутри метода.</li>\n</ul>\n<p>Оператор <code>finally</code> гарантирует, что определенный в нём участок кода будет выполнен независимо от того, какие исключения были возбуждены и перехвачены в блоке <code>try-catch</code>.</p>\n<p>Метод <code>finalize()</code> вызывается перед тем как сборщик мусора будет проводить удаление объекта.</p>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">public class MainClass {\n\n public static void main(String args[]) {\n  TestClass a = new TestClass();\n  System.out.println(\"result of a.a() is \" + a.a());\n  a = null;\n  System.gc(); // Принудительно зовём сборщик мусора\n  a = new TestClass();\n  System.out.println(\"result of a.a() is \" + a.a());\n  System.out.println(\"!!! done\");\n }\n\n}\n</code></pre>\n<pre><code class=\"java language-java\">public class TestClass {\n\n public int a() {\n  try {\n   System.out.println(\"!!! a() called\");\n   throw new Exception(\"\");\n  } catch (Exception e) {\n   System.out.println(\"!!! Exception in a()\");\n   return 2;\n  } finally {\n   System.out.println(\"!!! finally in a() \");\n  }\n }\n\n @Override\n protected void finalize() throws Throwable {\n  System.out.println(\"!!! finalize() called\");\n  super.finalize();\n }\n}\n</code></pre>\n<p>Результат выполнения:</p>\n<pre><code>!!! a() called\n!!! Exception in a()\n!!! finally in a()\nresult of a.a() is 2\n!!! a() called\n!!! Exception in a()\n!!! finally in a()\n!!! finalize() called\nresult of a.a() is 2\n!!! done\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#расскажите-про-приведение-типов-что-такое-понижение-и-повышение-типа","title":"<p>Расскажите про приведение типов. Что такое понижение и повышение типа?</p>","answer":"<p>Java является строго типизированным языком программирования, а это означает, то что каждое выражение и каждая переменная имеет строго определенный тип уже на момент компиляции. Однако определен механизм <em>приведения типов (casting)</em> - способ преобразования значения переменной одного типа в значение другого типа.</p>\n<p>В Java существуют несколько разновидностей приведения:</p>\n<ul>\n<li><strong>Тождественное (identity)</strong>. Преобразование выражения любого типа к точно такому же типу всегда допустимо и происходит автоматически.</li>\n<li><strong>Расширение (повышение, upcasting) примитивного типа (widening primitive)</strong>. Означает, что осуществляется переход от менее емкого типа к более ёмкому. Например, от типа <code>byte</code> (длина 1 байт) к типу <code>int</code> (длина 4 байта). Такие преобразование безопасны в том смысле, что новый тип всегда гарантировано вмещает в себя все данные, которые хранились в старом типе и таким образом не происходит потери данных. Этот тип приведения всегда допустим и происходит автоматически.</li>\n<li><strong>Сужение (понижение, downcasting) примитивного типа (narrowing primitive)</strong>. Означает, что переход осуществляется от более емкого типа к менее емкому. При таком преобразовании есть риск потерять данные. Например, если число типа <code>int</code> было больше <code>127</code>, то при приведении его к <code>byte</code> значения битов старше восьмого будут потеряны. В Java такое преобразование должно совершаться явным образом, при этом все старшие биты, не умещающиеся в новом типе, просто отбрасываются - никакого округления или других действий для получения более корректного результата не производится.</li>\n<li><strong>Расширение объектного типа (widening reference)</strong>. Означает неявное восходящее приведение типов или переход от более конкретного типа к менее конкретному, т.е. переход от потомка к предку. Разрешено всегда и происходит автоматически.</li>\n<li><strong>Сужение объектного типа (narrowing reference)</strong>. Означает нисходящее приведение, то есть приведение от предка к потомку (подтипу). Возможно только если исходная переменная является подтипом приводимого типа. При несоответствии типов в момент выполнения выбрасывается исключение <code>ClassCastException</code>. Требует явного указания типа.</li>\n<li><strong>Преобразование к строке (to String)</strong>. Любой тип может быть приведен к строке, т.е. к экземпляру класса <code>String</code>.</li>\n<li><strong>Запрещенные преобразования (forbidden)</strong>. Не все приведения между произвольными типами допустимы. Например, к запрещенным преобразованиям относятся приведения от любого ссылочного типа к примитивному и наоборот (кроме преобразования к строке). Кроме того невозможно привести друг к другу классы находящиеся на разных ветвях дерева наследования и т.п.</li>\n</ul>\n<p>При приведении ссылочных типов с самим объектом ничего не происходит, - меняется лишь тип ссылки, через которую происходит обращение к объекту.</p>\n<p>Для проверки возможности приведения нужно воспользоваться оператором <code>instanceof</code>:</p>\n<pre><code class=\"java language-java\">Parent parent = new Child();\nif (parent instanceof Child) {\n    Child child = (Child) parent;\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#когда-в-приложении-может-быть-выброшено-исключение-classcastexception","title":"<p>Когда в приложении может быть выброшено исключение <code>ClassCastException</code>?</p>","answer":"<p><code>ClassCastException</code> (потомок <code>RuntimeException</code>) - исключение, которое будет выброшено при ошибке приведения типа.</p>"},{"subject":"Java Core","url":"004-core.html#какие-есть-особенности-класса-string","title":"<p>Какие есть особенности класса <code>String</code>?</p>","answer":"<ul>\n<li>Это неизменяемый (immutable) и финализированный тип данных;</li>\n<li>Все объекты класса <code>String</code> JVM хранит в пуле строк;</li>\n<li>Объект класса <code>String</code> можно получить используя двойные кавычки;</li>\n<li>Можно использовать оператор <code>+</code> для конкатенации строк;</li>\n<li>Начиная с Java 7 строки можно использовать в конструкции <code>switch</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#почему-string-неизменяемый-и-финализированный-класс","title":"<p>Почему <code>String</code> неизменяемый и финализированный класс?</p>","answer":"<p>Есть несколько преимуществ в неизменности строк:</p>\n<ul>\n<li>Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше свободного места в <em>Heap</em>, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле. Если бы строка была изменяемой, то интернирование строк не было бы возможным, потому что изменение значения одной переменной отразилось бы также и на остальных переменных, ссылающихся на эту строку.</li>\n<li>Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае злоумышленник может изменить значение ссылки и вызвать проблемы в безопасности приложения.</li>\n<li>Неизменяемость позволяет избежать синхронизации: строки безопасны для многопоточности и один экземпляр строки может быть совместно использован различными потоками.</li>\n<li>Строки используются <em>classloader</em> и неизменность обеспечивает правильность загрузки класса.</li>\n<li>Поскольку строка неизменяемая, её <code>hashCode()</code> кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в <code>HashMap</code> т.к. его обработка происходит быстрее.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#почему-char-предпочтительнее-string-для-хранения-пароля","title":"<p>Почему <code>char[]</code> предпочтительнее <code>String</code> для хранения пароля?</p>","answer":"<p>С момента создания строка остаётся в пуле, до тех пор пока не будет удалена сборщиком мусора. Поэтому, даже после окончания использования пароля, он некоторое время продолжает оставаться доступным в памяти и способа избежать этого не существует. Это представляет определённый риск для безопасности, поскольку кто-либо, имеющий доступ к памяти сможет найти пароль в виде текста.\nВ случае использования массива символов для хранения пароля имеется возможность очистить его сразу по окончанию работы с паролем, позволяя избежать риска безопасности, свойственного строке.</p>"},{"subject":"Java Core","url":"004-core.html#почему-строка-является-популярным-ключом-в-hashmap-в-java","title":"<p>Почему строка является популярным ключом в <code>HashMap</code> в Java?</p>","answer":"<p>Поскольку строки неизменяемы, их хэш код вычисляется и кэшируется в момент создания, не требуя повторного пересчета при дальнейшем использовании. Поэтому в качестве ключа <code>HashMap</code> они будут обрабатываться быстрее.</p>"},{"subject":"Java Core","url":"004-core.html#что-делает-метод-intern-в-классе-string","title":"<p>Что делает метод <code>intern()</code> в классе <code>String</code>?</p>","answer":"<p>Метод <code>intern()</code> используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже находится в пуле.</p>"},{"subject":"Java Core","url":"004-core.html#можно-ли-использовать-строки-в-конструкции-switch","title":"<p>Можно ли использовать строки в конструкции <code>switch</code>?</p>","answer":"<p>Да, начиная с Java 7 в операторе <code>switch</code> можно использовать строки, ранние версии Java не поддерживают этого. При этом:</p>\n<ul>\n<li>участвующие строки чувствительны к регистру;</li>\n<li>используется метод <code>equals()</code> для сравнения полученного значения со значениями <code>case</code>, поэтому во избежание <code>NullPointerException</code> стоит предусмотреть проверку на <code>null</code>.</li>\n<li>согласно документации Java 7 для строк в <code>switch</code>, компилятор Java формирует более эффективный байт-код для строк в конструкции <code>switch</code>, чем для сцепленных условий <code>if</code>-<code>else</code>.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#какая-основная-разница-между-string-stringbuffer-stringbuilder","title":"<p>Какая основная разница между <code>String</code>, <code>StringBuffer</code>, <code>StringBuilder</code>?</p>","answer":"<p>Класс <code>String</code> является неизменяемым (<em>immutable</em>) - модифицировать объект такого класса нельзя, можно лишь заменить его созданием нового экземпляра.</p>\n<p>Класс <code>StringBuffer</code> изменяемый - использовать <code>StringBuffer</code> следует тогда, когда необходимо часто модифицировать содержимое.</p>\n<p>Класс <code>StringBuilder</code> был добавлен в Java 5 и он во всем идентичен классу <code>StringBuffer</code> за исключением того, что он не синхронизирован и поэтому его методы выполняются значительно быстрей.</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-класс-object-какие-в-нем-есть-методы","title":"<p>Что такое класс <code>Object</code>? Какие в нем есть методы?</p>","answer":"<p><code>Object</code> это базовый класс для всех остальных объектов в Java. Любой класс наследуется от <code>Object</code> и, соответственно, наследуют его методы:</p>\n<p><code>public boolean equals(Object obj)</code> – служит для сравнения объектов по значению;\n<code>int hashCode()</code> – возвращает hash код для объекта;\n<code>String toString()</code> – возвращает строковое представление объекта;\n<code>Class getClass()</code> – возвращает класс объекта во время выполнения;\n<code>protected Object clone()</code> – создает и возвращает копию объекта;\n<code>void notify()</code> – возобновляет поток, ожидающий монитор;\n<code>void notifyAll()</code> – возобновляет все потоки, ожидающие монитор;\n<code>void wait()</code> – остановка вызвавшего метод потока до момента пока другой поток не вызовет метод <code>notify()</code>\nили <code>notifyAll()</code> для этого объекта;\n<code>void wait(long timeout)</code> – остановка вызвавшего метод потока на определённое время или пока другой поток не вызовет\nметод <code>notify()</code> или <code>notifyAll()</code> для этого объекта;\n<code>void wait(long timeout, int nanos)</code> – остановка вызвавшего метод потока на определённое время или пока другой поток не\nвызовет метод <code>notify()</code> или <code>notifyAll()</code> для этого объекта;\n<code>protected void finalize()</code> – может вызываться сборщиком мусора в момент удаления объекта при сборке мусора.</p>"},{"subject":"Java Core","url":"004-core.html#дайте-определение-понятию-конструктор","title":"<p>Дайте определение понятию «конструктор»</p>","answer":"<p><strong>Конструктор</strong> — это специальный метод у которого отсутствует возвращаемый тип и который имеет то же имя, что и класс,\nв котором он используется. Конструктор вызывается при создании нового объекта класса и определяет действия необходимые\nдля его инициализации.</p>"},{"subject":"Java Core","url":"004-core.html#что-такое-конструктор-по-умолчанию","title":"<p>Что такое <em>«конструктор по умолчанию»</em>?</p>","answer":"<p>Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так\nназываемый <strong>«конструктор по умолчанию»</strong>.</p>\n<pre><code class=\"java language-java\">public class ClassName() {}\n</code></pre>\n<p>Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.</p>"},{"subject":"Java Core","url":"004-core.html#чем-отличаются-конструктор-по-умолчанию-конструктор-копирования-и-конструктор-с-параметрами","title":"<p>Чем отличаются конструктор по умолчанию, конструктор копирования и конструктор с параметрами?</p>","answer":"<p>У конструктора по умолчанию отсутствуют какие-либо аргументы. Конструктор копирования принимает в качестве аргумента уже\nсуществующий объект класса для последующего создания его клона. Конструктор с параметрами имеет в своей сигнатуре\nаргументы (обычно необходимые для инициализации полей класса).</p>"},{"subject":"Java Core","url":"004-core.html#где-и-как-вы-можете-использовать-приватный-конструктор","title":"<p>Где и как вы можете использовать приватный конструктор?</p>","answer":"<p>Приватный (помеченный ключевым словом <code>private</code>, скрытый) конструктор может использоваться публичным статическим методом\nгенерации объектов данного класса. Также доступ к нему разрешён вложенным классам и может использоваться для их нужд.</p>"},{"subject":"Java Core","url":"004-core.html#расскажите-про-классы-загрузчики-и-про-динамическую-загрузку-классов","title":"<p>Расскажите про классы-загрузчики и про динамическую загрузку классов</p>","answer":"<p>Основа работы с классами в Java — классы-загрузчики, обычные Java-объекты, предоставляющие интерфейс для поиска и\nсоздания объекта класса по его имени во время работы приложения.</p>\n<p>В начале работы программы создается 3 основных загрузчика классов:</p>\n<ul>\n<li><strong>базовый загрузчик (bootstrap/primordial)</strong>. Загружает основные системные и внутренние классы JDK (<em>Core API</em> -\nпакеты <code>java.*</code> (<code>rt.jar</code> и <code>i18n.jar</code>) . Важно заметить, что базовый загрузчик является <em>«Изначальным»</em> или\n<em>«Корневым»</em> и частью JVM, вследствие чего его нельзя создать внутри кода программы.</li>\n<li><strong>загрузчик расширений (extention)</strong>. Загружает различные пакеты расширений, которые располагаются в\nдиректории <code>&lt;JAVA_HOME&gt;/lib/ext</code> или другой директории, описанной в системном параметре <code>java.ext.dirs</code>. Это позволяет\nобновлять и добавлять новые расширения без необходимости модифицировать настройки используемых приложений. Загрузчик\nрасширений реализован классом <code>sun.misc.Launcher$ExtClassLoader</code>.</li>\n<li><strong>системный загрузчик (system/application)</strong>. Загружает классы, пути к которым указаны в переменной\nокружения <code>CLASSPATH</code> или пути, которые указаны в командной строке запуска JVM после ключей <code>-classpath</code> или <code>-cp</code>.\nСистемный загрузчик реализован классом <code>sun.misc.Launcher$AppClassLoader</code>.</li>\n</ul>\n<p>Загрузчики классов являются иерархическими: каждый из них (кроме базового) имеет родительский загрузчик и в большинстве\nслучаев, перед тем как попробовать загрузить класс самостоятельно, он посылает вначале запрос родительскому загрузчику\nзагрузить указанный класс. Такое делегирование позволяет загружать классы тем загрузчиком, который находится ближе всего\nк базовому в иерархии делегирования. Как следствие поиск классов будет происходить в источниках в порядке их доверия:\nсначала в библиотеке <em>Core API</em>, потом в папке расширений, потом в локальных файлах <code>CLASSPATH</code>.</p>\n<p>Процесс загрузки класса состоит из трех частей:</p>\n<ul>\n<li><em>Loading</em> – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике (в зависимости\nот загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие понятия как\n«методы», «поля» и т.д. пока не известны.</li>\n<li><em>Linking</em> – процесс, который может быть разбит на 3 части:<ul>\n<li><em>Bytecode verification</em> – проверка байт-кода на соответствие требованиям определенным в спецификации JVM.</li>\n<li><em>Class preparation</em> – создание и инициализация необходимых структур, используемых для представления полей,\nметодов, реализованных интерфейсов и т.п., определенных в загружаемом классе.</li>\n<li><em>Resolving</em> – загрузка набора классов, на которые ссылается загружаемый класс.</li></ul></li>\n<li><em>Initialization</em> – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.</li>\n</ul>\n<p>Динамическая загрузка классов в Java имеет ряд особенностей:</p>\n<ul>\n<li><em>отложенная (lazy) загрузка и связывание классов</em>. Загрузка классов производится только при необходимости, что позволяет экономить ресурсы и распределять нагрузку.</li>\n<li><em>проверка корректности загружаемого кода (type safeness)</em>. Все действия связанные с контролем использования типов производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.</li>\n<li><em>программируемая загрузка</em>. Пользовательский загрузчик полностью контролирует процесс получения запрошенного класса — самому ли искать байт-код и создавать класс или делегировать создание другому загрузчику. Дополнительно существует возможность выставлять различные атрибуты безопасности для загружаемых классов, позволяя таким образом работать с кодом из ненадежных источников.</li>\n<li><em>множественные пространства имен</em>. Каждый загрузчик имеет своё пространство имён для создаваемых классов. Соответственно, классы, загруженные двумя различными загрузчиками на основе общего байт-кода, в системе будут различаться.</li>\n</ul>\n<p>Существует несколько способов инициировать загрузку требуемого класса:</p>\n<ul>\n<li>явный: вызов <code>ClassLoader.loadClass()</code> или <code>Class.forName()</code> (по умолчанию используется загрузчик, создавший текущий класс, но есть возможность и явного указания загрузчика);</li>\n<li>неявный: когда для дальнейшей работы приложения требуется ранее не использованный класс, JVM инициирует его загрузку.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#что-такое-reflection","title":"<p>Что такое <em>Reflection</em>?</p>","answer":"<p><strong>Рефлексия (Reflection)</strong> - это механизм получения данных о программе во время её выполнения (runtime). В Java <em>Reflection</em> осуществляется с помощью <em>Java Reflection API</em>, состоящего из классов пакетов <code>java.lang</code> и <code>java.lang.reflect</code>.</p>\n<p>Возможности Java Reflection API:</p>\n<ul>\n<li>Определение класса объекта;</li>\n<li>Получение информации о модификаторах класса, полях, методах, конструкторах и суперклассах;</li>\n<li>Определение интерфейсов, реализуемых классом;</li>\n<li>Создание экземпляра класса;</li>\n<li>Получение и установка значений полей объекта;</li>\n<li>Вызов методов объекта;</li>\n<li>Создание нового массива.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#зачем-нужен-equals-чем-он-отличается-от-операции-","title":"<p>Зачем нужен <code>equals()</code>. Чем он отличается от операции <code>==</code>?</p>","answer":"<p>Метод <code>equals()</code> - определяет отношение эквивалентности объектов.</p>\n<p>При сравнение объектов с помощью <code>==</code> сравнение происходит лишь между ссылками. При сравнении по переопределённому разработчиком <code>equals()</code> - по внутреннему состоянию объектов.</p>"},{"subject":"Java Core","url":"004-core.html#если-вы-хотите-переопределить-equals-какие-условия-должны-выполняться","title":"<p>Если вы хотите переопределить <code>equals()</code>, какие условия должны выполняться?</p>","answer":""},{"subject":"Java Core","url":"004-core.html#какими-свойствами-обладает-порождаемое-equals-отношение-эквивалентности","title":"<p>Какими свойствами обладает порождаемое <code>equals()</code> отношение эквивалентности?</p>","answer":"<ul>\n<li><em>Рефлексивность</em>: для любой ссылки на значение <code>x</code>, <code>x.equals(x)</code> вернет <code>true</code>;</li>\n<li><em>Симметричность</em>: для любых ссылок на значения <code>x</code> и <code>y</code>, <code>x.equals(y)</code> должно вернуть <code>true</code>, тогда и только тогда,\nкогда <code>y.equals(x)</code> возвращает <code>true</code>.</li>\n<li><em>Транзитивность</em>: для любых ссылок на значения <code>x</code>, <code>y</code> и <code>z</code>, если <code>x.equals(y)</code> и <code>y.equals(z)</code> возвращают <code>true</code>,\nтогда и <code>x.equals(z)</code> вернёт <code>true</code>;</li>\n<li><em>Непротиворечивость</em>: для любых ссылок на значения <code>х</code> и <code>у</code>, если несколько раз вызвать <code>х.equals(y)</code>, постоянно\nбудет возвращаться значение <code>true</code> либо постоянно будет возвращаться значение <code>false</code> при условии, что никакая\nинформация, используемая при сравнении объектов, не поменялась.</li>\n</ul>\n<p>Для любой ненулевой ссылки на значение <code>х</code> выражение <code>х.equals(null)</code> должно возвращать <code>false</code>.</p>"},{"subject":"Java Core","url":"004-core.html#правила-переопределения-метода-objectequals","title":"<p>Правила переопределения метода <code>Object.equals()</code></p>","answer":"<ol>\n<li>Использование оператора <code>==</code> для проверки, является ли аргумент ссылкой на указанный объект. Если является,\nвозвращается <code>true</code>. Если сравниваемый объект <code>== null</code>, должно вернуться <code>false</code>.</li>\n<li>Использование оператор <code>instanceof</code> и вызова метода <code>getClass()</code> для проверки, имеет ли аргумент правильный тип. Если\nне имеет, возвращается <code>false</code>.</li>\n<li>Приведение аргумента к правильному типу. Поскольку эта операция следует за проверкой <code>instanceof</code> она гарантированно\nбудет выполнена.</li>\n<li>Обход всех значимых полей класса и проверка того, что значение поля в текущем объекте и значение того же поля в\nпроверяемом на эквивалентность аргументе соответствуют друг другу. Если проверки для всех полей прошли успешно,\nвозвращается результат <code>true</code>, в противном случае - <code>false</code>.</li>\n</ol>\n<p>По окончанию переопределения метода <code>equals()</code> следует проверить: является ли порождаемое отношение эквивалентности\nрефлексивным, симметричным, транзитивным и непротиворечивым? Если ответ отрицательный, метод подлежит соответствующей\nправке.</p>"},{"subject":"Java Core","url":"004-core.html#если-equals-переопределен-есть-ли-какие-либо-другие-методы-которые-следует-переопределить","title":"<p>Если <code>equals()</code> переопределен, есть ли какие-либо другие методы, которые следует переопределить?</p>","answer":"<p>Равные объекты должны возвращать одинаковые хэш коды. При переопределении <code>equals()</code> нужно обязательно переопределять и метод <code>hashCode()</code>.</p>"},{"subject":"Java Core","url":"004-core.html#что-будет-если-переопределить-equals-не-переопределяя-hashcode-какие-могут-возникнуть-проблемы","title":"<p>Что будет, если переопределить <code>equals()</code> не переопределяя <code>hashCode()</code>? Какие могут возникнуть проблемы?</p>","answer":"<p>Классы и методы, которые используют правила этого контракта могут работать некорректно. Так для <code>HashMap</code> это может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра ключа не будет в ней найдена.</p>"},{"subject":"Java Core","url":"004-core.html#каким-образом-реализованы-методы-hashcode-и-equals-в-классе-object","title":"<p>Каким образом реализованы методы <code>hashCode()</code> и <code>equals()</code> в классе <code>Object</code>?</p>","answer":"<p>Реализация метода <code>Object.equals()</code> сводится к проверке на равенство двух ссылок:</p>\n<pre><code class=\"java language-java\">public boolean equals(Object obj) {\n  return (this == obj);\n}\n</code></pre>\n<p>Реализация метода <code>Object.hashCode()</code> описана как <code>native</code>, т.е. определенной не с помощью Java кода и обычно возвращает адрес объекта в памяти:</p>\n<pre><code class=\"java language-java\">public native int hashCode();\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#для-чего-нужен-метод-hashcode","title":"<p>Для чего нужен метод <code>hashCode()</code>?</p>","answer":"<p>Метод <code>hashCode()</code> необходим для вычисления хэш кода переданного в качестве входного параметра объекта. В Java это целое число, в более широком смысле - битовая строка фиксированной длины, полученная из массива произвольной длины. Этот метод реализован таким образом, что для одного и того же входного объекта, хэш код всегда будет одинаковым. Следует понимать, что в Java множество возможных хэш кодов ограничено типом <code>int</code>, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть:</p>\n<ul>\n<li>если хэш коды разные, то и объекты гарантированно разные;</li>\n<li>если хэш коды равны, то объекты могут не обязательно равны.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#каковы-правила-переопределения-метода-objecthashcode","title":"<p>Каковы правила переопределения метода <code>Object.hashCode()</code>?</p>","answer":""},{"subject":"Java Core","url":"004-core.html#есть-ли-какие-либо-рекомендации-о-том-какие-поля-следует-использовать-при-подсчете-hashcode","title":"<p>Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете <code>hashCode()</code>?</p>","answer":"<p>Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как <code>id</code>, <code>uuid</code>. При этом нужно следовать правилу, если поля задействованы при вычислении <code>hashCode()</code>, то они должны быть задействованы и при выполнении <code>equals()</code>.</p>"},{"subject":"Java Core","url":"004-core.html#могут-ли-у-разных-объектов-быть-одинаковые-hashcode","title":"<p>Могут ли у разных объектов быть одинаковые <code>hashCode()</code>?</p>","answer":"<p>Да, могут. Метод <code>hashCode()</code> не гарантирует уникальность возвращаемого значения. Ситуация, когда у разных объектов одинаковые хэш коды называется <em>коллизией</em>. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хэш кода.</p>"},{"subject":"Java Core","url":"004-core.html#если-у-класса-pointint-x-y-реализовать-метод-equalsobject-that-return-thisx-thatx-thisy-thaty-но-сделать-хэш-код-в-виде-int-hashcode-return-x-то-будут-ли-корректно-такие-точки-помещаться-и-извлекаться-из-hashset","title":"<p>Если у класса <code>Point{int x, y;}</code> реализовать метод <code>equals(Object that) {(return this.x == that.x &amp;&amp; this.y == that.y)}</code>, но сделать хэш код в виде <code>int hashCode() {return x;}</code>, то будут ли корректно такие точки помещаться и извлекаться из <code>HashSet</code>?</p>","answer":"<p><code>HashSet</code> использует <code>HashMap</code> для хранения элементов. При добавлении элемента в <code>HashMap</code> вычисляется хэш код, по которому определяется позиция в массиве, куда будет вставлен новый элемент. У всех экземпляров класса <code>Point</code> хэш код будет одинаковым для всех объектов с одинаковым <code>x</code>, что приведёт к вырождению хэш таблицы в список.</p>\n<p>При возникновении коллизии в <code>HashMap</code> осуществляется проверка на наличие элемента в списке: <code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code>. Если элемент найден, то его значение перезаписывается. В нашем случае для разных объектов метод <code>equals()</code> будет возвращать <code>false</code>. Соответственно новый элемент будет успешно добавлен в <code>HashSet</code>. Извлечение элемента также будет осуществляться успешно. Но производительность такого кода будет невысокой и преимущества хэш таблиц использоваться не будут.</p>"},{"subject":"Java Core","url":"004-core.html#могут-ли-у-разных-объектов-ref0-!-ref1-быть-ref0equalsref1-true","title":"<p>Могут ли у разных объектов <code>(ref0 != ref1)</code> быть <code>ref0.equals(ref1) == true</code>?</p>","answer":"<p>Да, могут. Для этого в классе этих объектов должен быть переопределен метод <code>equals()</code>.</p>\n<p>Если используется метод <code>Object.equals()</code>, то для двух ссылок <code>x</code> и <code>y</code> метод вернет <code>true</code> тогда и только тогда, когда обе ссылки указывают на один и тот же объект (т.е. <code>x == y</code> возвращает <code>true</code>).</p>"},{"subject":"Java Core","url":"004-core.html#могут-ли-у-разных-ссылок-на-один-объект-ref0-ref1-быть-ref0equalsref1-false","title":"<p>Могут ли у разных ссылок на один объект <code>(ref0 == ref1)</code> быть <code>ref0.equals(ref1) == false</code>?</p>","answer":"<p>В общем случае - могут, если метод <code>equals()</code> реализован некорректно и не выполняет свойство рефлексивности: для любых ненулевых ссылок <code>x</code> метод <code>x.equals(x)</code> должен возвращать <code>true</code>.</p>"},{"subject":"Java Core","url":"004-core.html#можно-ли-так-реализовать-метод-equalsobject-that-return-thishashcode-thathashcode","title":"<p>Можно ли так реализовать метод <code>equals(Object that) {return this.hashCode() == that.hashCode()}</code>?</p>","answer":"<p>Строго говоря нельзя, поскольку метод <code>hashCode()</code> не гарантирует уникальность значения для каждого объекта. Однако для сравнения экземпляров класса <code>Object</code> такой код допустим, т.к. метод <code>hashCode()</code> в классе <code>Object</code> возвращает уникальные значения для разных объектов (его вычисление основано на использовании адреса объекта в памяти).</p>"},{"subject":"Java Core","url":"004-core.html#в-equals-требуется-проверять-что-аргумент-equalsobject-that-такого-же-типа-что-и-сам-объект-в-чем-разница-между-thisgetclass-thatgetclass-и-that-instanceof-myclass","title":"<p>В <code>equals()</code> требуется проверять, что аргумент <code>equals(Object that)</code> такого же типа что и сам объект. В чем разница между <code>this.getClass() == that.getClass()</code> и <code>that instanceof MyClass</code>?</p>","answer":"<p>Оператор <code>instanceof</code> сравнивает объект и указанный тип. Его можно использовать для проверки является ли данный объект экземпляром некоторого класса, либо экземпляром его дочернего класса, либо экземпляром класса, который реализует указанный интерфейс.</p>\n<p><code>this.getClass() == that.getClass()</code> проверяет два класса на идентичность, поэтому для корректной реализации контракта метода <code>equals()</code> необходимо использовать точное сравнение с помощью метода <code>getClass()</code>.</p>"},{"subject":"Java Core","url":"004-core.html#можно-ли-реализовать-метод-equals-класса-myclass-вот-так-class-myclass-public-boolean-equalsmyclass-that-return-this-that","title":"<p>Можно ли реализовать метод <code>equals()</code> класса <code>MyClass</code> вот так: <code>class MyClass {public boolean equals(MyClass that) {return this == that;}}</code>?</p>","answer":"<p>Реализовать можно, но данный метод не переопределяет метод <code>equals()</code> класса <code>Object</code>, а перегружает его.</p>"},{"subject":"Java Core","url":"004-core.html#есть-класс-pointint-x-y-почему-хэш-код-в-виде-31-x-y-предпочтительнее-чем-x-y","title":"<p>Есть класс <code>Point{int x, y;}</code>. Почему хэш код в виде <code>31 * x + y</code> предпочтительнее чем <code>x + y</code>?</p>","answer":"<p>Множитель создает зависимость значения хэш кода от очередности обработки полей, что в итоге порождает лучшую хэш\nфункцию.</p>"},{"subject":"Java Core","url":"004-core.html#расскажите-про-клонирование-объектов","title":"<p>Расскажите про клонирование объектов</p>","answer":"<p>Использование оператора присваивания не создает нового объекта, а лишь копирует ссылку на объект. Таким образом, две\nссылки указывают на одну и ту же область памяти, на один и тот же объект. Для создания нового объекта с таким же\nсостоянием используется клонирование объекта.</p>\n<p>Класс <code>Object</code> содержит <code>protected</code> метод <code>clone()</code>, осуществляющий побитовое копирование объекта производного класса.\nОднако сначала необходимо переопределить метод <code>clone()</code> как <code>public</code> для обеспечения возможности его вызова. В\nпереопределенном методе следует вызвать базовую версию метода <code>super.clone()</code>, которая и выполняет собственно\nклонирование.</p>\n<p>Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс <code>Cloneable</code>. Интерфейс <code>Cloneable</code> не\nсодержит методов относится к маркерным интерфейсам, а его реализация гарантирует, что метод <code>clone()</code> класса <code>Object</code>\nвозвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод\nгенерирует исключение <code>CloneNotSupportedException</code>. Следует отметить, что при использовании этого механизма объект\nсоздается без вызова конструктора.</p>\n<p>Это решение эффективно только в случае, если поля клонируемого объекта представляют собой значения базовых типов и их\nобёрток или неизменяемых (immutable) объектных типов. Если же поле клонируемого типа является изменяемым ссылочным\nтипом, то для корректного клонирования требуется другой подход. Причина заключается в том, что при создании копии поля\nоригинал и копия представляют собой ссылку на один и тот же объект. В этой ситуации следует также клонировать и сам\nобъект поля класса.</p>\n<p>Такое клонирование возможно только в случае, если тип атрибута класса также реализует интерфейс <code>Cloneable</code> и\nпереопределяет метод <code>clone()</code>. Так как, если это будет иначе вызов метода невозможен из-за его недоступности. Отсюда\nследует, что если класс имеет суперкласс, то для реализации механизма клонирования текущего класса-потомка необходимо\nналичие корректной реализации такого механизма в суперклассе. При этом следует отказаться от использования\nобъявлений <code>final</code> для полей объектных типов по причине невозможности изменения их значений при реализации клонирования.</p>\n<p>Помимо встроенного механизма клонирования в Java для клонирования объекта можно использовать:</p>\n<ul>\n<li><strong>Специализированный конструктор копирования</strong> - в классе описывается конструктор, который принимает объект этого же класса и инициализирует поля создаваемого объекта значениями полей переданного.</li>\n<li><strong>Фабричный метод</strong> - (Factory method), который представляет собой статический метод, возвращающий экземпляр своего класса.</li>\n<li><strong>Механизм сериализации</strong> - сохранение и последующее восстановление объекта в/из потока байтов.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#в-чем-отличие-между-поверхностным-и-глубоким-клонированием","title":"<p>В чем отличие между <em>поверхностным</em> и <em>глубоким</em> клонированием?</p>","answer":"<p><strong>Поверхностное копирование</strong> копирует настолько малую часть информации об объекте, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. класс <code>Object</code> не знает о структуре класса, которого он копирует. Клонирование такого типа осуществляется JVM по следующим правилам:</p>\n<ul>\n<li>Если класс имеет только члены примитивных типов, то будет создана совершенно новая копия объекта и возвращена ссылка на этот объект.</li>\n<li>Если класс помимо членов примитивных типов содержит члены ссылочных типов, то тогда копируются ссылки на объекты этих классов. Следовательно, оба объекта будут иметь одинаковые ссылки.</li>\n</ul>\n<p><strong>Глубокое копирование</strong> дублирует абсолютно всю информацию объекта:</p>\n<ul>\n<li>Нет необходимости копировать отдельно примитивные данные;</li>\n<li>Все члены ссылочного типа в оригинальном классе должны поддерживать клонирование. Для каждого такого члена при переопределении метода <code>clone()</code> должен вызываться <code>super.clone()</code>;</li>\n<li>Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#какой-способ-клонирования-предпочтительней","title":"<p>Какой способ клонирования предпочтительней?</p>","answer":"<p>Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:</p>\n<ul>\n<li>Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод <code>clone()</code>);</li>\n<li>Поля для клонирования указываются явно;</li>\n<li>Возможность клонировать даже <code>final</code> поля.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#почему-метод-clone-объявлен-в-классе-object-а-не-в-интерфейсе-cloneable","title":"<p>Почему метод <code>clone()</code> объявлен в классе <code>Object</code>, а не в интерфейсе <code>Cloneable</code>?</p>","answer":"<p>Метод <code>clone()</code> объявлен в классе <code>Object</code> с указанием модификатора <code>native</code>, чтобы обеспечить доступ к стандартному\nмеханизму поверхностного копирования объектов. Одновременно он объявлен и как <code>protected</code>, чтобы нельзя было вызвать\nэтот метод у не переопределивших его объектов. Непосредственно интерфейс <code>Cloneable</code> является маркерным (не содержит\nобъявлений методов) и нужен только для обозначения самого факта, что данный объект готов к тому, чтобы быть\nклонированным. Вызов переопределённого метода <code>clone()</code> у не <code>Cloneable</code> объекта вызовет\nвыбрасывание <code>CloneNotSupportedException</code>.</p>"},{"subject":"Java Core","url":"004-core.html#опишите-иерархию-исключений","title":"<p>Опишите иерархию исключений</p>","answer":"<p>Исключения делятся на несколько классов, но все они имеют общего предка — класс <code>Throwable</code>, потомками которого являются\nклассы <code>Exception</code> и <code>Error</code>.</p>\n<p><strong>Ошибки (Errors)</strong> представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует\nобрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода\nвозникают, если закончилась память доступная виртуальной машине.</p>\n<p><strong>Исключения (Exceptions)</strong> являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и\nпоследствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.</p>"},{"subject":"Java Core","url":"004-core.html#какие-виды-исключений-в-java-вы-знаете-чем-они-отличаются","title":"<p>Какие виды исключений в Java вы знаете, чем они отличаются?</p>","answer":""},{"subject":"Java Core","url":"004-core.html#что-такое-checked-и-unchecked-exception","title":"<p>Что такое <em>checked</em> и <em>unchecked exception</em>?</p>","answer":"<p>В Java все исключения делятся на два типа:</p>\n<ul>\n<li><strong>checked (контролируемые/проверяемые исключения)</strong> должны обрабатываться блоком <code>catch</code> или описываться в сигнатуре метода (например <code>throws IOException</code>). Наличие такого обработчика/модификатора сигнатуры проверяются на этапе компиляции;</li>\n<li><strong>unchecked (неконтролируемые/непроверяемые исключения)</strong>, к которым относятся ошибки <code>Error</code> (например <code>OutOfMemoryError</code>), обрабатывать которые не рекомендуется и исключения времени выполнения, представленные классом <code>RuntimeException</code> и его наследниками (например <code>NullPointerException</code>), которые могут не обрабатываться блоком <code>catch</code> и не быть описанными в сигнатуре метода.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#какой-оператор-позволяет-принудительно-выбросить-исключение","title":"<p>Какой оператор позволяет принудительно выбросить исключение?</p>","answer":"<p>Это оператор <code>throw</code>:</p>\n<pre><code class=\"java language-java\">throw new Exception();\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#о-чем-говорит-ключевое-слово-throws","title":"<p>О чем говорит ключевое слово <code>throws</code>?</p>","answer":"<p>Модификатор <code>throws</code> прописывается в сигнатуре метода и указывает на то, что метод потенциально может выбросить исключение с указанным типом.</p>"},{"subject":"Java Core","url":"004-core.html#как-написать-собственное-пользовательское-исключение","title":"<p>Как написать собственное («пользовательское») исключение?</p>","answer":"<p>Необходимо унаследоваться от базового класса требуемого типа исключений (например от <code>Exception</code> или <code>RuntimeException</code>).</p>\n<pre><code class=\"java language-java\">class CustomException extends Exception {\n    public CustomException() {\n        super();\n    }\n\n    public CustomException(final String string) {\n        super(string + \" is invalid\");\n    }\n\n    public CustomException(final Throwable cause) {\n        super(cause);\n    }\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#какие-существуют-unchecked-exception","title":"<p>Какие существуют <em>unchecked exception</em>?</p>","answer":"<p>Наиболее часто встречающиеся: <code>ArithmeticException</code>, <code>ClassCastException</code>, <code>ConcurrentModificationException</code>, <code>IllegalArgumentException</code>, <code>IllegalStateException</code>, <code>IndexOutOfBoundsException</code>, <code>NoSuchElementException</code>, <code>NullPointerException</code>, <code>UnsupportedOperationException</code>.</p>"},{"subject":"Java Core","url":"004-core.html#что-представляет-из-себя-ошибки-класса-error","title":"<p>Что представляет из себя ошибки класса <code>Error</code>?</p>","answer":"<p>Ошибки класса <code>Error</code> представляют собой наиболее серьёзные проблемы уровня JVM. Например, исключения такого рода возникают, если закончилась память доступная виртуальной машине. Обрабатывать такие ошибки не запрещается, но делать этого не рекомендуется.</p>"},{"subject":"Java Core","url":"004-core.html#что-вы-знаете-о-outofmemoryerror","title":"<p>Что вы знаете о <code>OutOfMemoryError</code>?</p>","answer":"<p><code>OutOfMemoryError</code> выбрасывается, когда виртуальная машина Java не может создать (разместить) объект из-за нехватки памяти, а сборщик мусора не может высвободить достаточное её количество.</p>\n<p>Область памяти, занимаемая java процессом, состоит из нескольких частей. Тип <code>OutOfMemoryError</code> зависит от того, в какой\nиз них не хватило места:</p>\n<ul>\n<li><code>java.lang.OutOfMemoryError: Java heap space</code>: Не хватает места в куче, а именно, в области памяти в которую\nпомещаются объекты, создаваемые в приложении программно. Обычно проблема кроется в утечке памяти. Размер задается\nпараметрами <code>-Xms</code> и <code>-Xmx</code>.</li>\n<li><code>java.lang.OutOfMemoryError: PermGen space</code>: (до версии Java 8) Данная ошибка возникает при нехватке места в\n<em>Permanent</em> области, размер которой задается параметрами <code>-XX:PermSize</code> и <code>-XX:MaxPermSize</code>.</li>\n<li><code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>: Данная ошибка может возникнуть как при переполнении первой,\nтак и второй областей. Связана она с тем, что памяти осталось мало и сборщик мусора постоянно работает, пытаясь\nвысвободить немного места. Данную ошибку можно отключить с помощью параметра <code>-XX:-UseGCOverheadLimit</code>.</li>\n<li><code>java.lang.OutOfMemoryError: unable to create new native thread</code>: Выбрасывается, когда нет возможности создавать новые\nпотоки.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#опишите-работу-блока-try-catch-finally","title":"<p>Опишите работу блока <em>try-catch-finally</em></p>","answer":"<p><code>try</code> — данное ключевое слово используется для отметки начала блока кода, который потенциально может привести к ошибке.\n<code>catch</code> — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений в случае\nих возникновения.\n<code>finally</code> — ключевое слово для отметки начала блока кода, который является дополнительным. Этот блок помещается после\nпоследнего блока <code>catch</code>. Управление передаётся в блок <code>finally</code> в любом случае, было выброшено исключение или нет.</p>\n<p>Общий вид конструкции для обработки исключительной ситуации выглядит следующим образом:</p>\n<pre><code class=\"java language-java\">try{\n        //код, который потенциально может привести к исключительной ситуации\n}\ncatch(SomeException e ) { //в скобках указывается класс конкретной ожидаемой ошибки\n    //код обработки исключительной ситуации\n}\nfinally {\n    //необязательный блок, код которого выполняется в любом случае\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#что-такое-механизм-try-with-resources","title":"<p>Что такое механизм <em>try-with-resources</em>?</p>","answer":"<p>Данная конструкция, которая появилась в Java 7, позволяет использовать блок <em>try-catch</em> не заботясь о закрытии ресурсов, используемых в данном сегменте кода.\nРесурсы объявляются в скобках сразу после <code>try</code>, а компилятор уже сам неявно создаёт секцию <code>finally</code>, в которой и происходит освобождение занятых в блоке ресурсов. Под ресурсами подразумеваются сущности, реализующие интерфейс <code>java.lang.Autocloseable</code>.</p>\n<p>Общий вид конструкции:</p>\n<pre><code class=\"java language-java\">try(/*объявление ресурсов*/) {\n    //...\n} catch(Exception ex) {\n    //...\n} finally {\n    //...\n}\n</code></pre>\n<p>Стоит заметить, что блоки <code>catch</code> и явный <code>finally</code> выполняются уже после того, как закрываются ресурсы в неявном <code>finally</code>.</p>"},{"subject":"Java Core","url":"004-core.html#возможно-ли-использование-блока-try-finally-без-catch","title":"<p>Возможно ли использование блока <em>try-finally</em> (без <code>catch</code>)?</p>","answer":"<p>Такая запись допустима, но смысла в такой записи не так много, всё же лучше иметь блок <code>catch</code>, в котором будет обрабатываться необходимое исключение.</p>"},{"subject":"Java Core","url":"004-core.html#может-ли-один-блок-catch-отлавливать-сразу-несколько-исключений","title":"<p>Может ли один блок <code>catch</code> отлавливать сразу несколько исключений?</p>","answer":"<p>В Java 7 стала доступна новая языковая конструкция, с помощью которой можно перехватывать несколько исключений одним блоком <code>catch</code>:</p>\n<pre><code class=\"java language-java\">try {\n    //...\n} catch(IOException | SQLException ex) {\n    //...\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#всегда-ли-исполняется-блок-finally","title":"<p>Всегда ли исполняется блок <code>finally</code>?</p>","answer":"<p>Код в блоке <code>finally</code> будет выполнен всегда, независимо от того, выброшено исключение или нет.</p>"},{"subject":"Java Core","url":"004-core.html#существуют-ли-ситуации-когда-блок-finally-не-будет-выполнен","title":"<p>Существуют ли ситуации, когда блок <code>finally</code> не будет выполнен?</p>","answer":"<p>Например, когда JVM «умирает» - в такой ситуации <code>finally</code> недостижим и не будет выполнен, так как происходит принудительный системный выход из программы:</p>\n<pre><code class=\"java language-java\">try {\n    System.exit(0);\n} catch(Exception e) {\n    e.printStackTrace();\n} finally { }\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#может-ли-метод-main-выбросить-исключение-во-вне-и-если-да-то-где-будет-происходить-обработка-данного-исключения","title":"<p>Может ли метод <em>main()</em> выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?</p>","answer":"<p>Может и оно будет передано в виртуальную машину Java (JVM).</p>"},{"subject":"Java Core","url":"004-core.html#предположим-есть-метод-который-может-выбросить-ioexception-и-filenotfoundexception-в-какой-последовательности-должны-идти-блоки-catch-сколько-блоков-catch-будет-выполнено","title":"<p>Предположим, есть метод, который может выбросить <code>IOException</code> и <code>FileNotFoundException</code> в какой последовательности должны идти блоки <code>catch</code>? Сколько блоков <code>catch</code> будет выполнено?</p>","answer":"<p>Общее правило: обрабатывать исключения нужно от «младшего» к старшему. Т.е. нельзя поставить в первый блок <code>catch(Exception ex) {}</code>, иначе все дальнейшие блоки <code>catch()</code> уже ничего не смогут обработать, т.к. любое исключение будет соответствовать обработчику <code>catch(Exception ex)</code>.</p>\n<p>Таким образом, исходя из факта, что <code>FileNotFoundException extends IOException</code> сначала нужно обработать <code>FileNotFoundException</code>, а затем уже <code>IOException</code>:</p>\n<pre><code class=\"java language-java\">void method() {\n    try {\n        //...\n    } catch (FileNotFoundException ex) {\n        //...\n    } catch (IOException ex) {\n        //...\n    }\n}\n</code></pre>"},{"subject":"Java Core","url":"004-core.html#что-такое-generics","title":"<p>Что такое <em>generics</em>?</p>","answer":"<p><strong>Generics</strong> - это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы. Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.</p>\n<p>Примером использования обобщенных типов может служить <em>Java Collection Framework</em>. Так, класс <code>LinkedList&lt;E&gt;</code> - типичный обобщенный тип. Он содержит параметр <code>E</code>, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать <code>LinkedList</code>, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа <code>LinkedList&lt;String&gt;</code>, <code>LinkedList&lt;Integer&gt;</code> и т.п.</p>"},{"subject":"Java Core","url":"004-core.html#опишите-разницу-между-extends-и-super-при-объявлении-generics","title":"<p>Опишите разницу между <code>? extends ...</code> и <code>? super ...</code> при объявлении generics</p>","answer":"<p>Запись вида \"? extends …\" или \"? super …\" — называется wildcard или символом подстановки, с верхней границей (extends) или с нижней границей (super).</p>\n<ul>\n<li><code>List&lt;? extends Number&gt;</code> может содержать объекты, класс которых является Number или наследуется от Number.</li>\n<li><code>List&lt;? super Number&gt;</code> может содержать объекты, класс которых Number, или  у которых Number является наследником (супертип от Number).</li>\n</ul>\n<p>Например, следующий метод класса <code>Collections</code>:</p>\n<pre><code class=\"java language-java\">public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) {\n ...\n}\n</code></pre>\n<p>Его аргументом является любая коллекция объектов типа <code>Object</code> или его наследников, а также реализующего интерфейс <code>Comparable</code> для самого этого типа или его предков.</p>\n<h6 id=\"thegetandputprinciplepecsproducerextendsconsumersuper\">The Get and Put Principle или PECS (Producer Extends Consumer Super)</h6>\n<p>Особенность wildcard с верхней и нижней границей дает дополнительные возможности, связанные с безопасным использованием типов. Из одного типа переменных можно только читать, в другой — только вписывать (исключением является возможность записать null для extends и прочитать Object для super). Чтобы было легче запомнить, когда какой wildcard использовать, существует принцип PECS — Producer Extends Consumer Super.</p>\n<ul>\n<li>Если мы объявили wildcard с extends, то это producer. Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает.</li>\n<li>Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.</li>\n</ul>"},{"subject":"Java Core","url":"004-core.html#чем-отличаются-javalangcomparable-и-javautilcomparator","title":"<p>Чем отличаются <code>java.lang.Comparable</code> и <code>java.util.Comparator</code>?</p>","answer":"<p><code>java.lang.Comparable</code> - интерфейс, добавляющий объекту метод <code>public int compareTo(T o)</code>. Должен возвращать отрицательное число, ноль, или положительное число, если объект меньше, равен или больше того объекта, который передан аргументом.</p>\n<p><code>java.util.Comparator</code> - интерфейс нужен для реализации внешнего \"сравнения\". Если разработчик не реализовал в своем классе, который мы хотим использовать, интерфейс <code>java.lang.Comparable</code>, либо реализовал, но нас не устраивает его функциональность, и мы хотим ее переопределить? На этот случай есть еще более гибкий способ, предполагающий применение интерфейса <code>java.util.Comparator</code>.  Интерфейс Comparator содержит ряд методов, ключевым из которых является метод  <code>int compare(T a, T b)</code>, который должен быть реализован так же, как <code>Comparator.compareTo</code>.</p>\n<p><a href=\"#java-core\">к оглавлению</a></p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-такое-коллекция","title":"<p>Что такое <em>«коллекция»</em>?</p>","answer":"<p><em>«Коллекция»</em> - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#назовите-основные-интерфейсы-jcf-и-их-реализации","title":"<p>Назовите основные интерфейсы JCF и их реализации</p>","answer":"<p>На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: <code>Collection</code> и <code>Map</code>. Эти интерфейсы разделяют все коллекции, входящие во\nфреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.</p>\n<p>Интерфейс <code>Collection</code> расширяют интерфейсы:</p>\n<ul>\n<li><code>List</code> (список) представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции\nпронумерованы, начиная от нуля, к ним можно обратиться по индексу. Реализации:<ul>\n<li><code>ArrayList</code> - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых\nэлементов.</li>\n<li><code>LinkedList</code> (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно\nданные, так и две ссылки на следующий и предыдущий узел.</li>\n<li><code>Vector</code> — реализация динамического массива объектов, методы которой синхронизированы.</li>\n<li><code>Stack</code> — реализация стека LIFO (last-in-first-out).</li></ul></li>\n<li><code>Set</code> (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:<ul>\n<li><code>HashSet</code> - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент.\nИз-за особенностей реализации порядок элементов не гарантируется при добавлении.</li>\n<li><code>LinkedHashSet</code> — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления\nэлементов.</li>\n<li><code>TreeSet</code> — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта <code>Comparator</code>,\nлибо сохраняет элементы с использованием «natural ordering».</li></ul></li>\n<li><code>Queue</code> (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (\nfirst-in-first-out):<ul>\n<li><code>PriorityQueue</code> — предоставляет возможность управлять порядком элементов в коллекции при помощи\nобъекта <code>Comparator</code>, либо сохраняет элементы с использованием «natural ordering».</li>\n<li><code>ArrayDeque</code> — реализация интерфейса <code>Deque</code>, который расширяет интерфейс <code>Queue</code> методами, позволяющими\nреализовать конструкцию вида LIFO (last-in-first-out).</li></ul></li>\n</ul>\n<p>Интерфейс <code>Map</code> реализован классами:</p>\n<ul>\n<li><code>Hashtable</code> — хэш-таблица, методы которой синхронизированы. Не позволяет использовать <code>null</code> в качестве значения или ключа и не является упорядоченной.</li>\n<li><code>HashMap</code> — хэш-таблица. Позволяет использовать <code>null</code> в качестве значения или ключа и не является упорядоченной.</li>\n<li><code>LinkedHashMap</code> — упорядоченная реализация хэш-таблицы.</li>\n<li><code>TreeMap</code> — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта <code>Comparator</code>, либо сохраняет элементы с использованием «natural ordering».</li>\n<li><code>WeakHashMap</code> — реализация хэш-таблицы, которая организована с использованием <em>weak references</em> для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#расположите-в-виде-иерархии-следующие-интерфейсы-list-set-map-sortedset-sortedmap-collection-iterable-iterator-navigableset-navigablemap","title":"<p>Расположите в виде иерархии следующие интерфейсы: <code>List</code>, <code>Set</code>, <code>Map</code>, <code>SortedSet</code>, <code>SortedMap</code>, <code>Collection</code>, <code>Iterable</code>, <code>Iterator</code>, <code>NavigableSet</code>, <code>NavigableMap</code></p>","answer":"<ul>\n<li><code>Iterable</code><ul>\n<li><code>Collection</code><ul>\n<li><code>List</code></li>\n<li><code>Set</code><ul>\n<li><code>SortedSet</code><ul>\n<li><code>NavigableSet</code></li></ul></li></ul></li></ul></li></ul></li>\n<li><code>Map</code><ul>\n<li><code>SortedMap</code><ul>\n<li><code>NavigableMap</code></li></ul></li></ul></li>\n<li><code>Iterator</code></li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#почему-map-—-это-не-collection-в-то-время-как-list-и-set-являются-collection","title":"<p>Почему <code>Map</code> — это не <code>Collection</code>, в то время как <code>List</code> и <code>Set</code> являются <code>Collection</code>?</p>","answer":"<p><code>Collection</code> представляет собой совокупность некоторых элементов. <code>Map</code> - это совокупность пар «ключ-значение».</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-чем-разница-между-классами-javautilcollection-и-javautilcollections","title":"<p>В чем разница между классами <code>java.util.Collection</code> и <code>java.util.Collections</code>?</p>","answer":"<p><code>java.util.Collections</code> - набор статических методов для работы с коллекциями.</p>\n<p><code>java.util.Collection</code> - один из основных интерфейсов Java Collections Framework.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-такое-fail-fast-поведение","title":"<p>Что такое «fail-fast поведение»?</p>","answer":"<p><strong>fail-fast поведение</strong> означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом. Использование fail-fast подхода позволяет избежать недетерминированного поведения программы в течение времени.</p>\n<p>В Java Collections API некоторые итераторы ведут себя как fail-fast и выбрасывают <code>ConcurrentModificationException</code>, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора.</p>\n<p>Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции (modification count):</p>\n<ul>\n<li>при изменении коллекции счетчик модификаций так же изменяется;</li>\n<li>при создании итератора ему передается текущее значение счетчика;</li>\n<li>при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какая-разница-между-fail-fast-и-fail-safe","title":"<p>Какая разница между fail-fast и fail-safe?</p>","answer":"<p>В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что\nони работают с клоном коллекции вместо оригинала.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#приведите-примеры-итераторов-реализующих-поведение-fail-safe","title":"<p>Приведите примеры итераторов, реализующих поведение fail-safe</p>","answer":"<p>Итератор коллекции <code>CopyOnWriteArrayList</code> и итератор представления <code>keySet</code> коллекции <code>ConcurrentHashMap</code> являются\nпримерами итераторов fail-safe.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#чем-различаются-enumeration-и-iterator","title":"<p>Чем различаются <code>Enumeration</code> и <code>Iterator</code></p>","answer":"<p>Хотя оба интерфейса и предназначены для обхода коллекций между ними имеются существенные различия:</p>\n<ul>\n<li>с помощью <code>Enumeration</code> нельзя добавлять/удалять элементы;</li>\n<li>в <code>Iterator</code> исправлены имена методов для повышения читаемости кода (<code>Enumeration.hasMoreElements()</code>\nсоответствует <code>Iterator.hasNext()</code>, <code>Enumeration.nextElement()</code> соответствует <code>Iterator.next()</code> и т.д);</li>\n<li><code>Enumeration</code> присутствуют в устаревших классах, таких как <code>Vector</code>/<code>Stack</code>, тогда как <code>Iterator</code> есть во всех\nсовременных классах-коллекциях.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-между-собой-связаны-iterable-и-iterator","title":"<p>Как между собой связаны <code>Iterable</code> и <code>Iterator</code>?</p>","answer":"<p>Интерфейс <code>Iterable</code> имеет только один метод - <code>iterator()</code>, который возвращает <code>Iterator</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-между-собой-связаны-iterable-iterator-и-for-each","title":"<p>Как между собой связаны <code>Iterable</code>, <code>Iterator</code> и «for-each»?</p>","answer":"<p>Классы, реализующие интерфейс <code>Iterable</code>, могут применяться в конструкции <code>for-each</code>, которая использует <code>Iterator</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сравните-iterator-и-listiterator","title":"<p>Сравните <code>Iterator</code> и <code>ListIterator</code></p>","answer":"<ul>\n<li><code>ListIterator</code> расширяет интерфейс <code>Iterator</code></li>\n<li><code>ListIterator</code> может быть использован только для перебора элементов коллекции <code>List</code>;</li>\n<li><code>Iterator</code> позволяет перебирать элементы только в одном направлении, при помощи метода <code>next()</code>. Тогда\nкак <code>ListIterator</code> позволяет перебирать список в обоих направлениях, при помощи методов <code>next()</code> и <code>previous()</code>;</li>\n<li><code>ListIterator</code> не указывает на конкретный элемент: его текущая позиция располагается между элементами, которые\nвозвращают методы <code>previous()</code> и <code>next()</code>.</li>\n<li>При помощи <code>ListIterator</code> вы можете модифицировать список, добавляя/удаляя элементы с помощью методов <code>add()</code>\nи <code>remove()</code>. <code>Iterator</code> не поддерживает данного функционала.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-произойдет-при-вызове-iteratornext-без-предварительного-вызова-iteratorhasnext","title":"<p>Что произойдет при вызове <code>Iterator.next()</code> без предварительного вызова <code>Iterator.hasNext()</code>?</p>","answer":"<p>Если итератор указывает на последний элемент коллекции, то возникнет исключение <code>NoSuchElementException</code>, иначе будет возвращен следующий элемент.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сколько-элементов-будет-пропущено-если-iteratornext-будет-вызван-после-10-вызовов-iteratorhasnext","title":"<p>Сколько элементов будет пропущено, если <code>Iterator.next()</code> будет вызван после 10 вызовов <code>Iterator.hasNext()</code>?</p>","answer":"<p>Нисколько - <code>hasNext()</code> осуществляет только проверку наличия следующего элемента.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-поведёт-себя-коллекция-если-вызвать-iteratorremove","title":"<p>Как поведёт себя коллекция, если вызвать <code>iterator.remove()</code>?</p>","answer":"<p>Если вызову <code>iterator.remove()</code> предшествовал вызов <code>iterator.next()</code>, то <code>iterator.remove()</code> удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено <code>IllegalStateException()</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-поведёт-себя-уже-инстанциированный-итератор-для-collection-если-вызвать-collectionremove","title":"<p>Как поведёт себя уже инстанциированный итератор для <code>collection</code>, если вызвать <code>collection.remove()</code>?</p>","answer":"<p>При следующем вызове методов итератора будет выброшено <code>ConcurrentModificationException</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-избежать-concurrentmodificationexception-во-время-перебора-коллекции","title":"<p>Как избежать <code>ConcurrentModificationException</code> во время перебора коллекции?</p>","answer":"<ul>\n<li>Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для <code>List</code> можно использовать <code>ListIterator</code>.</li>\n<li>Использовать <code>ConcurrentHashMap</code> и <code>CopyOnWriteArrayList</code>.</li>\n<li>Преобразовать список в массив и перебирать массив.</li>\n<li>Блокировать изменения списка на время перебора с помощью блока <code>synchronized</code>.</li>\n</ul>\n<p>Отрицательная сторона последних двух вариантов - ухудшение производительности.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какая-коллекция-реализует-дисциплину-обслуживания-fifo","title":"<p>Какая коллекция реализует дисциплину обслуживания FIFO?</p>","answer":"<p>FIFO, First-In-First-Out («первым пришел-первым ушел») - по этому принципу построена коллекция <code>Queue</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какая-коллекция-реализует-дисциплину-обслуживания-filo","title":"<p>Какая коллекция реализует дисциплину обслуживания FILO?</p>","answer":"<p>FILO, First-In-Last-Out («первым пришел, последним ушел») - по этому принципу построена коллекция <code>Stack</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#чем-отличается-arraylist-от-vector","title":"<p>Чем отличается <code>ArrayList</code> от <code>Vector</code>?</p>","answer":""},{"subject":"Java Collections Framework","url":"005-jcf.html#зачем-добавили-arraylist-если-уже-был-vector","title":"<p>Зачем добавили <code>ArrayList</code>, если уже был <code>Vector</code>?</p>","answer":"<ul>\n<li>Методы класса <code>Vector</code> синхронизированы, а <code>ArrayList</code> - нет;</li>\n<li>По умолчанию, <code>Vector</code> удваивает свой размер, когда заканчивается выделенная под элементы память. <code>ArrayList</code> же увеличивает свой размер только на половину.</li>\n</ul>\n<p><code>Vector</code> это устаревший класс и его использование не рекомендовано.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#чем-отличается-arraylist-от-linkedlist-в-каких-случаях-лучше-использовать-первый-а-в-каких-второй","title":"<p>Чем отличается <code>ArrayList</code> от <code>LinkedList</code>? В каких случаях лучше использовать первый, а в каких второй?</p>","answer":"<p><code>ArrayList</code> это список, реализованный на основе массива, а <code>LinkedList</code> — это классический двусвязный список, основанный на объектах с ссылками между ними.</p>\n<p><code>ArrayList</code>:</p>\n<ul>\n<li>доступ к произвольному элементу по индексу за <em>константное</em> время <em>O(1)</em>;</li>\n<li>доступ к элементам по значению за <em>линейное</em> время <em>O(N)</em>;</li>\n<li>вставка в конец в среднем производится за <em>константное</em> время <em>O(1)</em>;</li>\n<li>удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);</li>\n<li>вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;</li>\n<li>минимум накладных расходов при хранении.</li>\n</ul>\n<p><code>LinkedList</code>:</p>\n<ul>\n<li>на получение элемента по индексу или значению потребуется <em>линейное</em> время <em>O(N)</em>;</li>\n<li>на добавление и удаление в начало или конец списка потребуется <em>константное</em> <em>O(1)</em>;</li>\n<li>вставка или удаление в/из произвольного место <em>константное</em> <em>O(1)</em>;</li>\n<li>требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.</li>\n</ul>\n<p>В целом, <code>LinkedList</code> в абсолютных величинах проигрывает <code>ArrayList</code> и по потребляемой памяти, и по скорости выполнения операций. <code>LinkedList</code> предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-работает-быстрее-arraylist-или-linkedlist","title":"<p>Что работает быстрее <code>ArrayList</code> или <code>LinkedList</code>?</p>","answer":"<p>Смотря какие действия будут выполняться над структурой.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-linkedlist","title":"<p>Какое худшее время работы метода <code>contains()</code> для элемента, который есть в <code>LinkedList</code>?</p>","answer":"<p><em>O(N)</em>. Время поиска элемента линейно пропорционально количеству элементов в списке.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-contains-для-элемента-который-есть-в-arraylist","title":"<p>Какое худшее время работы метода <code>contains()</code> для элемента, который есть в <code>ArrayList</code>?</p>","answer":"<p><em>O(N)</em>. Время поиска элемента линейно пропорционально количеству элементов в списке.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-add-для-linkedlist","title":"<p>Какое худшее время работы метода <code>add()</code> для <code>LinkedList</code>?</p>","answer":"<p><em>O(N)</em>. Добавление в начало/конец списка осуществляется за время <em>O(1)</em>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-add-для-arraylist","title":"<p>Какое худшее время работы метода <code>add()</code> для <code>ArrayList</code>?</p>","answer":"<p><em>O(N)</em>. Вставка элемента в конец списка осуществляется за время <em>O(1)</em>, но если вместимость массива недостаточна, то происходит создание нового массива с увеличенным размером и копирование всех элементов из старого массива в новый.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#необходимо-добавить-1-млн-элементов-какую-структуру-вы-используете","title":"<p>Необходимо добавить 1 млн. элементов, какую структуру вы используете?</p>","answer":"<p>Однозначный ответ можно дать только исходя из информации о том в какую часть списка происходит добавление элементов, что\nпотом будет происходить с элементами списка, существуют ли какие-то ограничения по памяти или скорости выполнения.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-происходит-удаление-элементов-из-arraylist-как-меняется-в-этом-случае-размер-arraylist","title":"<p>Как происходит удаление элементов из <code>ArrayList</code>? Как меняется в этом случае размер <code>ArrayList</code>?</p>","answer":"<p>При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и\nреальный размер массива (его емкость, capacity) не изменяется никак. Механизм автоматического «расширения» массива\nсуществует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой <code>trimToSize()</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#предложите-эффективный-алгоритм-удаления-нескольких-рядом-стоящих-элементов-из-середины-списка-реализуемого-arraylist","title":"<p>Предложите эффективный алгоритм удаления нескольких рядом стоящих элементов из середины списка, реализуемого <code>ArrayList</code></p>","answer":"<p>Допустим нужно удалить <code>n</code> элементов с позиции <code>m</code> в списке. Вместо выполнения удаления одного элемента <code>n</code> раз (каждый\nраз смещая на 1 позицию элементы, стоящие «правее» в списке), нужно выполнить смещение всех элементов, стоящих\n«правее» <code>n + m</code> позиции на <code>n</code> элементов «левее» к началу списка. Таким образом, вместо выполнения <code>n</code> итераций\nперемещения элементов списка, все выполняется за 1 проход. Но если говорить об общей эффективности - то самый быстрый\nспособ будет с использованием <code>System.arraycopy()</code>, и получить к нему доступ можно через\nметод - <code>subList(int fromIndex, int toIndex)</code>.</p>\n<p>Пример:</p>\n<pre><code class=\"java language-java\">import java.io.*;\nimport java.util.ArrayList;\n\npublic class Main {\n    //позиция с которой удаляем\n    private static int m = 0;\n    //количество удаляемых элементов\n    private static int n = 0;\n    //количество элементов в списке\n    private static final int size = 1000000;\n    //основной список (для удаления вызовом remove() и его копия для удаления путём перезаписи)\n    private static ArrayList&lt;Integer&gt; initList, copyList;\n\n    public static void main(String[] args){\n\n        initList = new ArrayList&lt;&gt;(size);\n        for (int i = 0; i &lt; size; i++) {\n            initList.add(i);\n        }\n        System.out.println(\"Список из 1.000.000 элементов заполнен\");\n\n        copyList = new ArrayList&lt;&gt;(initList);\n        System.out.println(\"Создана копия списка\\n\");\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            System.out.print(\"С какой позиции удаляем? &gt; \");\n            m = Integer.parseInt(br.readLine());\n            System.out.print(\"Сколько удаляем? &gt; \");\n            n = Integer.parseInt(br.readLine());\n        } catch(IOException e){\n            System.err.println(e.toString());\n        }\n        System.out.println(\"Выполняем удаление вызовом remove()...\");\n        long start = System.currentTimeMillis();\n\n        for (int i = m - 1; i &lt; m + n - 1; i++) {\n            initList.remove(i);\n        }\n\n        long finish = System.currentTimeMillis() - start;\n        System.out.println(\"Время удаления с помощью вызова remove(): \" + finish);\n        System.out.println(\"Размер исходного списка после удаления: \" + initList.size());\n\n        System.out.println(\"\\nВыполняем удаление путем перезаписи...\\n\");\n        start = System.currentTimeMillis();\n\n        removeEfficiently();\n\n        finish = System.currentTimeMillis() - start;\n        System.out.println(\"Время удаления путём смещения: \" + finish);\n        System.out.println(\"Размер копии списка:\" + copyList.size());\n\n        System.out.println(\"\\nВыполняем удаление через SubList...\\n\");\n        start = System.currentTimeMillis();\n        initList.subList(m - 1, m + n).clear();\n        finish = System.currentTimeMillis() - start;\n        System.out.println(\"Время удаления через саблист: \" + finish);\n        System.out.println(\"Размер копии списка:\" + copyList.size());\n    }\n\n    private static void removeEfficiently(){\n        /* если необходимо удалить все элементы, начиная с указанного,\n         * то удаляем элементы с конца до m\n         */\n        if (m + n &gt;= size){\n            int i = size - 1;\n            while (i != m - 1){\n                copyList.remove(i);\n                i--;\n            }\n        } else{\n            //переменная k необходима для отсчёта сдвига начиная от места вставка m\n            for (int i  = m + n, k = 0; i &lt; size; i++, k++) {\n               copyList.set(m + k, copyList.get(i));\n            }\n\n            /* удаляем ненужные элементы в конце списка\n             * удаляется всегда последний элемент, так как время этого действия\n             * фиксировано и не зависит от размера списка\n             */\n            int i = size - 1;\n            while (i != size - n - 1){\n                copyList.remove(i);\n                i--;\n            }\n            //сокращаем длину списка путём удаления пустых ячеек\n            copyList.trimToSize();\n        }\n    }\n}\n</code></pre>\n<p>Результат выполнения:</p>\n<pre><code>run:\nСписок из 1.000.000 элементов заполнен\nСоздана копия списка\n\nС какой позиции удаляем? &gt; 600000\nСколько удаляем? &gt; 20000\n\nВыполняем удаление вызовом remove()...\nВремя удаления с помощью вызова remove(): 928\nРазмер исходного списка после удаления: 980000\n\nВыполняем удаление путем перезаписи...\n\nВремя удаления путём смещения: 17\n\nРазмер копии списка:980000\nВыполняем удаление через SubList...\n\nВремя удаления через саблист: 1\nРазмер копии списка:980000\nСБОРКА УСПЕШНО ЗАВЕРШЕНА (общее время: 33 секунды)\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сколько-необходимо-дополнительной-памяти-при-вызове-arraylistadd","title":"<p>Сколько необходимо дополнительной памяти при вызове <code>ArrayList.add()</code>?</p>","answer":"<p>Если в массиве достаточно места для размещения нового элемента, то дополнительной памяти не требуется. Иначе происходит создание нового массива размером в 1,5 раза превышающим существующий (это верно для JDK выше 1.7, в более ранних версиях размер увеличения иной).</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сколько-выделяется-дополнительно-памяти-при-вызове-linkedlistadd","title":"<p>Сколько выделяется дополнительно памяти при вызове <code>LinkedList.add()</code>?</p>","answer":"<p>Создается один новый экземпляр вложенного класса <code>Node</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-linkedlist","title":"<p>Оцените количество памяти на хранение одного примитива типа <code>byte</code> в <code>LinkedList</code>?</p>","answer":"<p>Каждый элемент <code>LinkedList</code> хранит ссылку на предыдущий элемент, следующий элемент и ссылку на данные.</p>\n<pre><code class=\"java language-java\">private static class Node&lt;E&gt; {\n        E item;\n        Node&lt;E&gt; next;\n        Node&lt;E&gt; prev;\n//...\n}\n</code></pre>\n<p>Для 32-битных систем каждая ссылка занимает 32 бита (4 байта). Сам объект (заголовок) вложенного класса <code>Node</code> занимает 8 байт. 4 + 4 + 4 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта. Примитив типа <code>byte</code> занимает 1 байт памяти, но в JCF примитивы упаковываются: объект типа <code>Byte</code> занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа <code>byte</code> и 7 байт для кратности 8). Также напомню, что значения от -128 до 127 кэшируются и для них новые объекты каждый раз не создаются. Таким образом, в x32 JVM 24 байта тратятся на хранение одного элемента в списке и 16 байт - на хранение упакованного объекта типа <code>Byte</code>. Итого 40 байт.</p>\n<p>Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт), размер заголовка каждого объекта составляет 16 байт (два машинных слова). Вычисления аналогичны: 8 + 8 + 8 + 16 = 40 байт и 24 байта. Итого 64 байта.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#оцените-количество-памяти-на-хранение-одного-примитива-типа-byte-в-arraylist","title":"<p>Оцените количество памяти на хранение одного примитива типа <code>byte</code> в <code>ArrayList</code>?</p>","answer":"<p><code>ArrayList</code> основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) - на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт - на хранение упакованного объекта типа <code>Byte</code>. Для x64 - 8 байт и 24 байта соответственно.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#для-arraylist-или-для-linkedlist-операция-добавления-элемента-в-середину-listaddlistsize2-newelement-медленнее","title":"<p>Для <code>ArrayList</code> или для <code>LinkedList</code> операция добавления элемента в середину (<code>list.add(list.size()/2, newElement)</code>) медленнее?</p>","answer":"<p>Для <code>ArrayList</code>:</p>\n<ul>\n<li>проверка массива на вместимость. Если вместимости недостаточно, то увеличение размера массива и копирование всех элементов в новый массив (<em>O(N)</em>);</li>\n<li>копирование всех элементов, расположенных правее от позиции вставки, на одну позицию вправо (<em>O(N)</em>);</li>\n<li>вставка элемента (<em>O(1)</em>).</li>\n</ul>\n<p>Для <code>LinkedList</code>:</p>\n<ul>\n<li>поиск позиции вставки (<em>O(N)</em>);</li>\n<li>вставка элемента (<em>O(1)</em>).</li>\n</ul>\n<p>В худшем случае вставка в середину списка эффективнее для <code>LinkedList</code>. В остальных - скорее всего, для <code>ArrayList</code>,\nпоскольку копирование элементов осуществляется за счет вызова быстрого системного метода <code>System.arraycopy()</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-реализации-класса-arraylist-есть-следующие-поля-object-elementdata-int-size-объясните-зачем-хранить-отдельно-size-если-всегда-можно-взять-elementdatalength","title":"<p>В реализации класса <code>ArrayList</code> есть следующие поля: <code>Object[] elementData</code>, <code>int size</code>. Объясните, зачем хранить отдельно <code>size</code>, если всегда можно взять <code>elementData.length</code>?</p>","answer":"<p>Размер массива <code>elementData</code> представляет собой вместимость (capacity) <code>ArrayList</code>, которая всегда больше\nпеременной <code>size</code> - реального количества хранимых элементов. При необходимости вместимость автоматически возрастает.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сравните-интерфейсы-queue-и-deque","title":"<p>Сравните интерфейсы <code>Queue</code> и <code>Deque</code></p>","answer":""},{"subject":"Java Collections Framework","url":"005-jcf.html#кто-кого-расширяет-queue-расширяет-deque-или-deque-расширяет-queue","title":"<p>Кто кого расширяет: <code>Queue</code> расширяет <code>Deque</code>, или <code>Deque</code> расширяет <code>Queue</code>?</p>","answer":"<p><code>Queue</code> - это очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out) - соответственно\nизвлечение элемента осуществляется с начала очереди, вставка элемента - в конец очереди. Хотя этот принцип нарушает, к\nпримеру, <code>PriorityQueue</code>, использующая «natural ordering» или переданный <code>Comparator</code> при вставке нового элемента.</p>\n<p><code>Deque</code> (Double Ended Queue) расширяет <code>Queue</code> и согласно документации, это линейная коллекция, поддерживающая\nвставку/извлечение элементов с обоих концов. Помимо этого реализации интерфейса <code>Deque</code> могут строиться по принципу\nFIFO, либо LIFO.</p>\n<p>Реализации и <code>Deque</code>, и <code>Queue</code> обычно не переопределяют методы <code>equals()</code> и <code>hashCode()</code>, вместо этого используются\nунаследованные методы класса Object, основанные на сравнении ссылок.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#почему-linkedlist-реализует-и-list-и-deque","title":"<p>Почему <code>LinkedList</code> реализует и <code>List</code>, и <code>Deque</code>?</p>","answer":"<p><code>LinkedList</code> позволяет добавлять элементы в начало и конец списка за константное время, что хорошо согласуется с поведением интерфейса <code>Deque</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#linkedlist-—-это-односвязный-двусвязный-или-четырехсвязный-список","title":"<p><code>LinkedList</code> — это односвязный, двусвязный или четырехсвязный список?</p>","answer":"<p><code>Двусвязный</code>: каждый элемент <code>LinkedList</code> хранит ссылку на предыдущий и следующий элементы.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-перебрать-элементы-linkedlist-в-обратном-порядке-не-используя-медленный-getindex","title":"<p>Как перебрать элементы <code>LinkedList</code> в обратном порядке, не используя медленный <code>get(index)</code>?</p>","answer":"<p>Для этого в <code>LinkedList</code> есть обратный итератор, который можно получить вызова метод <code>descendingIterator()</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-позволяет-сделать-priorityqueue","title":"<p>Что позволяет сделать <code>PriorityQueue</code>?</p>","answer":"<p>Особенностью <code>PriorityQueue</code> является возможность управления порядком элементов. По умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта <code>Comparator</code>, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.</p>\n<p>Используя <code>PriorityQueue</code>, можно, например, реализовать алгоритм Дейкстры для поиска кратчайшего пути от одной вершины графа к другой. Либо для хранения объектов согласно определённого свойства.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#stack-считается-устаревшим-чем-его-рекомендуют-заменять-почему","title":"<p><code>Stack</code> считается «устаревшим». Чем его рекомендуют заменять? Почему?</p>","answer":"<p><code>Stack</code> был добавлен в Java 1.0 как реализация стека LIFO (last-in-first-out) и является расширением коллекции <code>Vector</code>, хотя это несколько нарушает понятие стека (например, класс <code>Vector</code> предоставляет возможность обращаться к любому элементу по индексу). Является частично синхронизированной коллекцией (кроме метода добавления <code>push()</code>) с вытекающими отсюда последствиями в виде негативного воздействия на производительность. После добавления в Java 1.6 интерфейса <code>Deque</code>, рекомендуется использовать реализации именно этого интерфейса, например, <code>ArrayDeque</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#зачем-нужен-hashmap-если-есть-hashtable","title":"<p>Зачем нужен <code>HashMap</code>, если есть <code>Hashtable</code>?</p>","answer":"<ul>\n<li>Методы класса <code>Hashtable</code> синхронизированы, что приводит к снижению производительности, а <code>HashMap</code> - нет;</li>\n<li><code>HashTable</code> не может содержать элементы <code>null</code>, тогда как <code>HashMap</code> может содержать один ключ <code>null</code> и любое количество значений <code>null</code>;</li>\n<li>Iterator у <code>HashMap</code>, в отличие от Enumeration у <code>HashTable</code>, работает по принципу «fail-fast» (выдает исключение при любой несогласованности данных).</li>\n</ul>\n<p><code>Hashtable</code> это устаревший класс и его использование не рекомендовано.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-чем-разница-между-hashmap-и-identityhashmap-для-чего-нужна-identityhashmap","title":"<p>В чем разница между <code>HashMap</code> и <code>IdentityHashMap</code>? Для чего нужна <code>IdentityHashMap</code>?</p>","answer":"<p><code>IdentityHashMap</code> - это структура данных, так же реализующая интерфейс <code>Map</code> и использующая при сравнении ключей (значений) сравнение ссылок, а не\nвызов метода <code>equals()</code>. Другими словами, в <code>IdentityHashMap</code> два ключа <code>k1</code> и <code>k2</code> будут считаться равными, если они указывают на один объект, т.е.\nвыполняется условие <code>k1</code> == <code>k2</code>.</p>\n<p><code>IdentityHashMap</code> не использует метод <code>hashCode()</code>, вместо которого применяется метод <code>System.identityHashCode()</code>, по этой причине <code>IdentityHashMap</code>\nпо сравнению с <code>HashMap</code> имеет более высокую производительность, особенно если последний хранит объекты с дорогостоящими методами <code>equals()</code>\nи <code>hashCode()</code>.</p>\n<p>Одним из основных требований к использованию <code>HashMap</code> является неизменяемость ключа, а, т.к. <code>IdentityHashMap</code> не использует методы  <code>equals()</code> и <code>hashCode()</code>, то это правило на него не распространяется.</p>\n<p><code>IdentityHashMap</code> может применяться для реализации сериализации/клонирования. При выполнении подобных алгоритмов программе необходимо обслуживать хэш-таблицу со всеми ссылками на объекты, которые уже были обработаны. Такая структура не должна рассматривать уникальные объекты как равные, даже если метод <code>equals()</code> возвращает <code>true</code>.</p>\n<p>Пример кода:</p>\n<pre><code class=\"java language-java\">import java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\npublic class Q2 {\n\n    public static void main(String[] args) {\n        Q2 q = new Q2();\n        q.testHashMapAndIdentityHashMap();\n    }\n\n    private void testHashMapAndIdentityHashMap() {\n        CreditCard visa = new CreditCard(\"VISA\", \"04/12/2019\");\n\n        Map&lt;CreditCard, String&gt; cardToExpiry = new HashMap&lt;&gt;();\n        Map&lt;CreditCard, String&gt; cardToExpiryIdenity = new IdentityHashMap&lt;&gt;();\n\n        System.out.println(\"adding to HM\");\n        // inserting objects to HashMap\n        cardToExpiry.put(visa, visa.getExpiryDate());\n\n        // inserting objects to IdentityHashMap\n        cardToExpiryIdenity.put(visa, visa.getExpiryDate());\n        System.out.println(\"adding to IHM\");\n\n        System.out.println(\"before modifying keys\");\n        String result = cardToExpiry.get(visa) != null ? \"Yes\" : \"No\";\n        System.out.println(\"Does VISA card exists in HashMap? \" + result);\n\n        result = cardToExpiryIdenity.get(visa) != null ? \"Yes\" : \"No\";\n        System.out.println(\"Does VISA card exists in IdenityHashMap? \" + result);\n\n        // modifying value object\n        visa.setExpiryDate(\"02/11/2030\");\n\n        System.out.println(\"after modifying keys\");\n        result = cardToExpiry.get(visa) != null ? \"Yes\" : \"No\";\n        System.out.println(\"Does VISA card exists in HashMap? \" + result);\n\n        result = cardToExpiryIdenity.get(visa) != null ? \"Yes\" : \"No\";\n        System.out.println(\"Does VISA card exists in IdenityHashMap? \" + result);\n\n        System.out.println(\"cardToExpiry.containsKey\");\n        System.out.println(cardToExpiry.containsKey(visa));\n        System.out.println(\"cardToExpiryIdenity.containsKey\");\n        System.out.println(cardToExpiryIdenity.containsKey(visa));\n    }\n\n}\n\nclass CreditCard {\n    private String issuer;\n    private String expiryDate;\n\n    public CreditCard(String issuer, String expiryDate) {\n        this.issuer = issuer;\n        this.expiryDate = expiryDate;\n    }\n\n    public String getIssuer() {\n        return issuer;\n    }\n\n    public String getExpiryDate() {\n        return expiryDate;\n    }\n\n    public void setExpiryDate(String expiry) {\n        this.expiryDate = expiry;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((expiryDate == null) ? 0 : expiryDate.hashCode());\n        result = prime * result + ((issuer == null) ? 0 : issuer.hashCode());\n        System.out.println(\"hashCode = \" + result);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"equals !!! \");\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        CreditCard other = (CreditCard) obj;\n        if (expiryDate == null) {\n            if (other.expiryDate != null)\n                return false;\n        } else if (!expiryDate.equals(other.expiryDate))\n            return false;\n        if (issuer == null) {\n            if (other.issuer != null)\n                return false;\n        } else if (!issuer.equals(other.issuer))\n            return false;\n        return true;\n    }\n\n}\n</code></pre>\n<p>Результат выполнения кода:</p>\n<pre><code>adding to HM\nhashCode = 1285631513\nadding to IHM\nbefore modifying keys\nhashCode = 1285631513\nDoes VISA card exists in HashMap? Yes\nDoes VISA card exists in IdenityHashMap? Yes\nafter modifying keys\nhashCode = 791156485\nDoes VISA card exists in HashMap? No\nDoes VISA card exists in IdenityHashMap? Yes\ncardToExpiry.containsKey\nhashCode = 791156485\nfalse\ncardToExpiryIdenity.containsKey\ntrue\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-чем-разница-между-hashmap-и-weakhashmap-для-чего-используется-weakhashmap","title":"<p>В чем разница между <code>HashMap</code> и <code>WeakHashMap</code>? Для чего используется <code>WeakHashMap</code>?</p>","answer":"<p>В Java существует 4 типа ссылок: <em>сильные (strong reference)</em>, <em>мягкие (SoftReference)</em>, <em>слабые (WeakReference)</em> и <em>фантомные (PhantomReference)</em>.\nОсобенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достичь только с помощью цепочки WeakReference (то есть на него\nотсутствуют сильные и мягкие ссылки), то данный объект будет помечен на удаление.</p>\n<p><code>WeakHashMap</code> - это структура данных, реализующая интерфейс <code>Map</code> и основанная на использовании WeakReference для хранения ключей. Таким образом, пара\n«ключ-значение» будет удалена из <code>WeakHashMap</code>, если на объект-ключ более не имеется сильных ссылок.</p>\n<p>В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить\nдополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. В этом случае добавляем каждый объект\nв <code>WeakHashMap</code> в качестве ключа, а в качестве значения - нужную информацию. Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно\nпроверять хэш-таблицу и извлекать информацию. Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем\nсоответствующая запись для этой слабой ссылки будет удалена из <code>WeakHashMap</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-weakhashmap-используются-weakreferences-а-почему-бы-не-создать-softhashmap-на-softreferences","title":"<p>В <code>WeakHashMap</code> используются WeakReferences. А почему бы не создать <code>SoftHashMap</code> на SoftReferences?</p>","answer":"<p><code>SoftHashMap</code> представлена в сторонних библиотеках, например, в <code>Apache Commons</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-weakhashmap-используются-weakreferences-а-почему-бы-не-создать-phantomhashmap-на-phantomreferences","title":"<p>В <code>WeakHashMap</code> используются WeakReferences. А почему бы не создать <code>PhantomHashMap</code> на PhantomReferences?</p>","answer":"<p>PhantomReference при вызове метода <code>get()</code> возвращает всегда <code>null</code>, поэтому тяжело представить назначение такой структуры данных.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#linkedhashmap-что-в-нем-от-linkedlist-а-что-от-hashmap","title":"<p><code>LinkedHashMap</code> - что в нем от <code>LinkedList</code>, а что от <code>HashMap</code>?</p>","answer":"<p>Реализация <code>LinkedHashMap</code> отличается от <code>HashMap</code> поддержкой двухсвязанного списка, определяющего порядок итерации по элементам структуры данных. По умолчанию элементы списка упорядочены согласно их порядку добавления в <code>LinkedHashMap</code> (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора <code>accessOrder</code> в значение <code>true</code>. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов <code>get()</code> или <code>put()</code> элемент, к которому обращаемся, перемещается в конец списка.</p>\n<p>При добавлении элемента, который уже присутствует в <code>LinkedHashMap</code> (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-чем-проявляется-сортированность-sortedmap-кроме-того-что-tostring-выводит-все-элементы-по-порядку","title":"<p>В чем проявляется «сортированность» <code>SortedMap</code>, кроме того, что <code>toString()</code> выводит все элементы по порядку?</p>","answer":"<p>Так же оно проявляется при итерации по коллекции.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-устроен-hashmap","title":"<p>Как устроен <code>HashMap</code>?</p>","answer":"<p><code>HashMap</code> состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#согласно-кнуту-и-кормену-существует-две-основных-реализации-хэш-таблицы-на-основе-открытой-адресации-и-на-основе-метода-цепочек-как-реализована-hashmap-почему-по-вашему-мнению-была-выбрана-именно-эта-реализация-в-чем-плюсы-и-минусы-каждого-подхода","title":"<p>Согласно Кнуту и Кормену существует две основных реализации хэш-таблицы: на основе открытой адресации и на основе метода цепочек. Как реализована <code>HashMap</code>? Почему, по вашему мнению, была выбрана именно эта реализация? В чем плюсы и минусы каждого подхода?</p>","answer":"<p><code>HashMap</code> реализован с использованием метода цепочек, т.е. каждой ячейке массива (корзине) соответствует свой связный список и при возникновении коллизии осуществляется добавление нового элемента в этот список.</p>\n<p>Для метода цепочек коэффициент заполнения может быть больше 1 и с увеличением числа элементов производительность убывает линейно. Такие таблицы удобно использовать, если заранее неизвестно количество хранимых элементов, либо их может быть достаточно много, что приводит к большим значениям коэффициента заполнения.</p>\n<p>Среди методов открытой реализации различают:</p>\n<ul>\n<li>линейное пробирование;</li>\n<li>квадратичное пробирование;</li>\n<li>двойное хэширование.</li>\n</ul>\n<p>Недостатки структур с методом открытой адресации:</p>\n<ul>\n<li>Количество элементов в хэш-таблице не может превышать размера массива. По мере увеличения числа элементов и повышения коэффициента заполнения производительность структуры резко падает, поэтому необходимо проводить перехэширование.</li>\n<li>Сложно организовать удаление элемента.</li>\n<li>Первые два метода открытой адресации приводят к проблеме первичной и вторичной группировок.</li>\n</ul>\n<p>Преимущества хэш-таблицы с открытой адресацией:</p>\n<ul>\n<li>отсутствие затрат на создание и хранение объектов списка;</li>\n<li>простота организации сериализации/десериализации объекта.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-работает-hashmap-при-попытке-сохранить-в-него-два-элемента-по-ключам-с-одинаковым-hashcode-но-для-которых-equals-false","title":"<p>Как работает <code>HashMap</code> при попытке сохранить в него два элемента по ключам с одинаковым <code>hashCode()</code>, но для которых <code>equals() == false</code>?</p>","answer":"<p>По значению <code>hashCode()</code> вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким <code>hashCode()</code> уже присутствует, но их <code>equals()</code> методы не равны, то элемент будет добавлен в конец списка.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-начальное-количество-корзин-в-hashmap","title":"<p>Какое начальное количество корзин в <code>HashMap</code>?</p>","answer":"<p>В конструкторе по умолчанию - 16, используя конструкторы с параметрами можно задавать произвольное начальное количество корзин.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какова-оценка-временной-сложности-операций-над-элементами-из-hashmap-гарантирует-ли-hashmap-указанную-сложность-выборки-элемента","title":"<p>Какова оценка временной сложности операций над элементами из <code>HashMap</code>? Гарантирует ли <code>HashMap</code> указанную сложность выборки элемента?</p>","answer":"<p>В общем случае операции добавления, поиска и удаления элементов занимают константное время.</p>\n<p>Данная сложность не гарантируется, т.к. если хэш-функция распределяет элементы по корзинам равномерно, временная\nсложность станет не хуже <a href=\"https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0#%D0%9B%D0%BE%D0%B3%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F\"><em>Логарифмического\nвремени</em></a>\nO(log(N)), а в случае, когда хэш-функция постоянно возвращает одно и то же значение, <code>HashMap</code> превратится в связный\nсписок со сложностью О(n).</p>\n<p>Пример кода двоичного поиска:</p>\n<pre><code class=\"java language-java\">public class Q {\n    public static void main(String[] args) {\n        Q q = new Q();\n        q.binSearch();\n    }\n\n    private void binSearch() {\n        int[] inpArr = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        Integer result = binSearchF(inpArr, 1, 0, inpArr.length - 1);\n        System.out.println(\"-----------------------\");\n        result = binSearchF(inpArr, 2, 0, inpArr.length - 1);\n        System.out.println(\"Found at position \" + result);\n    }\n\n    private Integer binSearchF(int[] inpArr, int searchValue, int low, int high) {\n        Integer index = null;\n        while (low &lt;= high) {\n            System.out.println(\"New iteration, low = \" + low + \", high = \" + high);\n            int mid = (low + high) / 2;\n            System.out.println(\"trying mid = \" + mid + \" inpArr[mid] = \" + inpArr[mid]);\n            if (inpArr[mid] &lt; searchValue) {\n                low = mid + 1;\n                System.out.println(\"inpArr[mid] (\" + inpArr[mid] + \") &lt; searchValue(\" + searchValue + \"), mid = \" + mid\n                        + \", setting low = \" + low);\n            } else if (inpArr[mid] &gt; searchValue) {\n                high = mid - 1;\n                System.out.println(\"inpArr[mid] (\" + inpArr[mid] + \") &gt; searchValue(\" + searchValue + \"), mid = \" + mid\n                        + \", setting high = \" + high);\n            } else if (inpArr[mid] == searchValue) {\n                index = mid;\n                System.out.println(\"found at index \" + mid);\n                break;\n            }\n        }\n        return index;\n    }\n}\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#возможна-ли-ситуация-когда-hashmap-выродится-в-список-даже-с-ключами-имеющими-разные-hashcode","title":"<p>Возможна ли ситуация, когда <code>HashMap</code> выродится в список даже с ключами имеющими разные <code>hashCode()</code>?</p>","answer":"<p>Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-каком-случае-может-быть-потерян-элемент-в-hashmap","title":"<p>В каком случае может быть потерян элемент в <code>HashMap</code>?</p>","answer":"<p>Допустим, в качестве ключа используется не примитив, а объект с несколькими полями. После добавления элемента в <code>HashMap</code> у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хэш-кода. В результате при попытке найти данный элемент по исходному ключу, будет происходить обращение к правильной корзине, а вот <code>equals</code> уже не найдет указанный ключ в списке элементов. Тем не менее, даже если <code>equals</code> реализован таким образом, что изменение данного поля объекта не влияет на результат, то после увеличения размера корзин и пересчета хэш-кодов элементов, указанный элемент, с измененным значением поля, с большой долей вероятности попадет в совершенно другую корзину и тогда уже потеряется совсем.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#почему-нельзя-использовать-byte-в-качестве-ключа-в-hashmap","title":"<p>Почему нельзя использовать <code>byte[]</code> в качестве ключа в <code>HashMap</code>?</p>","answer":"<p>Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному <code>Object.hashCode()</code> на основании адреса массива). Так же у массивов не переопределен <code>equals</code> и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какова-роль-equals-и-hashcode-в-hashmap","title":"<p>Какова роль <code>equals()</code> и <code>hashCode()</code> в <code>HashMap</code>?</p>","answer":"<p><code>hashCode</code> позволяет определить корзину для поиска элемента, а <code>equals</code> используется для сравнения ключей элементов в списке корзины и искомого ключа.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#каково-максимальное-число-значений-hashcode","title":"<p>Каково максимальное число значений <code>hashCode()</code>?</p>","answer":"<p>Число значений следует из сигнатуры <code>int hashCode()</code> и равно диапазону типа <code>int</code> — <strong>2<sup>32</sup></strong>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-getkey-для-ключа-которого-нет-в-hashmap","title":"<p>Какое худшее время работы метода get(key) для ключа, которого нет в <code>HashMap</code>?</p>","answer":""},{"subject":"Java Collections Framework","url":"005-jcf.html#какое-худшее-время-работы-метода-getkey-для-ключа-который-есть-в-hashmap","title":"<p>Какое худшее время работы метода get(key) для ключа, который есть в <code>HashMap</code>?</p>","answer":"<p><strong><em>O(N)</em></strong>. Худший случай - это поиск ключа в <code>HashMap</code>, вырожденного в список по причине совпадения ключей по <code>hashCode()</code> и для выяснения хранится ли элемент с определённым ключом может потребоваться перебор всего списка.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сколько-переходов-происходит-в-момент-вызова-hashmapgetkey-по-ключу-который-есть-в-таблице","title":"<p>Сколько переходов происходит в момент вызова <code>HashMap.get(key)</code> по ключу, который есть в таблице?</p>","answer":"<ul>\n<li>ключ равен <code>null</code>: <strong>1</strong> - выполняется единственный метод <code>getForNullKey()</code>.</li>\n<li>любой ключ отличный от <code>null</code>: <strong>4</strong> - вычисление хэш-кода ключа; определение номера корзины; поиск значения; возврат значения.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сколько-создается-новых-объектов-когда-вы-добавляете-новый-элемент-в-hashmap","title":"<p>Сколько создается новых объектов, когда вы добавляете новый элемент в <code>HashMap</code>?</p>","answer":"<p><strong>Один</strong> новый объект статического вложенного класса <code>Entry&lt;K,V&gt;</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-и-когда-происходит-увеличение-количества-корзин-в-hashmap","title":"<p>Как и когда происходит увеличение количества корзин в <code>HashMap</code>?</p>","answer":"<p>Помимо <code>capacity</code> у <code>HashMap</code> есть еще поле <code>loadFactor</code>, на основании которого, вычисляется предельное количество\nзанятых корзин <code>capacity * loadFactor</code>. По умолчанию <code>loadFactor = 0.75</code>. По достижению предельного значения, число\nкорзин увеличивается в 2 раза и для всех хранимых элементов вычисляется новое «местоположение» с учетом нового числа\nкорзин.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#объясните-смысл-параметров-в-конструкторе-hashmapint-initialcapacity-float-loadfactor","title":"<p>Объясните смысл параметров в конструкторе <code>HashMap(int initialCapacity, float loadFactor)</code></p>","answer":"<ul>\n<li><code>initialCapacity</code> - исходный размер <code>HashMap</code>, количество корзин в хэш-таблице в момент её создания.</li>\n<li><code>loadFactor</code> - коэффициент заполнения <code>HashMap</code>, при превышении которого происходит увеличение количества корзин и\nавтоматическое перехэширование. Равен отношению числа уже хранимых элементов в таблице к её размеру.</li>\n</ul>"},{"subject":"Java Collections Framework","url":"005-jcf.html#будет-ли-работать-hashmap-если-все-добавляемые-ключи-будут-иметь-одинаковый-hashcode","title":"<p>Будет ли работать <code>HashMap</code>, если все добавляемые ключи будут иметь одинаковый <code>hashCode()</code>?</p>","answer":"<p>Да, будет, но в этом случае <code>HashMap</code> вырождается в связный список и теряет свои преимущества.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-перебрать-все-ключи-map","title":"<p>Как перебрать все ключи <code>Map</code>?</p>","answer":"<p>Использовать метод <code>keySet()</code>, который возвращает множество <code>Set&lt;K&gt;</code> ключей.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-перебрать-все-значения-map","title":"<p>Как перебрать все значения <code>Map</code>?</p>","answer":"<p>Использовать метод <code>values()</code>, который возвращает коллекцию <code>Collection&lt;V&gt;</code> значений.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-перебрать-все-пары-ключ-значение-в-map","title":"<p>Как перебрать все пары «ключ-значение» в <code>Map</code>?</p>","answer":"<p>Использовать метод <code>entrySet()</code>, который возвращает множество <code>Set&lt;Map.Entry&lt;K, V&gt;</code> пар «ключ-значение».</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#в-чем-отличия-treeset-и-hashset","title":"<p>В чем отличия <code>TreeSet</code> и <code>HashSet</code>?</p>","answer":"<p><code>TreeSet</code> обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность выполнения основных операций не хуже <em>O(log(N))</em> (_\nЛогарифмическое время_).</p>\n<p><code>HashSet</code> использует для хранения элементов такой же подход, что и <code>HashMap</code>, за тем отличием, что в <code>HashSet</code> в качестве ключа и значения выступает\nсам <code>элемент</code>, кроме того <code>HashSet</code> не поддерживает упорядоченное хранение элементов и обеспечивает временную сложность выполнения операций\nаналогично <code>HashMap</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#что-будет-если-добавлять-элементы-в-treeset-по-возрастанию","title":"<p>Что будет, если добавлять элементы в <code>TreeSet</code> по возрастанию?</p>","answer":"<p>В основе <code>TreeSet</code> лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, <code>TreeSet</code> все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#чем-linkedhashset-отличается-от-hashset","title":"<p>Чем <code>LinkedHashSet</code> отличается от <code>HashSet</code>?</p>","answer":"<p><code>LinkedHashSet</code> отличается от <code>HashSet</code> только тем, что в его основе лежит <code>LinkedHashMap</code> вместо <code>HashMap</code>. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order). При добавлении элемента, который уже присутствует в <code>LinkedHashSet</code> (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#для-enum-есть-специальный-класс-javautilenumset-зачем-чем-авторов-не-устраивал-hashset-или-treeset","title":"<p>Для <code>Enum</code> есть специальный класс <code>java.util.EnumSet</code>. Зачем? Чем авторов не устраивал <code>HashSet</code> или <code>TreeSet</code>?</p>","answer":"<p><code>EnumSet</code> - это реализация интерфейса <code>Set</code> для использования с перечислениями (<code>Enum</code>). В структуре данных хранятся объекты только одного типа <code>Enum</code>, указываемого при создании. Для хранения значений <code>EnumSet</code> использует массив битов (<em>bit vector</em>), - это позволяет получить высокую компактность и эффективность. Проход по <code>EnumSet</code> осуществляется согласно порядку объявления элементов перечисления.</p>\n<p>Все основные операции выполняются за <em>O(1)</em> и обычно (но негарантированно) быстрей аналогов из <code>HashSet</code>, а пакетные операции (<em>bulk operations</em>), такие как <code>containsAll()</code> и <code>retainAll()</code> выполняются даже горазда быстрей.</p>\n<p>Помимо всего <code>EnumSet</code> предоставляет множество статических методов инициализации для упрощенного и удобного создания экземпляров.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#какие-существуют-способы-перебирать-элементы-списка","title":"<p>Какие существуют способы перебирать элементы списка?</p>","answer":"<ul>\n<li>Цикл с итератором</li>\n</ul>\n<pre><code class=\"java language-java\">Iterator&lt;String&gt; iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    //iterator.next();\n}\n</code></pre>\n<ul>\n<li>Цикл <code>for</code></li>\n</ul>\n<pre><code class=\"java language-java\">for (int i = 0; i &lt; list.size(); i++) {\n    //list.get(i);\n}\n</code></pre>\n<ul>\n<li>Цикл <code>while</code></li>\n</ul>\n<pre><code class=\"java language-java\">int i = 0;\nwhile (i &lt; list.size()) {\n    //list.get(i);\n    i++;\n}\n</code></pre>\n<ul>\n<li>«for-each»</li>\n</ul>\n<pre><code class=\"java language-java\">for (String element : list) {\n    //element;\n}\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#каким-образом-можно-получить-синхронизированные-объекты-стандартных-коллекций","title":"<p>Каким образом можно получить синхронизированные объекты стандартных коллекций?</p>","answer":"<p>С помощью статических методов <code>synchronizedMap()</code> и <code>synchronizedList()</code> класса <code>Collections</code>. Данные методы возвращают синхронизированный декоратор переданной коллекции. При этом все равно в случае обхода по коллекции требуется ручная синхронизация.</p>\n<pre><code class=\"java language-java\">  Map m = Collections.synchronizedMap(new HashMap());\n  List l = Collections.synchronizedList(new ArrayList());\n</code></pre>\n<p>Начиная с Java 6 JCF был расширен специальными коллекциями, поддерживающими многопоточный доступ, такими как <code>CopyOnWriteArrayList</code> и <code>ConcurrentHashMap</code>.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-получить-коллекцию-только-для-чтения","title":"<p>Как получить коллекцию только для чтения?</p>","answer":"<p>При помощи:</p>\n<ul>\n<li><code>Collections.unmodifiableList(list)</code>;</li>\n<li><code>Collections.unmodifiableSet(set)</code>;</li>\n<li><code>Collections.unmodifiableMap(map)</code>.</li>\n</ul>\n<p>Эти методы принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами\nвнутри.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#напишите-однопоточную-программу-которая-заставляет-коллекцию-выбросить-concurrentmodificationexception","title":"<p>Напишите однопоточную программу, которая заставляет коллекцию выбросить <code>ConcurrentModificationException</code></p>","answer":"<pre><code class=\"java language-java\">public static void main(String[] args) {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n\n    for (Integer integer : list) {\n        list.remove(1);\n    }\n}\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#приведите-пример-когда-какая-либо-коллекция-выбрасывает-unsupportedoperationexception","title":"<p>Приведите пример, когда какая-либо коллекция выбрасывает <code>UnsupportedOperationException</code></p>","answer":"<pre><code class=\"java language-java\">public static void main(String[] args) {\n    List&lt;Integer&gt; list = Collections.emptyList();\n    list.add(0);\n}\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#реализуйте-симметрическую-разность-двух-коллекций-используя-методы-collection-addall-removeall-retainall","title":"<p>Реализуйте симметрическую разность двух коллекций используя методы <code>Collection</code> (<code>addAll(...)</code>, <code>removeAll(...)</code>, <code>retainAll(...)</code>)</p>","answer":"<p>Симметрическая разность двух коллекций - это множество элементов, одновременно не принадлежащих обоим исходным\nколлекциям.</p>\n<pre><code class=\"java language-java\">&lt;T&gt; Collection&lt;T&gt; symmetricDifference(Collection&lt;T&gt; a, Collection&lt;T&gt; b) {\n    // Объединяем коллекции.\n    Collection&lt;T&gt; result = new ArrayList&lt;&gt;(a);\n    result.addAll(b);\n\n    // Получаем пересечение коллекций.\n    Collection&lt;T&gt; intersection = new ArrayList&lt;&gt;(a);\n    intersection.retainAll(b);\n\n    // Удаляем элементы, расположенные в обоих коллекциях.\n    result.removeAll(intersection);\n\n    return result;\n}\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-используя-linkedhashmap-сделать-кэш-c-invalidation-policy","title":"<p>Как, используя LinkedHashMap, сделать кэш c «invalidation policy»?</p>","answer":"<p>Необходимо использовать <em>LRU-алгоритм (Least Recently Used algorithm)</em> и <code>LinkedHashMap</code> с access-order. В этом случае при обращении к элементу он будет перемещаться в конец списка, а наименее используемые элементы будут постепенно группироваться в начале списка. Так же в стандартной реализации <code>LinkedHashMap</code> есть метод <code>removeEldestEntries()</code>, который возвращает <code>true</code>, если текущий объект <code>LinkedHashMap</code> должен удалить наименее используемый элемент из коллекции при использовании методов <code>put()</code> и <code>putAll()</code>.</p>\n<pre><code class=\"java language-java\">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {\n    private static final int MAX_ENTRIES = 10;\n\n    public LRUCache(int initialCapacity) {\n        super(initialCapacity, 0.85f, true);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {\n        return size() &gt; MAX_ENTRIES;\n    }\n}\n</code></pre>\n<p>Стоит заметить, что <code>LinkedHashMap</code> не позволяет полностью реализовать LRU-алгоритм, поскольку при вставке уже имеющегося в коллекции элемента порядок итерации по элементам не меняется.</p>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-одной-строчкой-скопировать-элементы-любой-collection-в-массив","title":"<p>Как одной строчкой скопировать элементы любой <code>collection</code> в массив?</p>","answer":"<pre><code class=\"java language-java\">Object[] array = collection.toArray();\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-одним-вызовом-из-list-получить-list-со-всеми-элементами-кроме-первых-и-последних-3-х","title":"<p>Как одним вызовом из <code>List</code> получить <code>List</code> со всеми элементами, кроме первых и последних 3-х?</p>","answer":"<pre><code class=\"java language-java\">List&lt;Integer&gt; subList = list.subList(3, list.size() - 3);\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-одной-строчкой-преобразовать-hashset-в-arraylist","title":"<p>Как одной строчкой преобразовать <code>HashSet</code> в <code>ArrayList</code>?</p>","answer":"<pre><code class=\"java language-java\">ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(new HashSet&lt;&gt;());\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#как-одной-строчкой-преобразовать-arraylist-в-hashset","title":"<p>Как одной строчкой преобразовать <code>ArrayList</code> в <code>HashSet</code>?</p>","answer":"<pre><code class=\"java language-java\">HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(new ArrayList&lt;&gt;());\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сделайте-hashset-из-ключей-hashmap","title":"<p>Сделайте <code>HashSet</code> из ключей <code>HashMap</code></p>","answer":"<pre><code class=\"java language-java\">HashSet&lt;Object&gt; set = new HashSet&lt;&gt;(map.keySet());\n</code></pre>"},{"subject":"Java Collections Framework","url":"005-jcf.html#сделайте-hashmap-из-hashsetmapentryk-v","title":"<p>Сделайте <code>HashMap</code> из <code>HashSet&lt;Map.Entry&lt;K, V&gt;&gt;</code></p>","answer":"<pre><code class=\"java language-java\">HashMap&lt;K, V&gt; map = new HashMap&lt;&gt;(set.size());\nfor (Map.Entry&lt;K, V&gt; entry : set) {\n    map.put(entry.getKey(), entry.getValue());\n}\n</code></pre>\n<p><a href=\"#java-collections-framework\">к оглавлению</a></p>\n<h1 id=\"\">Источник</h1>\n<ul>\n<li><a href=\"http://www.parshinpn.pro/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1\">parshinpn.pro</a></li>\n<li><a href=\"https://habrahabr.ru/post/162017/\">Хабрахабр</a></li>\n<li><a href=\"http://www.quizful.net/interview/java\">Quizful</a></li>\n<li><a href=\"http://info.javarush.ru/\">JavaRush</a></li>\n<li><a href=\"https://habrahabr.ru/post/237043/\">Хабрахабр:Справочник по Java Collections Framework</a></li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#что-такое-лямбда-какова-структура-и-особенности-использования-лямбда-выражения","title":"<p>Что такое <em>«лямбда»</em>? Какова структура и особенности использования лямбда-выражения?</p>","answer":"<p><strong>Лямбда</strong> представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.</p>\n<p>Основу лямбда-выражения составляет <em>лямбда-оператор</em>, который представляет стрелку <code>-&gt;</code>. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.</p>\n<p>Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.</p>\n<pre><code class=\"java language-java\">interface Operationable {\n    int calculate(int x, int y);\n}\n\npublic static void main(String[] args) {\n    Operationable operation = (x, y) -&gt; x + y;\n    int result = operation.calculate(10, 20);\n    System.out.println(result); //30\n}\n</code></pre>\n<p>По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее применялись в Java.</p>\n<ul>\n<li><p><em>Отложенное выполнение (deferred execution) лямбда-выражения</em>- определяется один раз в одном месте программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.</p></li>\n<li><p><em>Параметры лямбда-выражения</em> должны соответствовать по типу параметрам метода функционального интерфейса:</p></li>\n</ul>\n<pre><code class=\"java language-java\">operation = (int x, int y) -&gt; x + y;\n//При написании самого лямбда-выражения тип параметров разрешается не указывать:\n(x, y) -&gt; x + y;\n//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,\n() -&gt; 30 + 20;\n//Если метод принимает только один параметр, то скобки можно опустить:\nn -&gt; n * n;\n</code></pre>\n<ul>\n<li><em>Конечные лямбда-выражения</em> не обязаны возвращать какое-либо значение.</li>\n</ul>\n<pre><code class=\"java language-java\">interface Printable {\n    void print(String s);\n}\n\npublic static void main(String[] args) {\n    Printable printer = s -&gt; System.out.println(s);\n    printer.print(\"Hello, world\");\n}\n</code></pre>\n<ul>\n<li><em>Блочные лямбда-выражения</em> обрамляются фигурными скобками. В блочных лямбда-выражениях можно использовать внутренние вложенные блоки, циклы, конструкции <code>if</code>, <code>switch</code>, создавать переменные и т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется оператор <code>return</code>:</li>\n</ul>\n<pre><code class=\"java language-java\">Operationable operation = (int x, int y) -&gt; {\n    if (y == 0) {\n        return 0;\n    }\n    else {\n        return x / y;\n    }\n};\n</code></pre>\n<ul>\n<li><em>Передача лямбда-выражения в качестве параметра метода</em>:</li>\n</ul>\n<pre><code class=\"java language-java\">interface Condition {\n    boolean isAppropriate(int n);\n}\n\nprivate static int sum(int[] numbers, Condition condition) {\n    int result = 0;\n    for (int i : numbers) {\n        if (condition.isAppropriate(i)) {\n            result += i;\n        }\n    }\n    return result;\n}\n\npublic static void main(String[] args) {\n    System.out.println(sum(new int[] {0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -&gt; n != 0));\n}\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#к-каким-переменным-есть-доступ-у-лямбда-выражений","title":"<p>К каким переменным есть доступ у лямбда-выражений?</p>","answer":"<p>Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:</p>\n<ul>\n<li>неизменяемые (<em>effectively final</em> - не обязательно помеченные как <code>final</code>) локальные переменные;</li>\n<li>поля класса;</li>\n<li>статические переменные.</li>\n</ul>\n<p>К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.</p>"},{"subject":"Java 8","url":"006-java8.html#как-отсортировать-список-строк-с-помощью-лямбда-выражения","title":"<p>Как отсортировать список строк с помощью лямбда-выражения?</p>","answer":"<pre><code class=\"java language-java\">public static List&lt;String&gt; sort(List&lt;String&gt; list){\n    Collections.sort(list, (a, b) -&gt; a.compareTo(b));\n    return list;\n}\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-ссылка-на-метод","title":"<p>Что такое «ссылка на метод»?</p>","answer":"<p>Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом <strong>method reference (ссылка на метод)</strong> для непосредственной передачи этого метода. Такая ссылка передается в виде:</p>\n<ul>\n<li><code>имя_класса::имя_статического_метода</code> для статического метода;</li>\n<li><code>объект_класса::имя_метода</code> для метода экземпляра;</li>\n<li><code>название_класса::new</code> для конструктора.</li>\n</ul>\n<p>Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.</p>\n<pre><code class=\"java language-java\">private interface Measurable {\n    public int length(String string);\n}\n\npublic static void main(String[] args) {\n    Measurable a = String::length;\n    System.out.println(a.length(\"abc\"));\n}\n</code></pre>\n<p>Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.</p>"},{"subject":"Java 8","url":"006-java8.html#какие-виды-ссылок-на-методы-вы-знаете","title":"<p>Какие виды ссылок на методы вы знаете?</p>","answer":"<ul>\n<li>на статический метод;</li>\n<li>на метод экземпляра;</li>\n<li>на конструкторе.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#объясните-выражение-systemoutprintln","title":"<p>Объясните выражение <code>System.out::println</code></p>","answer":"<p>Данное выражение иллюстрирует механизм <em>instance method reference</em>: передачи ссылки на метод <code>println()</code> статического\nполя <code>out</code> класса <code>System</code>.</p>"},{"subject":"Java 8","url":"006-java8.html#что-такое-функциональные-интерфейсы","title":"<p>Что такое «функциональные интерфейсы»?</p>","answer":"<p><strong>Функциональный интерфейс</strong> - это интерфейс, который определяет только один абстрактный метод.</p>\n<p>Чтобы точно определить интерфейс как функциональный, добавлена аннотация <code>@FunctionalInterface</code>, работающая по\nпринципу <code>@Override</code>. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.</p>\n<p>Интерфейс может включать сколько угодно <code>default</code> методов и при этом оставаться функциональным, потому что <code>default</code> методы - не абстрактные.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-functiontr-doublefunctionr-intfunctionr-и-longfunctionr","title":"<p>Для чего нужны функциональные интерфейсы <code>Function&lt;T,R&gt;</code>, <code>DoubleFunction&lt;R&gt;</code>, <code>IntFunction&lt;R&gt;</code> и <code>LongFunction&lt;R&gt;</code>?</p>","answer":"<p><strong><code>Function&lt;T, R&gt;</code></strong> - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса <code>T</code> и возвращающая на выходе экземпляр класса <code>R</code>.</p>\n<p>Методы по умолчанию могут использоваться для построения цепочек вызовов (<code>compose</code>, <code>andThen</code>).</p>\n<pre><code class=\"java language-java\">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;\nFunction&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);\nbackToString.apply(\"123\");     // \"123\"\n</code></pre>\n<ul>\n<li><code>DoubleFunction&lt;R&gt;</code> - функция, получающая на вход <code>Double</code> и возвращающая на выходе экземпляр класса <code>R</code>;</li>\n<li><code>IntFunction&lt;R&gt;</code> - функция, получающая на вход <code>Integer</code> и возвращающая на выходе экземпляр класса <code>R</code>;</li>\n<li><code>LongFunction&lt;R&gt;</code> - функция, получающая на вход <code>Long</code> и возвращающая на выходе экземпляр класса <code>R</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-unaryoperatort-doubleunaryoperator-intunaryoperator-и-longunaryoperator","title":"<p>Для чего нужны функциональные интерфейсы <code>UnaryOperator&lt;T&gt;</code>, <code>DoubleUnaryOperator</code>, <code>IntUnaryOperator</code> и <code>LongUnaryOperator</code>?</p>","answer":"<p><strong><code>UnaryOperator&lt;T&gt;</code> (унарный оператор)</strong> принимает в качестве параметра объект типа <code>T</code>, выполняет над ними операции и возвращает результат операций в виде объекта типа <code>T</code>:</p>\n<pre><code class=\"java language-java\">UnaryOperator&lt;Integer&gt; operator = x -&gt; x * x;\nSystem.out.println(operator.apply(5)); // 25\n</code></pre>\n<ul>\n<li><code>DoubleUnaryOperator</code> - унарный оператор, получающий на вход <code>Double</code>;</li>\n<li><code>IntUnaryOperator</code> - унарный оператор, получающий на вход <code>Integer</code>;</li>\n<li><code>LongUnaryOperator</code> - унарный оператор, получающий на вход <code>Long</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-binaryoperatort-doublebinaryoperator-intbinaryoperator-и-longbinaryoperator","title":"<p>Для чего нужны функциональные интерфейсы <code>BinaryOperator&lt;T&gt;</code>, <code>DoubleBinaryOperator</code>, <code>IntBinaryOperator</code> и <code>LongBinaryOperator</code>?</p>","answer":"<p><strong><code>BinaryOperator&lt;T&gt;</code> (бинарный оператор)</strong> - интерфейс, с помощью которого реализуется функция, получающая на вход два экземпляра класса <code>T</code> и возвращающая на выходе экземпляр класса <code>T</code>.</p>\n<pre><code class=\"java language-java\">BinaryOperator&lt;Integer&gt; operator = (a, b) -&gt; a + b;\nSystem.out.println(operator.apply(1, 2)); // 3\n</code></pre>\n<ul>\n<li><code>DoubleBinaryOperator</code> - бинарный оператор, получающий на вход <code>Double</code>;</li>\n<li><code>IntBinaryOperator</code> - бинарный оператор, получающий на вход <code>Integer</code>;</li>\n<li><code>LongBinaryOperator</code> - бинарный оператор, получающий на вход <code>Long</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-predicatet-doublepredicate-intpredicate-и-longpredicate","title":"<p>Для чего нужны функциональные интерфейсы <code>Predicate&lt;T&gt;</code>, <code>DoublePredicate</code>, <code>IntPredicate</code> и <code>LongPredicate</code>?</p>","answer":"<p><strong><code>Predicate&lt;T&gt;</code> (предикат)</strong> - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса <code>T</code> и возвращающая на выходе значение типа <code>boolean</code>.</p>\n<p>Интерфейс содержит различные методы по умолчанию, позволяющие строить сложные условия (<code>and</code>, <code>or</code>, <code>negate</code>).</p>\n<pre><code class=\"java language-java\">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;\npredicate.test(\"foo\"); // true\npredicate.negate().test(\"foo\"); // false\n</code></pre>\n<ul>\n<li><code>DoublePredicate</code> - предикат, получающий на вход <code>Double</code>;</li>\n<li><code>IntPredicate</code> - предикат, получающий на вход <code>Integer</code>;</li>\n<li><code>LongPredicate</code> - предикат, получающий на вход <code>Long</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-consumert-doubleconsumer-intconsumer-и-longconsumer","title":"<p>Для чего нужны функциональные интерфейсы <code>Consumer&lt;T&gt;</code>, <code>DoubleConsumer</code>, <code>IntConsumer</code> и <code>LongConsumer</code>?</p>","answer":"<p><strong><code>Consumer&lt;T&gt;</code> (потребитель)</strong> - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр класса <code>T</code>, производит с ним некоторое действие и ничего не возвращает.</p>\n<pre><code class=\"java language-java\">Consumer&lt;String&gt; hello = (name) -&gt; System.out.println(\"Hello, \" + name);\nhello.accept(\"world\");\n</code></pre>\n<ul>\n<li><code>DoubleConsumer</code> - потребитель, получающий на вход <code>Double</code>;</li>\n<li><code>IntConsumer</code> - потребитель, получающий на вход <code>Integer</code>;</li>\n<li><code>LongConsumer</code> - потребитель, получающий на вход <code>Long</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-suppliert-booleansupplier-doublesupplier-intsupplier-и-longsupplier","title":"<p>Для чего нужны функциональные интерфейсы <code>Supplier&lt;T&gt;</code>,  <code>BooleanSupplier</code>, <code>DoubleSupplier</code>, <code>IntSupplier</code> и <code>LongSupplier</code>?</p>","answer":"<p><strong><code>Supplier&lt;T&gt;</code> (поставщик)</strong> - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса <code>T</code>;</p>\n<pre><code class=\"java language-java\">Supplier&lt;LocalDateTime&gt; now = LocalDateTime::now;\nnow.get();\n</code></pre>\n<ul>\n<li><code>DoubleSupplier</code> - поставщик, возвращающий <code>Double</code>;</li>\n<li><code>IntSupplier</code> - поставщик, возвращающий <code>Integer</code>;</li>\n<li><code>LongSupplier</code> - поставщик, возвращающий <code>Long</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужен-функциональный-интерфейс-biconsumertu","title":"<p>Для чего нужен функциональный интерфейс <code>BiConsumer&lt;T,U&gt;</code>?</p>","answer":"<p><strong><code>BiConsumer&lt;T,U&gt;</code></strong> представляет собой операцию, которая принимает два аргумента классов <code>T</code> и <code>U</code> производит с ними некоторое действие и ничего не возвращает.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужен-функциональный-интерфейс-bifunctiontur","title":"<p>Для чего нужен функциональный интерфейс <code>BiFunction&lt;T,U,R&gt;</code>?</p>","answer":"<p><strong><code>BiFunction&lt;T,U,R&gt;</code></strong> представляет собой операцию, которая принимает два аргумента классов <code>T</code> и <code>U</code> и возвращающая результат класса <code>R</code>.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужен-функциональный-интерфейс-bipredicatetu","title":"<p>Для чего нужен функциональный интерфейс <code>BiPredicate&lt;T,U&gt;</code>?</p>","answer":"<p><strong><code>BiPredicate&lt;T,U&gt;</code></strong> представляет собой операцию, которая принимает два аргумента классов <code>T</code> и <code>U</code> и возвращающая результат типа <code>boolean</code>.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-вида-tofunction","title":"<p>Для чего нужны функциональные интерфейсы вида <code>_To_Function</code>?</p>","answer":"<ul>\n<li><code>DoubleToIntFunction</code> - операция принимающая аргумент класса <code>Double</code> и возвращающая результат типа <code>Integer</code>;</li>\n<li><code>DoubleToLongFunction</code> - операция принимающая аргумент класса <code>Double</code> и возвращающая результат типа <code>Long</code>;</li>\n<li><code>IntToDoubleFunction</code> - операция принимающая аргумент класса <code>Integer</code> и возвращающая результат типа <code>Double</code>;</li>\n<li><code>IntToLongFunction</code> - операция принимающая аргумент класса <code>Integer</code> и возвращающая результат типа <code>Long</code>;</li>\n<li><code>LongToDoubleFunction</code> - операция принимающая аргумент класса <code>Long</code> и возвращающая результат типа <code>Double</code>;</li>\n<li><code>LongToIntFunction</code> - операция принимающая аргумент класса <code>Long</code> и возвращающая результат типа <code>Integer</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-todoublebifunctiontu-tointbifunctiontu-и-tolongbifunctiontu","title":"<p>Для чего нужны функциональные интерфейсы <code>ToDoubleBiFunction&lt;T,U&gt;</code>, <code>ToIntBiFunction&lt;T,U&gt;</code> и <code>ToLongBiFunction&lt;T,U&gt;</code>?</p>","answer":"<ul>\n<li><code>ToDoubleBiFunction&lt;T,U&gt;</code> - операция принимающая два аргумента классов <code>T</code> и <code>U</code> и возвращающая результат типа <code>Double</code>;</li>\n<li><code>ToLongBiFunction&lt;T,U&gt;</code> - операция принимающая два аргумента классов <code>T</code> и <code>U</code> и возвращающая результат типа <code>Long</code>;</li>\n<li><code>ToIntBiFunction&lt;T,U&gt;</code>  - операция принимающая два аргумента классов <code>T</code> и <code>U</code> и возвращающая результат типа <code>Integer</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-todoublefunctiont-tointfunctiont-и-tolongfunctiont","title":"<p>Для чего нужны функциональные интерфейсы <code>ToDoubleFunction&lt;T&gt;</code>, <code>ToIntFunction&lt;T&gt;</code> и <code>ToLongFunction&lt;T&gt;</code>?</p>","answer":"<ul>\n<li><code>ToDoubleFunction&lt;T&gt;</code> - операция принимающая аргумент класса <code>T</code> и возвращающая результат типа <code>Double</code>;</li>\n<li><code>ToLongFunction&lt;T&gt;</code> - операция принимающая аргумент класса <code>T</code> и возвращающая результат типа <code>Long</code>;</li>\n<li><code>ToIntFunction&lt;T&gt;</code> - операция принимающая аргумент класса <code>T</code> и возвращающая результат типа <code>Integer</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужны-функциональные-интерфейсы-objdoubleconsumert-objintconsumert-и-objlongconsumert","title":"<p>Для чего нужны функциональные интерфейсы <code>ObjDoubleConsumer&lt;T&gt;</code>, <code>ObjIntConsumer&lt;T&gt;</code> и <code>ObjLongConsumer&lt;T&gt;</code>?</p>","answer":"<ul>\n<li><code>ObjDoubleConsumer&lt;T&gt;</code> - операция, которая принимает два аргумента классов <code>T</code> и <code>Double</code>, производит с ними некоторое действие и ничего не возвращает;</li>\n<li><code>ObjLongConsumer&lt;T&gt;</code> - операция, которая принимает два аргумента классов <code>T</code> и <code>Long</code>, производит с ними некоторое действие и ничего не возвращает;</li>\n<li><code>ObjIntConsumer&lt;T&gt;</code> - операция, которая принимает два аргумента классов <code>T</code> и <code>Integer</code>, производит с ними некоторое действие и ничего не возвращает.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#что-такое-stringjoiner","title":"<p>Что такое <code>StringJoiner</code>?</p>","answer":"<p>Класс <code>StringJoiner</code> используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:</p>\n<pre><code class=\"java language-java\">StringJoiner joiner = new StringJoiner(\".\", \"prefix-\", \"-suffix\");\nfor (String s : \"Hello the brave world\".split(\" \")) {\n    joiner.add(s);\n}\nSystem.out.println(joiner); //prefix-Hello.the.brave.world-suffix\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-default-методы-интерфейса","title":"<p>Что такое <code>default</code> методы интерфейса?</p>","answer":"<p>Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово <code>default</code>:</p>\n<pre><code class=\"java language-java\">interface Example {\n    int process(int a);\n    default void show() {\n        System.out.println(\"default show()\");\n    }\n}\n</code></pre>\n<ul>\n<li>Если класс реализует интерфейс, он может, но не обязан, реализовать методы по умолчанию, уже реализованные в интерфейсе. Класс наследует реализацию по умолчанию.</li>\n<li>Если некий класс реализует несколько интерфейсов, которые имеют одинаковый метод по умолчанию, то класс должен реализовать метод с совпадающей сигнатурой самостоятельно. Ситуация аналогична, если один интерфейс имеет метод по умолчанию, а в другом этот же метод является абстрактным - никакой реализации по умолчанию классом не наследуется.</li>\n<li>Метод по умолчанию не может переопределить метод класса <code>java.lang.Object</code>.</li>\n<li>Помогают реализовывать интерфейсы без страха нарушить работу других классов.</li>\n<li>Позволяют избежать создания служебных классов, так как все необходимые методы могут быть представлены в самих интерфейсах.</li>\n<li>Дают свободу классам выбрать метод, который нужно переопределить.</li>\n<li>Одной из основных причин внедрения методов по умолчанию является возможность коллекций в Java 8 использовать лямбда-выражения.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#как-вызывать-default-метод-интерфейса-в-реализующем-этот-интерфейс-классе","title":"<p>Как вызывать <code>default</code> метод интерфейса в реализующем этот интерфейс классе?</p>","answer":"<p>Используя ключевое слово <code>super</code> вместе с именем интерфейса:</p>\n<pre><code class=\"java language-java\">interface Paper {\n    default void show() {\n        System.out.println(\"default show()\");\n    }\n}\n\nclass Licence implements Paper {\n    public void show() {\n        Paper.super.show();\n    }\n}\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-static-метод-интерфейса","title":"<p>Что такое <code>static</code> метод интерфейса?</p>","answer":"<p>Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.</p>\n<ul>\n<li>Статические методы в интерфейсе являются частью интерфейса без возможности использовать их для объектов класса реализации;</li>\n<li>Методы класса <code>java.lang.Object</code> нельзя переопределить как статические;</li>\n<li>Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на null, сортировки коллекций и т.д.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#как-вызывать-static-метод-интерфейса","title":"<p>Как вызывать <code>static</code> метод интерфейса?</p>","answer":"<p>Используя имя интерфейса:</p>\n<pre><code class=\"java language-java\">interface Paper {\n    static void show() {\n        System.out.println(\"static show()\");\n    }\n}\n\nclass Licence {\n    public void showPaper() {\n        Paper.show();\n    }\n}\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-optional","title":"<p>Что такое <code>Optional</code>?</p>","answer":"<p>Опциональное значение <code>Optional</code> — это контейнер для объекта, который может содержать или не содержать значение <code>null</code>. Такая обёртка является удобным средством предотвращения <code>NullPointerException</code>, т.к.\nимеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся <code>if null/notNull</code> проверок:</p>\n<pre><code class=\"java language-java\">Optional&lt;String&gt; optional = Optional.of(\"hello\");\n\noptional.isPresent(); // true\noptional.ifPresent(s -&gt; System.out.println(s.length())); // 5\noptional.get(); // \"hello\"\noptional.orElse(\"ops...\"); // \"hello\"\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-stream","title":"<p>Что такое <code>Stream</code>?</p>","answer":"<p>Интерфейс <code>java.util.Stream</code> представляет собой последовательность элементов, над которой можно производить различные операции.</p>\n<p>Операции над стримами бывают или <em>промежуточными (intermediate)</em> или <em>конечными (terminal)</em>. Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить цепочки из несколько операций над одним и тем же стримом.</p>\n<p>У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не происходит (похоже на создание объекта <code>Thread</code> или <code>Runnable</code>, без вызова <code>start()</code>).</p>\n<p>Стримы создаются на основе источников каких-либо, например классов из <code>java.util.Collection</code>.</p>\n<p>Ассоциативные массивы (maps), например, <code>HashMap</code>, не поддерживаются.</p>\n<p>Операции над стримами могут выполняться как последовательно, так и параллельно.</p>\n<p>Потоки не могут быть использованы повторно. Как только была вызвана какая-нибудь конечная операция, поток закрывается.</p>\n<p>Кроме универсальных объектных существуют особые виды стримов для работы с примитивными типами данных <code>int</code>, <code>long</code> и <code>double</code>: <code>IntStream</code>, <code>LongStream</code> и <code>DoubleStream</code>. Эти примитивные стримы работают так же, как и обычные объектные, но со следующими отличиями:</p>\n<ul>\n<li>используют специализированные лямбда-выражения, например, <code>IntFunction</code> или <code>IntPredicate</code> вместо <code>Function</code> и <code>Predicate</code>;</li>\n<li>поддерживают дополнительные конечные операции <code>sum()</code>, <code>average()</code>, <code>mapToObj()</code>.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#какие-существуют-способы-создания-стрима","title":"<p>Какие существуют способы создания стрима?</p>","answer":"<ol>\n<li>Из коллекции:</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromCollection = Arrays.asList(\"x\", \"y\", \"z\").stream();\n</code></pre>\n<ol start=\"2\">\n<li>Из набора значений:</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromValues = Stream.of(\"x\", \"y\", \"z\");\n</code></pre>\n<ol start=\"3\">\n<li>Из массива:</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromArray = Arrays.stream(new String[]{\"x\", \"y\", \"z\"});\n</code></pre>\n<ol start=\"4\">\n<li>Из файла (каждая строка в файле будет отдельным элементом в стриме):</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromFile = Files.lines(Paths.get(\"input.txt\"));\n</code></pre>\n<ol start=\"5\">\n<li>Из строки:</li>\n</ol>\n<pre><code class=\"java language-java\">IntStream fromString = \"0123456789\".chars();\n</code></pre>\n<ol start=\"6\">\n<li>С помощью <code>Stream.builder()</code>:</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromBuilder = Stream.builder().add(\"z\").add(\"y\").add(\"z\").build();\n</code></pre>\n<ol start=\"7\">\n<li>С помощью <code>Stream.iterate()</code> (бесконечный):</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;Integer&gt; fromIterate = Stream.iterate(1, n -&gt; n + 1);\n</code></pre>\n<ol start=\"8\">\n<li>С помощью <code>Stream.generate()</code> (бесконечный):</li>\n</ol>\n<pre><code class=\"java language-java\">Stream&lt;String&gt; fromGenerate = Stream.generate(() -&gt; \"0\");\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#в-чем-разница-между-collection-и-stream","title":"<p>В чем разница между <code>Collection</code> и <code>Stream</code>?</p>","answer":"<p>Коллекции позволяют работать с элементами по отдельности, тогда как стримы так делать не позволяют, но вместо этого предоставляют возможность выполнять функции над данными как над одним целым.</p>\n<p>Также стоит отметить важность самой концепции сущностей: <code>Collection</code> - это прежде всего воплощение <em>Структуры Данных</em>. Например, <code>Set</code> не просто хранит в себе элементы, он реализует идею множества с уникальными элементами,\nтогда как <code>Stream</code>, это прежде всего абстракция необходимая для реализации <em>конвейера вычислений</em>, собственно поэтому, результатом работы конвейера являются те или иные <em>Структуры Данных</em> или же результаты проверок/поиска и т.п.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-нужен-метод-collect-в-стримах","title":"<p>Для чего нужен метод <code>collect()</code> в стримах?</p>","answer":"<p>Метод <code>collect()</code> является конечной операцией, которая используется для представление результата в виде коллекции или какой-либо другой структуры данных.</p>\n<p><code>collect()</code> принимает на вход <code>Collector&lt;Тип_источника, Тип_аккумулятора, Тип_результата&gt;</code>, который содержит четыре этапа: <em>supplier</em> - инициализация аккумулятора, <em>accumulator</em> - обработка каждого элемента, <em>combiner</em> - соединение двух аккумуляторов при параллельном выполнении, <em>[finisher]</em> - необязательный метод последней обработки аккумулятора. В Java 8 в классе <code>Collectors</code> реализовано несколько распространённых коллекторов:</p>\n<ul>\n<li><code>toList()</code>, <code>toCollection()</code>, <code>toSet()</code> - представляют стрим в виде списка, коллекции или множества;</li>\n<li><code>toConcurrentMap()</code>, <code>toMap()</code> - позволяют преобразовать стрим в <code>Mindmap</code>;</li>\n<li><code>averagingInt()</code>, <code>averagingDouble()</code>, <code>averagingLong()</code> - возвращают среднее значение;</li>\n<li><code>summingInt()</code>, <code>summingDouble()</code>, <code>summingLong()</code> - возвращает сумму;</li>\n<li><code>summarizingInt()</code>, <code>summarizingDouble()</code>, <code>summarizingLong()</code> - возвращают <code>SummaryStatistics</code> с разными агрегатными значениями;</li>\n<li><code>partitioningBy()</code> - разделяет коллекцию на две части по соответствию условию и возвращает их как <code>Mindmap&lt;Boolean, List&gt;</code>;</li>\n<li><code>groupingBy()</code> - разделяет коллекцию на несколько частей и возвращает <code>Mindmap&lt;N, List&lt;T&gt;&gt;</code>;</li>\n<li><code>mapping()</code> - дополнительные преобразования значений для сложных <code>Collector</code>.</li>\n</ul>\n<p>Так же существует возможность создания собственного коллектора через <code>Collector.of()</code>:</p>\n<pre><code class=\"java language-java\">Collector&lt;String, List&lt;String&gt;, List&lt;String&gt;&gt; toList = Collector.of(\n    ArrayList::new,\n    List::add,\n    (l1, l2) -&gt; { l1.addAll(l2); return l1; }\n);\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#для-чего-в-стримах-применяются-методы-foreach-и-foreachordered","title":"<p>Для чего в стримах применяются методы <code>forEach()</code> и <code>forEachOrdered()</code>?</p>","answer":"<ul>\n<li><code>forEach()</code> применяет функцию к каждому объекту стрима, порядок при параллельном выполнении не гарантируется;</li>\n<li><code>forEachOrdered()</code> применяет функцию к каждому объекту стрима с сохранением порядка элементов.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#для-чего-в-стримах-предназначены-методы-map-и-maptoint-maptodouble-maptolong","title":"<p>Для чего в стримах предназначены методы <code>map()</code> и <code>mapToInt()</code>, <code>mapToDouble()</code>, <code>mapToLong()</code>?</p>","answer":"<p>Метод <code>map()</code> является промежуточной операцией, которая заданным образом преобразует каждый элемент стрима.</p>\n<p><code>mapToInt()</code>, <code>mapToDouble()</code>, <code>mapToLong()</code> - аналоги <code>map()</code>, возвращающие соответствующий числовой стрим (то есть стрим из числовых примитивов):</p>\n<pre><code class=\"java language-java\">Stream\n    .of(\"12\", \"22\", \"4\", \"444\", \"123\")\n    .mapToInt(Integer::parseInt)\n    .toArray(); //[12, 22, 4, 444, 123]\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#какова-цель-метода-filter-в-стримах","title":"<p>Какова цель метода <code>filter()</code> в стримах?</p>","answer":"<p>Метод <code>filter()</code> является промежуточной операцией принимающей предикат, который фильтрует все элементы, возвращая только те, что соответствуют условию.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-в-стримах-предназначен-метод-limit","title":"<p>Для чего в стримах предназначен метод <code>limit()</code>?</p>","answer":"<p>Метод <code>limit()</code> является промежуточной операцией, которая позволяет ограничить выборку определенным количеством первых элементов.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-в-стримах-предназначен-метод-sorted","title":"<p>Для чего в стримах предназначен метод <code>sorted()</code>?</p>","answer":"<p>Метод <code>sorted()</code> является промежуточной операцией, которая позволяет сортировать значения либо в натуральном порядке, либо задавая <code>Comparator</code>.</p>\n<p>Порядок элементов в исходной коллекции остается нетронутым - <code>sorted()</code> всего лишь создает его отсортированное представление.</p>"},{"subject":"Java 8","url":"006-java8.html#для-чего-в-стримах-предназначены-методы-flatmap-flatmaptoint-flatmaptodouble-flatmaptolong","title":"<p>Для чего в стримах предназначены методы <code>flatMap()</code>, <code>flatMapToInt()</code>, <code>flatMapToDouble()</code>, <code>flatMapToLong()</code>?</p>","answer":"<p>Метод <code>flatMap()</code> похож на map, но может создавать из одного элемента несколько. Таким образом, каждый объект будет преобразован в ноль, один или несколько других объектов, поддерживаемых потоком.  Наиболее очевидный способ применения этой операции — преобразование элементов контейнера при помощи функций, которые возвращают контейнеры.</p>\n<pre><code class=\"java language-java\">Stream\n    .of(\"H e l l o\", \"w o r l d !\")\n    .flatMap((p) -&gt; Arrays.stream(p.split(\" \")))\n    .toArray(String[]::new);//[\"H\", \"e\", \"l\", \"l\", \"o\", \"w\", \"o\", \"r\", \"l\", \"d\", \"!\"]\n</code></pre>\n<p><code>flatMapToInt()</code>, <code>flatMapToDouble()</code>, <code>flatMapToLong()</code> - это аналоги <code>flatMap()</code>, возвращающие соответствующий\nчисловой стрим.</p>"},{"subject":"Java 8","url":"006-java8.html#расскажите-о-параллельной-обработке-в-java-8","title":"<p>Расскажите о параллельной обработке в Java 8</p>","answer":"<p>Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке\nпроцессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют\nобщий <code>ForkJoinPool</code> доступный через статический <code>ForkJoinPool.commonPool()</code> метод. При этом, если окружение не является\nмногоядерным, то поток будет выполняться как последовательный. Фактически применение параллельных стримов сводится к\nтому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре процессора, и в конце\nэти части соединяются, и над ними выполняются конечные операции.</p>\n<p>Для создания параллельного потока из коллекции можно также использовать метод <code>parallelStream()</code>\nинтерфейса <code>Collection</code>.</p>\n<p>Чтобы сделать обычный последовательный стрим параллельным, надо вызвать у объекта <code>Stream</code> метод <code>parallel()</code>.\nМетод <code>isParallel()</code> позволяет узнать является ли стрим параллельным.</p>\n<p>С помощью, методов <code>parallel()</code> и <code>sequential()</code> можно определять какие операции могут быть параллельными, а какие\nтолько последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот:</p>\n<pre><code class=\"java language-java\">collection\n.stream()\n.peek(...) // операция последовательна\n.parallel()\n.map(...) // операция может выполняться параллельно,\n.sequential()\n.reduce(...) // операция снова последовательна\n</code></pre>\n<p>Как правило, элементы передаются в стрим в том же порядке, в котором они определены в источнике данных. При работе с параллельными стримами система сохраняет порядок следования элементов. Исключение составляет метод <code>forEach()</code>, который может выводить элементы в произвольном порядке. И чтобы сохранить порядок следования, необходимо применять метод <code>forEachOrdered()</code>.</p>\n<p>Критерии, которые могут повлиять на производительность в параллельных стримах:</p>\n<ul>\n<li>Размер данных - чем больше данных, тем сложнее сначала разделять данные, а потом их соединять.</li>\n<li>Количество ядер процессора. Теоретически, чем больше ядер в компьютере, тем быстрее программа будет работать. Если на машине одно ядро, нет смысла применять параллельные потоки.</li>\n<li>Чем проще структура данных, с которой работает поток, тем быстрее будут происходить операции. Например, данные из <code>ArrayList</code> легко использовать, так как структура данной коллекции предполагает последовательность несвязанных данных. А вот коллекция типа <code>LinkedList</code> - не лучший вариант, так как в последовательном списке все элементы связаны с предыдущими/последующими. И такие данные трудно распараллелить.</li>\n<li>Над данными примитивных типов операции будут производиться быстрее, чем над объектами классов.</li>\n<li>Крайне не рекомендуется использовать параллельные стримы для долгих операций (например сетевых соединений), так как все параллельные стримы работают c одним <code>ForkJoinPool</code>, то такие долгие операции могут остановить работу всех параллельных стримов в JVM из-за отсутствия доступных потоков в пуле, т.е. параллельные стримы стоит использовать лишь для коротких операций, где счет идет на миллисекунды, но не для тех где счет может идти на секунды и минуты;</li>\n<li>Сохранение порядка в параллельных стримах увеличивает издержки при выполнении и если порядок не важен, то имеется возможность отключить его сохранение и тем самым увеличить производительность, использовав промежуточную операцию <code>unordered()</code>:</li>\n</ul>\n<pre><code class=\"java language-java\">collection.parallelStream()\n    .sorted()\n    .unordered()\n    .collect(Collectors.toList());\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#какие-конечные-методы-работы-со-стримами-вы-знаете","title":"<p>Какие конечные методы работы со стримами вы знаете?</p>","answer":"<ul>\n<li><code>findFirst()</code> возвращает первый элемент;</li>\n<li><code>findAny()</code> возвращает любой подходящий элемент;</li>\n<li><code>collect()</code> представление результатов в виде коллекций и других структур данных;</li>\n<li><code>count()</code> возвращает количество элементов;</li>\n<li><code>anyMatch()</code> возвращает <code>true</code>, если условие выполняется хотя бы для одного элемента;</li>\n<li><code>noneMatch()</code> возвращает <code>true</code>, если условие не выполняется ни для одного элемента;</li>\n<li><code>allMatch()</code> возвращает <code>true</code>, если условие выполняется для всех элементов;</li>\n<li><code>min()</code> возвращает минимальный элемент, используя в качестве условия <code>Comparator</code>;</li>\n<li><code>max()</code> возвращает максимальный элемент, используя в качестве условия <code>Comparator</code>;</li>\n<li><code>forEach()</code> применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);</li>\n<li><code>forEachOrdered()</code> применяет функцию к каждому объекту с сохранением порядка элементов;</li>\n<li><code>toArray()</code> возвращает массив значений;</li>\n<li><code>reduce()</code>позволяет выполнять агрегатные функции и возвращать один результат.</li>\n</ul>\n<p>Для числовых стримов дополнительно доступны:</p>\n<ul>\n<li><code>sum()</code> возвращает сумму всех чисел;</li>\n<li><code>average()</code> возвращает среднее арифметическое всех чисел.</li>\n</ul>"},{"subject":"Java 8","url":"006-java8.html#какие-промежуточные-методы-работы-со-стримами-вы-знаете","title":"<p>Какие промежуточные методы работы со стримами вы знаете?</p>","answer":"<ul>\n<li><code>filter()</code> отфильтровывает записи, возвращая только записи, соответствующие условию;</li>\n<li><code>skip()</code> позволяет пропустить определённое количество элементов в начале;</li>\n<li><code>distinct()</code> возвращает стрим без дубликатов (для метода <code>equals()</code>);</li>\n<li><code>map()</code> преобразует каждый элемент;</li>\n<li><code>peek()</code> возвращает тот же стрим, применяя к каждому элементу функцию;</li>\n<li><code>limit()</code> позволяет ограничить выборку определенным количеством первых элементов;</li>\n<li><code>sorted()</code> позволяет сортировать значения либо в натуральном порядке, либо задавая <code>Comparator</code>;</li>\n<li><code>mapToInt()</code>, <code>mapToDouble()</code>, <code>mapToLong()</code> - аналоги <code>map()</code> возвращающие стрим числовых примитивов;</li>\n<li><code>flatMap()</code>, <code>flatMapToInt()</code>, <code>flatMapToDouble()</code>, <code>flatMapToLong()</code> - похожи на <code>map()</code>, но могут создавать из одного элемента несколько.</li>\n</ul>\n<p>Для числовых стримов дополнительно доступен метод <code>mapToObj()</code>, который преобразует числовой стрим обратно в объектный.</p>"},{"subject":"Java 8","url":"006-java8.html#как-вывести-на-экран-10-случайных-чисел-используя-foreach","title":"<p>Как вывести на экран 10 случайных чисел, используя <code>forEach()</code>?</p>","answer":"<pre><code class=\"java language-java\">(new Random())\n    .ints()\n    .limit(10)\n    .forEach(System.out::println);\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-можно-вывести-на-экран-уникальные-квадраты-чисел-используя-метод-map","title":"<p>Как можно вывести на экран уникальные квадраты чисел используя метод <code>map()</code>?</p>","answer":"<pre><code class=\"java language-java\">Stream\n    .of(1, 2, 3, 2, 1)\n    .map(s -&gt; s * s)\n    .distinct()\n    .forEach(System.out::println);\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-вывести-на-экран-количество-пустых-строк-с-помощью-метода-filter","title":"<p>Как вывести на экран количество пустых строк с помощью метода <code>filter()</code>?</p>","answer":"<pre><code class=\"java language-java\">System.out.println(\n    Stream\n        .of(\"Hello\", \"\", \", \", \"world\", \"!\")\n        .filter(String::isEmpty)\n        .count());\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-вывести-на-экран-10-случайных-чисел-в-порядке-возрастания","title":"<p>Как вывести на экран 10 случайных чисел в порядке возрастания?</p>","answer":"<pre><code class=\"java language-java\">(new Random())\n    .ints()\n    .limit(10)\n    .sorted()\n    .forEach(System.out::println);\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-найти-максимальное-число-в-наборе","title":"<p>Как найти максимальное число в наборе?</p>","answer":"<pre><code class=\"java language-java\">Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -&gt; a)\n    .max()\n    .getAsInt(); //55\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-найти-минимальное-число-в-наборе","title":"<p>Как найти минимальное число в наборе?</p>","answer":"<pre><code class=\"java language-java\">Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -&gt; a)\n    .min()\n    .getAsInt(); //2\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-сумму-всех-чисел-в-наборе","title":"<p>Как получить сумму всех чисел в наборе?</p>","answer":"<pre><code class=\"java language-java\">Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt()\n    .sum(); //69\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-среднее-значение-всех-чисел","title":"<p>Как получить среднее значение всех чисел?</p>","answer":"<pre><code class=\"java language-java\">Stream\n    .of(5, 3, 4, 55, 2)\n    .mapToInt(a -&gt; a)\n    .average()\n    .getAsDouble(); //13.8\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#какие-дополнительные-методы-для-работы-с-ассоциативными-массивами-maps-появились-в-java-8","title":"<p>Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?</p>","answer":"<ul>\n<li><code>putIfAbsent()</code> добавляет пару «ключ-значение», только если ключ отсутствовал:</li>\n</ul>\n<p><code>map.putIfAbsent(\"a\", \"Aa\");</code></p>\n<ul>\n<li><code>forEach()</code> принимает функцию, которая производит операцию над каждым элементом:</li>\n</ul>\n<p><code>map.forEach((k, v) -&gt; System.out.println(v));</code></p>\n<ul>\n<li><code>compute()</code> создаёт или обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):</li>\n</ul>\n<p><code>map.compute(\"a\", (k, v) -&gt; String.valueOf(k).concat(v)); //[\"a\", \"aAa\"]</code></p>\n<ul>\n<li><code>computeIfPresent()</code> если ключ существует, обновляет текущее значение на полученное в результате вычисления (возможно использовать ключ и текущее значение):</li>\n</ul>\n<p><code>map.computeIfPresent(\"a\", (k, v) -&gt; k.concat(v));</code></p>\n<ul>\n<li><code>computeIfAbsent()</code> если ключ отсутствует, создаёт его со значением, которое вычисляется (возможно использовать ключ):</li>\n</ul>\n<p><code>map.computeIfAbsent(\"a\", k -&gt; \"A\".concat(k)); //[\"a\",\"Aa\"]</code></p>\n<ul>\n<li><code>getOrDefault()</code> в случае отсутствия ключа, возвращает переданное значение по умолчанию:</li>\n</ul>\n<p><code>map.getOrDefault(\"a\", \"not found\");</code></p>\n<ul>\n<li><code>merge()</code> принимает ключ, значение и функцию, которая объединяет передаваемое и текущее значения. Если под заданным ключом значение отсутствует, то записывает туда передаваемое значение.</li>\n</ul>\n<p><code>map.merge(\"a\", \"z\", (value, newValue) -&gt; value.concat(newValue)); //[\"a\",\"Aaz\"]</code></p>"},{"subject":"Java 8","url":"006-java8.html#что-такое-spliterator","title":"<p>Что такое <code>Spliterator</code>?</p>","answer":"<p><code>Spliterator</code> (Сплитератор) — это интерфейс, который содержит 8 методов, причём четыре из них уже имеют реализацию по умолчанию. Оставшиеся методы — это tryAdvance, trySplit, estimateSize и characteristics. Существуют также специальные модификации сплитератора для примитивных типов int, long и double: они добавляют несколько дополнительных методов, чтобы избежать упаковки (boxing). <code>Spliterator</code> похож на обычный итератор. Основное отличие — умение разделиться (split) на две части — лежит в основе параллельной работы потоков. Также в целях оптимизации сплитератор имеет ряд флагов-характеристик и может сообщить точно или приблизительно свой размер. Наконец, сплитератор никогда не модифицирует источник данных: у него нет метода remove как у итератора.</p>"},{"subject":"Java 8","url":"006-java8.html#что-такое-localdatetime","title":"<p>Что такое <code>LocalDateTime</code>?</p>","answer":"<p><code>LocalDateTime</code> объединяет вместе <code>LocaleDate</code> и <code>LocalTime</code>, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.</p>"},{"subject":"Java 8","url":"006-java8.html#что-такое-zoneddatetime","title":"<p>Что такое <code>ZonedDateTime</code>?</p>","answer":"<p><code>java.time.ZonedDateTime</code> — аналог <code>java.util.Calendar</code>, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает временную зону, поэтому все операции с временными сдвигами этот класс проводит с её учётом.</p>"},{"subject":"Java 8","url":"006-java8.html#как-получить-текущую-дату-с-использованием-date-time-api-из-java-8","title":"<p>Как получить текущую дату с использованием Date Time API из Java 8?</p>","answer":"<pre><code class=\"java language-java\">LocalDate.now();\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-добавить-1-неделю-1-месяц-1-год-10-лет-к-текущей-дате-с-использованием-date-time-api","title":"<p>Как добавить 1 неделю, 1 месяц, 1 год, 10 лет к текущей дате с использованием Date Time API?</p>","answer":"<pre><code class=\"java language-java\">LocalDate.now().plusWeeks(1);\nLocalDate.now().plusMonths(1);\nLocalDate.now().plusYears(1);\nLocalDate.now().plus(1, ChronoUnit.DECADES);\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-следующий-вторник-используя-date-time-api","title":"<p>Как получить следующий вторник используя Date Time API?</p>","answer":"<pre><code class=\"java language-java\">LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.TUESDAY));\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-вторую-субботу-текущего-месяца-используя-date-time-api","title":"<p>Как получить вторую субботу текущего месяца используя Date Time API?</p>","answer":"<pre><code class=\"java language-java\">LocalDate\n    .of(LocalDate.now().getYear(), LocalDate.now().getMonth(), 1)\n    .with(TemporalAdjusters.nextOrSame(DayOfWeek.SATURDAY))\n    .with(TemporalAdjusters.next(DayOfWeek.SATURDAY));\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-текущее-время-с-точностью-до-миллисекунд-используя-date-time-api","title":"<p>Как получить текущее время с точностью до миллисекунд используя Date Time API?</p>","answer":"<pre><code class=\"java language-java\">new Date().toInstant();\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-получить-текущее-время-по-местному-времени-с-точностью-до-миллисекунд-используя-date-time-api","title":"<p>Как получить текущее время по местному времени с точностью до миллисекунд используя Date Time API?</p>","answer":"<pre><code class=\"java language-java\">LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#как-определить-повторяемую-аннотацию","title":"<p>Как определить повторяемую аннотацию?</p>","answer":"<p>Чтобы определить повторяемую аннотацию, необходимо создать аннотацию-контейнер для списка повторяемых аннотаций и обозначить повторяемую мета-аннотацией <code>@Repeatable</code>:</p>\n<pre><code class=\"java language-java\">@interface Schedulers\n{\n    Scheduler[] value();\n}\n\n@Repeatable(Schedulers.class)\n@interface Scheduler\n{\n    String birthday() default \"Jan 8 1935\";\n}\n</code></pre>"},{"subject":"Java 8","url":"006-java8.html#что-такое-nashorn","title":"<p>Что такое <code>Nashorn</code>?</p>","answer":"<p><strong>Nashorn</strong> - это движок JavaScript, разрабатываемый на Java компанией Oracle. Призван дать возможность встраивать код JavaScript в приложения Java. В сравнении с <em>Rhino</em>, который поддерживается Mozilla Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую производительность, так как он компилирует код и передает байт-код виртуальной машине Java непосредственно в памяти. Nashorn умеет компилировать код JavaScript и генерировать классы Java, которые загружаются специальным загрузчиком. Так же возможен вызов кода Java прямо из JavaScript.</p>"},{"subject":"Java 8","url":"006-java8.html#что-такое-jjs","title":"<p>Что такое <code>jjs</code>?</p>","answer":"<p><code>jjs</code> это утилита командной строки, которая позволяет исполнять программы на языке JavaScript прямо в консоли.</p>"},{"subject":"Java 8","url":"006-java8.html#какой-класс-появился-в-java-8-для-кодированиядекодирования-данных","title":"<p>Какой класс появился в Java 8 для кодирования/декодирования данных?</p>","answer":"<p><code>Base64</code> - потокобезопасный класс, который реализует кодировщик и декодировщик данных, используя схему кодирования base64 согласно <em>RFC 4648</em> и <em>RFC 2045</em>.</p>\n<p>Base64 содержит 6 основных методов:</p>\n<p><code>getEncoder()</code>/<code>getDecoder()</code> - возвращает кодировщик/декодировщик base64, соответствующий стандарту <em>RFC 4648</em>;\n<code>getUrlEncoder()</code>/<code>getUrlDecoder()</code> - возвращает URL-safe кодировщик/декодировщик base64, соответствующий стандарту <em>RFC 4648</em>;\n<code>getMimeEncoder()</code>/<code>getMimeDecoder()</code> - возвращает MIME кодировщик/декодировщик, соответствующий стандарту <em>RFC 2045</em>.</p>"},{"subject":"Java 8","url":"006-java8.html#как-создать-base64-кодировщик-и-декодировщик","title":"<p>Как создать Base64 кодировщик и декодировщик?</p>","answer":"<pre><code class=\"java language-java\">// Encode\nString b64 = Base64.getEncoder().encodeToString(\"input\".getBytes(\"utf-8\")); //aW5wdXQ==\n// Decode\nnew String(Base64.getDecoder().decode(\"aW5wdXQ==\"), \"utf-8\"); //input\n</code></pre>\n<p><a href=\"#java-8\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://habrahabr.ru/post/216431/\">Хабрахабр - Новое в Java 8</a></li>\n<li><a href=\"https://habrahabr.ru/company/luxoft/blog/270383/\">Хабрахабр - Шпаргалка Java программиста 4. Java Stream API</a></li>\n<li><a href=\"http://metanit.com/java/tutorial/9.1.php\">METANIT.COM</a></li>\n<li><a href=\"http://javadevblog.com/interfejsy-v-java-8-staticheskie-metody-metody-po-umolchaniyu-funktsional-ny-e-interfejsy.html\">javadevblog.com</a></li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#в-чём-заключается-разница-между-io-и-nio","title":"<p>В чём заключается разница между IO и NIO?</p>","answer":"<ul>\n<li>Java IO (input-output) является потокоориентированным, а Java NIO (new/non-blocking io) – буфер-ориентированным. Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. В Java NIO данные сначала считываются в буфер, что дает больше гибкости при обработке данных.</li>\n<li>Потоки ввода/вывода в Java IO являются блокирующими. Это значит, что когда в потоке выполнения вызывается <code>read()</code> или <code>write()</code> метод любого класса из пакета <code>java.io.*</code>, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого. Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим. Тоже самое справедливо и для неблокирующего вывода. Поток выполнения может запросить запись в канал некоторых данных, но не дожидаться при этом пока они не будут полностью записаны.</li>\n<li>В Java NIO имеются селекторы, которые позволяют одному потоку выполнения мониторить несколько каналов ввода. Т.е. существует возможность зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-особенности-nio-вы-знаете","title":"<p>Какие особенности NIO вы знаете?</p>","answer":"<ul>\n<li><strong>Каналы и селекторы</strong>: NIO поддерживает различные типы каналов. Канал является абстракцией объектов более низкого уровня файловой системы (например, отображенные в памяти файлы и блокировки файлов), что позволяет передавать данные с более высокой скоростью. Каналы не блокируются и поэтому Java предоставляет еще такие инструменты, как селектор, который позволяет выбрать готовый канал для передачи данных, и сокет, который является инструментом для блокировки.</li>\n<li><strong>Буферы</strong>: имеет буферизация для всех классов-обёрток примитивов (кроме Boolean). Появился абстрактный класс Buffer, который предоставляет такие операции, как clear, flip, mark и т.д. Его подклассы предоставляют методы для получения и установки данных.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#что-такое-каналы","title":"<p>Что такое <em>«каналы»</em>?</p>","answer":"<p>Каналы (channels) – это логические (не физические) порталы, абстракции объектов более низкого уровня файловой системы (\nнапример, отображенные в памяти файлы и блокировки файлов), через которые осуществляется ввод/вывод данных, а буферы\nявляются источниками или приёмниками этих переданных данных. При организации вывода, данные, которые необходимо\nотправить, помещаются в буфер, который затем передается в канал. При вводе, данные из канала помещаются в заранее\nпредоставленный буфер.</p>\n<p>Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту\nсторону каналов. Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с\nминимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема\nданных.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-существуют-виды-потоков-вводавывода","title":"<p>Какие существуют виды потоков ввода/вывода?</p>","answer":""},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#назовите-основные-классы-потоков-вводавывода","title":"<p>Назовите основные классы потоков ввода/вывода</p>","answer":"<p>Разделяют два вида потоков ввода/вывода:</p>\n<ul>\n<li><strong>байтовые</strong> - <code>java.io.InputStream</code>, <code>java.io.OutputStream</code>;</li>\n<li><strong>символьные</strong> - <code>java.io.Reader</code>, <code>java.io.Writer</code>.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#в-каких-пакетах-расположены-классы-потоков-вводавывода","title":"<p>В каких пакетах расположены классы потоков ввода/вывода?</p>","answer":"<p><code>java.io</code>, <code>java.nio</code>. Для работы с потоками компрессированных данных используются классы из пакета <code>java.util.zip</code></p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-подклассы-класса-inputstream-вы-знаете-для-чего-они-предназначены","title":"<p>Какие подклассы класса <code>InputStream</code> вы знаете, для чего они предназначены?</p>","answer":"<ul>\n<li><code>InputStream</code> - абстрактный класс, описывающий поток ввода;</li>\n<li><code>BufferedInputStream</code> - буферизованный входной поток;</li>\n<li><code>ByteArrayInputStream</code> позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока;</li>\n<li><code>DataInputStream</code> - входной поток для байтовых данных, включающий методы для чтения стандартных типов данных Java;</li>\n<li><code>FileInputStream</code> - входной поток для чтения информации из файла;</li>\n<li><code>FilterInputStream</code> - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;</li>\n<li><code>ObjectInputStream</code> - входной поток для объектов;</li>\n<li><code>StringBufferInputStream</code> превращает строку (<code>String</code>) во входной поток данных <code>InputStream</code>;</li>\n<li><code>PipedInputStream</code> реализует понятие входного канала;</li>\n<li><code>PushbackInputStream</code> - разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток, позволяет «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.</li>\n<li><code>SequenceInputStream</code> используется для слияния двух или более потоков <code>InputStream</code> в единый.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#для-чего-используется-pushbackinputstream","title":"<p>Для чего используется <code>PushbackInputStream</code>?</p>","answer":"<p>Разновидность буферизации, обеспечивающая чтение байта с последующим его возвратом в поток. Класс <code>PushbackInputStream</code> представляет механизм «заглянуть» во входной поток и увидеть, что оттуда поступит в следующий момент, не извлекая информации.</p>\n<p>У класса есть дополнительный метод unread().</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#для-чего-используется-sequenceinputstream","title":"<p>Для чего используется <code>SequenceInputStream</code>?</p>","answer":"<p>Класс <code>SequenceInputStream</code> позволяет сливать вместе несколько экземпляров класса <code>InputStream</code>. Конструктор принимает в качестве аргумента либо пару объектов класса <code>InputStream</code>, либо интерфейс <code>Enumeration</code>.</p>\n<p>Во время работы класс выполняет запросы на чтение из первого объекта класса <code>InputStream</code> и до конца, а затем переключается на второй. При использовании интерфейса работа продолжится по всем объектам класса <code>InputStream</code>. По достижении конца, связанный с ним поток закрывается. Закрытие потока, созданного объектом класса <code>SequenceInputStream</code>, приводит к закрытию всех открытых потоков.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какой-класс-позволяет-читать-данные-из-входного-байтового-потока-в-формате-примитивных-типов-данных","title":"<p>Какой класс позволяет читать данные из входного байтового потока в формате примитивных типов данных?</p>","answer":"<p>Класс <code>DataInputStream</code> представляет поток ввода и предназначен для записи данных примитивных типов, таких, как <code>int</code>, <code>double</code> и т.д. Для каждого примитивного типа определен свой метод для считывания:</p>\n<ul>\n<li><code>boolean readBoolean()</code>: считывает из потока булевое однобайтовое значение</li>\n<li><code>byte readByte()</code>: считывает из потока 1 байт</li>\n<li><code>char readChar()</code>: считывает из потока значение <code>char</code></li>\n<li><code>double readDouble()</code>: считывает из потока 8-байтовое значение <code>double</code></li>\n<li><code>float readFloat()</code>: считывает из потока 4-байтовое значение <code>float</code></li>\n<li><code>int readInt()</code>: считывает из потока целочисленное значение <code>int</code></li>\n<li><code>long readLong()</code>: считывает из потока значение <code>long</code></li>\n<li><code>short readShort()</code>: считывает значение <code>short</code></li>\n<li><code>String readUTF()</code>: считывает из потока строку в кодировке UTF-8</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-подклассы-класса-outputstream-вы-знаете-для-чего-они-предназначены","title":"<p>Какие подклассы класса <code>OutputStream</code> вы знаете, для чего они предназначены?</p>","answer":"<ul>\n<li><code>OutputStream</code> - это абстрактный класс, определяющий потоковый байтовый вывод;</li>\n<li><code>BufferedOutputStream</code> - буферизированный выходной поток;</li>\n<li><code>ByteArrayOutputStream</code> - все данные, посылаемые в этот поток, размещаются в предварительно созданном буфере;</li>\n<li><code>DataOutputStream</code> - выходной поток байт, включающий методы для записи стандартных типов данных Java;</li>\n<li><code>FileOutputStream</code> - запись данных в файл на физическом носителе;</li>\n<li><code>FilterOutputStream</code> - абстрактный класс, предоставляющий интерфейс для классов-надстроек, которые добавляют к существующим потокам полезные свойства;</li>\n<li><code>ObjectOutputStream</code> - выходной поток для записи объектов;</li>\n<li><code>PipedOutputStream</code> реализует понятие выходного канала;</li>\n<li><code>PrintStream</code> - выходной поток, включающий методы <code>print()</code> и <code>println()</code>.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-подклассы-класса-reader-вы-знаете-для-чего-они-предназначены","title":"<p>Какие подклассы класса <code>Reader</code> вы знаете, для чего они предназначены?</p>","answer":"<ul>\n<li><code>Reader</code> - абстрактный класс, описывающий символьный ввод;</li>\n<li><code>BufferedReader</code> - буферизованный входной символьный поток;</li>\n<li><code>CharArrayReader</code> - входной поток, который читает из символьного массива;</li>\n<li><code>FileReader</code> - входной поток, читающий файл;</li>\n<li><code>FilterReader</code> - абстрактный класс, предоставляющий интерфейс для классов-надстроек;</li>\n<li><code>InputStreamReader</code>- входной поток, транслирующий байты в символы;</li>\n<li><code>LineNumberReader</code> - входной поток, подсчитывающий строки;</li>\n<li><code>PipedReader</code> - входной канал;</li>\n<li><code>PushbackReader</code> - входной поток, позволяющий возвращать символы обратно в поток;</li>\n<li><code>StringReader</code> - входной поток, читающий из строки.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-подклассы-класса-writer-вы-знаете-для-чего-они-предназначены","title":"<p>Какие подклассы класса <code>Writer</code> вы знаете, для чего они предназначены?</p>","answer":"<ul>\n<li><code>Writer</code> - абстрактный класс, описывающий символьный вывод;</li>\n<li><code>BufferedWriter</code> - буферизованный выходной символьный поток;</li>\n<li><code>CharArrayWriter</code> - выходной поток, который пишет в символьный массив;</li>\n<li><code>FileWriter</code> - выходной поток, пишущий в файл;</li>\n<li><code>FilterWriter</code> - абстрактный класс, предоставляющий интерфейс для классов-надстроек;</li>\n<li><code>OutputStreamWriter</code> - выходной поток, транслирующий байты в символы;</li>\n<li><code>PipedWriter</code> - выходной канал;</li>\n<li><code>PrintWriter</code> - выходной поток символов, включающий методы <code>print()</code> и <code>println()</code>;</li>\n<li><code>StringWriter</code> - выходной поток, пишущий в строку;</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#в-чем-отличие-класса-printwriter-от-printstream","title":"<p>В чем отличие класса <code>PrintWriter</code> от <code>PrintStream</code>?</p>","answer":"<p>Прежде всего, в классе <code>PrintWriter</code> применен усовершенствованный способ работы с символами Unicode и другой механизм буферизации вывода: в классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод <code>print()</code> или <code>println()</code>, а при использовании класса <code>PrintWriter</code> существует возможность отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода <code>flush()</code>.</p>\n<p>Кроме того, методы класса <code>PrintWriter</code> никогда не создают исключений. Для проверки ошибок необходимо явно вызвать метод <code>checkError()</code>.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#чем-отличаются-и-что-общего-у-inputstream-outputstream-reader-writer","title":"<p>Чем отличаются и что общего у <code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code>, <code>Writer</code>?</p>","answer":"<ul>\n<li><code>InputStream</code> и его наследники - совокупность для получения байтовых данных из различных источников;</li>\n<li><code>OutputStream</code> и его наследники - набор классов определяющих потоковый байтовый вывод;</li>\n<li><code>Reader</code> и его наследники определяют потоковый ввод символов Unicode;</li>\n<li><code>Writer</code> и его наследники определяют потоковый вывод символов Unicode.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-классы-позволяют-преобразовать-байтовые-потоки-в-символьные-и-обратно","title":"<p>Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?</p>","answer":"<ul>\n<li><code>OutputStreamWriter</code> — «мост» между классом <code>OutputStream</code> и классом <code>Writer</code>. Символы, записанные в поток, преобразовываются в байты.</li>\n<li><code>InputStreamReader</code> — аналог для чтения. При помощи методов класса <code>Reader</code> читаются байты из потока <code>InputStream</code> и далее преобразуются в символы.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-классы-позволяют-ускорить-чтениезапись-за-счет-использования-буфера","title":"<p>Какие классы позволяют ускорить чтение/запись за счет использования буфера?</p>","answer":"<ul>\n<li><code>BufferedInputStream(InputStream in)</code>/<code>BufferedInputStream(InputStream in, int size)</code>,</li>\n<li><code>BufferedOutputStream(OutputStream out)</code>/<code>BufferedOutputStream(OutputStream out, int size)</code>,</li>\n<li><code>BufferedReader(Reader r)</code>/<code>BufferedReader(Reader in, int sz)</code>,</li>\n<li><code>BufferedWriter(Writer out)</code>/<code>BufferedWriter(Writer out, int sz)</code></li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какой-класс-предназначен-для-работы-с-элементами-файловой-системы","title":"<p>Какой класс предназначен для работы с элементами файловой системы?</p>","answer":"<p><code>File</code> работает непосредственно с файлами и каталогами. Данный класс позволяет создавать новые элементы и получать информацию существующих: размер, права доступа, время и дату создания, путь к родительскому каталогу.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-методы-класса-file-вы-знаете","title":"<p>Какие методы класса <code>File</code> вы знаете?</p>","answer":"<p>Наиболее используемые методы класса <code>File</code>:</p>\n<ul>\n<li><code>boolean createNewFile()</code>: делает попытку создать новый файл;</li>\n<li><code>boolean delete()</code>: делает попытку удалить каталог или файл;</li>\n<li><code>boolean mkdir()</code>: делает попытку создать новый каталог;</li>\n<li><code>boolean renameTo(File dest)</code>: делает попытку переименовать файл или каталог;</li>\n<li><code>boolean exists()</code>: проверяет, существует ли файл или каталог;</li>\n<li><code>String getAbsolutePath()</code>: возвращает абсолютный путь для пути, переданного в конструктор объекта;</li>\n<li><code>String getName()</code>: возвращает краткое имя файла или каталога;</li>\n<li><code>String getParent()</code>: возвращает имя родительского каталога;</li>\n<li><code>boolean isDirectory()</code>: возвращает значение <code>true</code>, если по указанному пути располагается каталог;</li>\n<li><code>boolean isFile()</code>: возвращает значение <code>true</code>, если по указанному пути находится файл;</li>\n<li><code>boolean isHidden()</code>: возвращает значение <code>true</code>, если каталог или файл являются скрытыми;</li>\n<li><code>long length()</code>: возвращает размер файла в байтах;</li>\n<li><code>long lastModified()</code>: возвращает время последнего изменения файла или каталога;</li>\n<li><code>String[] list()</code>: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге;</li>\n<li><code>File[] listFiles()</code>: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#что-вы-знаете-об-интерфейсе-filefilter","title":"<p>Что вы знаете об интерфейсе <code>FileFilter</code>?</p>","answer":"<p>Интерфейс <code>FileFilter</code> применяется для проверки, попадает ли объект <code>File</code> под некоторое условие. Этот интерфейс содержит единственный метод <code>boolean accept(File pathName)</code>. Этот метод необходимо переопределить и реализовать. Например:</p>\n<pre><code class=\"java language-java\">public boolean accept(final File file) {\n    return file.isExists() &amp;&amp; file.isDirectory();\n}\n</code></pre>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#как-выбрать-все-элементы-определенного-каталога-по-критерию-например-с-определенным-расширением","title":"<p>Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?</p>","answer":"<p>Метод <code>File.listFiles()</code> возвращает массив объектов <code>File</code>, содержащихся в каталоге. Метод может принимать в качестве параметра объект класса, реализующего <code>FileFilter</code>. Это позволяет включить в список только те элементы, для которых метод <code>accept</code> возвращает <code>true</code> (критерием может быть длина имени файла или его расширение).</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#что-вы-знаете-о-randomaccessfile","title":"<p>Что вы знаете о <code>RandomAccessFile</code>?</p>","answer":"<p>Класс <code>java.io.RandomAccessFile</code> обеспечивает чтение и запись данных в произвольном месте файла. Он не является частью иерархии <code>InputStream</code> или <code>OutputStream</code>. Это полностью отдельный класс, имеющий свои собственные (в большинстве своем <em>native</em>) методы. Объяснением этого может быть то, что <code>RandomAccessFile</code> имеет во многом отличающееся поведение по сравнению с остальными классами ввода/вывода так как позволяет, в пределах файла, перемещаться вперед и назад.</p>\n<p><code>RandomAccessFile</code> имеет такие специфические методы как:</p>\n<ul>\n<li><code>getFilePointer()</code> для определения текущего местоположения в файле;</li>\n<li><code>seek()</code> для перемещения на новую позицию в файле;</li>\n<li><code>length()</code> для выяснения размера файла;</li>\n<li><code>setLength()</code> для установки размера файла;</li>\n<li><code>skipBytes()</code> для того, чтобы попытаться пропустить определённое число байт;</li>\n<li><code>getChannel()</code> для работы с уникальным файловым каналом, ассоциированным с заданным файлом;</li>\n<li>методы для выполнения обычного и форматированного вывода из файла (<code>read()</code>, <code>readInt()</code>, <code>readLine()</code>, <code>readUTF()</code> и т.п.);</li>\n<li>методы для обычной или форматированной записи в файл с прямым доступом (<code>write()</code>, <code>writeBoolean()</code>, <code>writeByte()</code> и т.п.).</li>\n</ul>\n<p>Так же следует отметить, что конструкторы <code>RandomAccessFile</code> требуют второй аргумент, указывающий необходимый режим доступа к файлу - только чтение (<code>\"r\"</code>), чтение и запись (<code>\"rw\"</code>) или иную их разновидность.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-режимы-доступа-к-файлу-есть-у-randomaccessfile","title":"<p>Какие режимы доступа к файлу есть у <code>RandomAccessFile</code>?</p>","answer":"<ul>\n<li><code>\"r\"</code> открывает файл только для чтения. Запуск любых методов записи данных приведет к выбросу исключения <code>IOException</code>.</li>\n<li><code>\"rw\"</code> открывает файл для чтения и записи. Если файл еще не создан, то осуществляется попытка создать его.</li>\n<li><code>\"rws\"</code> открывает файл для чтения и записи подобно <code>\"rw\"</code>, но требует от системы при каждом изменении содержимого файла или метаданных синхронно записывать эти изменения на физический носитель.</li>\n<li><code>\"rwd\"</code> открывает файл для чтения и записи подобно <code>\"rws\"</code>, но требует от системы синхронно записывать изменения на физический носитель только при каждом изменении содержимого файла. Если изменяются метаданные, синхронная запись не требуется.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какие-классы-поддерживают-чтение-и-запись-потоков-в-компрессированном-формате","title":"<p>Какие классы поддерживают чтение и запись потоков в компрессированном формате?</p>","answer":"<ul>\n<li><code>DeflaterOutputStream</code> - компрессия данных в формате deflate.</li>\n<li><code>Deflater</code> - компрессия данных в формат ZLIB</li>\n<li><code>ZipOutputStream</code> - потомок <code>DeflaterOutputStream</code> для компрессии данных в формат Zip.</li>\n<li><code>GZIPOutputStream</code> - потомок <code>DeflaterOutputStream</code> для компрессии данных в формат GZIP.</li>\n<li><code>InflaterInputStream</code> - декомпрессия данных в формате deflate.</li>\n<li><code>Inflater</code> - декомпрессия данных в формате ZLIB</li>\n<li><code>ZipInputStream</code> - потомок <code>InflaterInputStream</code> для декомпрессии данных в формате Zip.</li>\n<li><code>GZIPInputStream</code> - потомок <code>InflaterInputStream</code> для декомпрессии данных в формате GZIP.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#существует-ли-возможность-перенаправить-потоки-стандартного-вводавывода","title":"<p>Существует ли возможность перенаправить потоки стандартного ввода/вывода?</p>","answer":"<p>Класс <code>System</code> позволяет вам перенаправлять стандартный ввод, вывод и поток вывода ошибок, используя простой вызов статического метода:</p>\n<ul>\n<li><code>setIn(InputStream)</code> - для ввода;</li>\n<li><code>setOut(PrintStream)</code> - для вывода;</li>\n<li><code>setErr(PrintStream)</code> - для вывода ошибок.</li>\n</ul>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#какой-символ-является-разделителем-при-указании-пути-в-файловой-системе","title":"<p>Какой символ является разделителем при указании пути в файловой системе?</p>","answer":"<p>Для различных операционных систем символ разделителя различается. Для Windows это <code>\\</code>, для Linux - <code>/</code>.</p>\n<p>В Java получить разделитель для текущей операционной системы можно через обращение к статическому полю <code>File.separator</code>.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#что-такое-абсолютный-путь-и-относительный-путь","title":"<p>Что такое <em>«абсолютный путь»</em> и <em>«относительный путь»</em>?</p>","answer":"<p><strong>Абсолютный (полный) путь</strong> — это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей рабочей директории или других обстоятельств. Полный путь всегда начинается с корневого каталога.</p>\n<p><strong>Относительный путь</strong> представляет собой путь по отношению к текущему рабочему каталогу пользователя или активного приложения.</p>"},{"subject":"Потоки ввода/вывода в Java","url":"007-io.html#что-такое-символьная-ссылка","title":"<p>Что такое <em>«символьная ссылка»</em>?</p>","answer":"<p><strong>Символьная (символическая) ссылка</strong> (также «симлинк», Symbolic link) — специальный файл в файловой системе, в котором, вместо пользовательских данных, содержится путь к файлу, который должен быть открыт при попытке обратиться к данной ссылке (файлу). Целью ссылки может быть любой объект: например, другая ссылка, файл, каталог или даже несуществующий файл (в последнем случае, при попытке открыть его, должно выдаваться сообщение об отсутствии файла).</p>\n<p>Символьные ссылки используются для более удобной организации структуры файлов на компьютере, так как:</p>\n<ul>\n<li>позволяют для одного файла или каталога иметь несколько имён и различных атрибутов;</li>\n<li>свободны от некоторых ограничений, присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут ссылаться на каталоги).</li>\n</ul>\n<p><a href=\"#Потоки-вводавывода-в-java\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"http://www.quizful.net/post/java-nio-tutorial\">Quizful</a></li>\n<li><a href=\"https://habrahabr.ru/post/235585/\">Хабрахабр</a></li>\n<li><a href=\"http://developer.alexanderklimov.ru/android/java/io.php\">Освой программирование играючи</a></li>\n<li><a href=\"http://metanit.com/java/tutorial/6.1.php\">Metanit</a></li>\n<li><a href=\"http://javastudy.ru/interview/input-output/\">javastudy.ru</a></li>\n<li><a href=\"http://iais.kemsu.ru/odocs/java/Chapter11.html\">Bruce Eckel «Thinking in Java»</a></li>\n</ul>"},{"subject":"Сериализация в Java","url":"008-serialization.html#что-такое-сериализация","title":"<p>Что такое <em>«сериализация»</em>?</p>","answer":"<p><strong>Сериализация (Serialization)</strong> - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения. Сериализованные объекты можно затем восстановить (десериализовать).</p>\n<p>В Java, согласно спецификации Java Object Serialization существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса <code>java.io.Serializable</code> и «расширенная» сериализация - <code>java.io.Externalizable</code>.</p>\n<p>Сериализация позволяет в определенных пределах изменять класс. Вот наиболее важные изменения, с которыми спецификация\nJava Object Serialization может справляться автоматически:</p>\n<ul>\n<li>добавление в класс новых полей;</li>\n<li>изменение полей из статических в нестатические;</li>\n<li>изменение полей из транзитных в нетранзитные.</li>\n</ul>\n<p>Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют\nопределенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#опишите-процесс-сериализациидесериализации-с-использованием-serializable","title":"<p>Опишите процесс сериализации/десериализации с использованием <code>Serializable</code></p>","answer":"<p>При использовании Serializable применяется алгоритм сериализации, который с помощью рефлексии (Reflection API)\nвыполняет:</p>\n<ul>\n<li>запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор <code>SerialVersionUID</code>,\nидентификаторы полей класса);</li>\n<li>рекурсивную запись в поток описания суперклассов до класса <code>java.lang.Object</code> (не включительно);</li>\n<li>запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;</li>\n<li>рекурсивную запись объектов, которые являются полями сериализуемого объекта.</li>\n</ul>\n<p>При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с\nциклическими ссылками.</p>\n<p>Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока. Конструктор объекта при этом не вызывается. Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#как-изменить-стандартное-поведение-сериализациидесериализации","title":"<p>Как изменить стандартное поведение сериализации/десериализации?</p>","answer":"<ul>\n<li>Реализовать интерфейс <code>java.io.Externalizable</code>, который позволяет применение пользовательской логики сериализации.\nСпособ сериализации и десериализации описывается в методах <code>writeExternal()</code> и <code>readExternal()</code>. Во время\nдесериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается\nметод <code>readExternal</code>.</li>\n<li>Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а\nне метод по умолчанию :<ul>\n<li><code>writeObject()</code> - запись объекта в поток;</li>\n<li><code>readObject()</code> - чтение объекта из потока;</li>\n<li><code>writeReplace()</code> - позволяет заменить себя экземпляром другого класса перед записью;</li>\n<li><code>readResolve()</code> - позволяет заменить на себя другой объект после чтения.</li></ul></li>\n</ul>"},{"subject":"Сериализация в Java","url":"008-serialization.html#как-исключить-поля-из-сериализации","title":"<p>Как исключить поля из сериализации?</p>","answer":"<p>Для управления сериализацией при определении полей можно использовать ключевое слово <code>transient</code>, таким образом исключив поля из общего процесса сериализации.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#что-обозначает-ключевое-слово-transient","title":"<p>Что обозначает ключевое слово <code>transient</code>?</p>","answer":"<p>Поля класса, помеченные модификатором <code>transient</code>, не сериализуются.</p>\n<p>Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить. Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#какое-влияние-оказывают-на-сериализуемость-модификаторы-полей-static-и-final","title":"<p>Какое влияние оказывают на сериализуемость модификаторы полей <code>static</code> и <code>final</code></p>","answer":"<p>При стандартной сериализации поля, имеющие модификатор static, не сериализуются. Соответственно, после десериализации это поле значения не меняет. При использовании реализации <code>Externalizable</code> сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.</p>\n<p>Поля с модификатором <code>final</code> сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании <code>Externalizable</code>, поскольку <code>final</code> поля должны быть инициализированы в конструкторе, а после этого в <code>readExternal()</code> изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с <code>final</code> полем необходимо использовать только стандартную сериализацию.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#как-не-допустить-сериализацию","title":"<p>Как не допустить сериализацию?</p>","answer":"<p>Чтобы не допустить автоматическую сериализацию можно переопределить <code>private</code> методы для создания исключительной ситуации <code>NotSerializableException</code>.</p>\n<pre><code class=\"java language-java\">private void writeObject(ObjectOutputStream out) throws IOException {\n    throw new NotSerializableException();\n}\n\nprivate void readObject(ObjectInputStream in) throws IOException {\n    throw new NotSerializableException();\n}\n</code></pre>\n<p>Любая попытка записать или прочитать этот объект теперь приведет к возникновению исключительной ситуации.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#как-создать-собственный-протокол-сериализации","title":"<p>Как создать собственный протокол сериализации?</p>","answer":"<p>Для создания собственного протокола сериализации достаточно реализовать интерфейс <code>Externalizable</code>, который содержит два метода:</p>\n<pre><code class=\"java language-java\">public void writeExternal(ObjectOutput out) throws IOException;\npublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;\n</code></pre>"},{"subject":"Сериализация в Java","url":"008-serialization.html#какая-роль-поля-serialversionuid-в-сериализации","title":"<p>Какая роль поля <code>serialVersionUID</code> в сериализации?</p>","answer":"<p><code>serialVersionUID</code> используется для указания версии сериализованных данных.</p>\n<p>Когда мы не объявляем <code>serialVersionUID</code> в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр.</p>\n<p>Рекомендуется явно объявлять <code>serialVersionUID</code> т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение <code>InvalidClassException</code>.</p>\n<pre><code class=\"java language-java\">private static final long serialVersionUID = 20161013L;\n</code></pre>"},{"subject":"Сериализация в Java","url":"008-serialization.html#когда-стоит-изменять-значение-поля-serialversionuid","title":"<p>Когда стоит изменять значение поля <code>serialVersionUID</code>?</p>","answer":"<p><code>serialVersionUID</code> нужно изменять при внесении в класс несовместимых изменений, например при удалении какого-либо его атрибута.</p>"},{"subject":"Сериализация в Java","url":"008-serialization.html#в-чем-проблема-сериализации-singleton","title":"<p>В чем проблема сериализации Singleton?</p>","answer":"<p>Проблема в том что после десериализации мы получим другой объект. Таким образом, сериализация дает возможность создать Singleton еще раз, что недопустимо. Существует два способа избежать этого:</p>\n<ul>\n<li>явный запрет сериализации.</li>\n<li>определение метода с сигнатурой <code>(default/public/private/protected/) Object readResolve() throws ObjectStreamException</code>, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.</li>\n</ul>"},{"subject":"Сериализация в Java","url":"008-serialization.html#какие-существуют-способы-контроля-за-значениями-десериализованного-объекта","title":"<p>Какие существуют способы контроля за значениями десериализованного объекта</p>","answer":"<p>Если есть необходимость выполнения контроля за значениями десериализованного объекта, то можно использовать интерфейс <code>ObjectInputValidation</code> с переопределением метода <code>validateObject()</code>.</p>\n<pre><code class=\"java language-java\">// Если вызвать метод validateObject() после десериализации объекта, то будет вызвано исключение InvalidObjectException при значении возраста за пределами 39...60.\npublic class Person implements java.io.Serializable,\n                               java.io.ObjectInputValidation {\n    ...\n    @Override\n    public void validateObject() throws InvalidObjectException {\n        if ((age &lt; 39) || (age &gt; 60))\n            throw new InvalidObjectException(\"Invalid age\");\n    }\n}\n</code></pre>\n<p>Так же существуют способы подписывания и шифрования, позволяющие убедиться, что данные не были изменены:</p>\n<ul>\n<li><p>с помощью описания логики в <code>writeObject()</code> и <code>readObject()</code>.</p></li>\n<li><p>поместить в оберточный класс <code>javax.crypto.SealedObject</code> и/или <code>java.security.SignedObject</code>. Данные классы являются сериализуемыми, поэтому при оборачивании объекта в <code>SealedObject</code> создается подобие «подарочной упаковки» вокруг исходного объекта. Для шифрования необходимо создать симметричный ключ, управление которым должно осуществляться отдельно. Аналогично, для проверки данных можно использовать класс <code>SignedObject</code>, для работы с которым также нужен симметричный ключ, управляемый отдельно.</p></li>\n</ul>\n<p><a href=\"#сериализация-в-java\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://www.ibm.com/developerworks/ru/library/j-5things1/\">IBM developerWorks</a></li>\n<li><a href=\"http://java-online.ru/blog-serialization.xhtml\">Java-online.ru</a></li>\n<li><a href=\"http://ccfit.nsu.ru/~deviv/courses/oop/java_ser_rus.html\">Изучите секреты Java Serialization API</a></li>\n<li><a href=\"http://bit.ly/1xwRA2D\">JavaRush</a></li>\n<li><a href=\"http://www.skipy.ru/technics/serialization.html\">Записки трезвого практика</a></li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#расскажите-о-модели-памяти-java","title":"<p>Расскажите о модели памяти Java?</p>","answer":"<p><strong>Модель памяти Java (Java Memory Model, JMM)</strong> описывает поведение потоков в среде исполнения Java. Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти.</p>\n<p>Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -<em>happens-before</em> - абстракции обозначающей, что если операция <em>X</em> связана отношением happens-before с операцией <em>Y</em>, то весь код следуемый за операцией <em>Y</em>, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции <em>X</em>.</p>\n<p>Существует несколько основных правил для отношения happens-before:</p>\n<ul>\n<li>В рамках одного потока любая операция happens-before любой операцией следующей за ней в исходном коде;</li>\n<li>Освобождение монитора (unlock) happens-before захват того же монитора (lock);</li>\n<li>Выход из <code>synchronized</code> блока/метода happens-before вход в <code>synchronized</code> блок/метод на том же мониторе;</li>\n<li>Запись <code>volatile</code> поля happens-before чтение того же самого <code>volatile</code> поля;</li>\n<li>Завершение метода <code>run()</code> экземпляра класса <code>Thread</code> happens-before выход из метода <code>join()</code> или возвращение <code>false</code> методом <code>isAlive()</code> экземпляром того же потока;</li>\n<li>Вызов метода <code>start()</code> экземпляра класса <code>Thread</code> happens-before начало метода <code>run()</code> экземпляра того же потока;</li>\n<li>Завершение конструктора happens-before начало метода <code>finalize()</code> этого класса;</li>\n<li>Вызов метода <code>interrupt()</code> на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения <code>InterruptedException</code>, либо с помощью методов <code>isInterrupted()</code> или <code>interrupted()</code>.</li>\n<li>Связь happens-before транзитивна, т.е. если <em>X</em> happens-before <em>Y</em>, а <em>Y</em> happens-before <em>Z</em>, то <em>X</em> happens-before <em>Z</em>.</li>\n<li>Освобождение/захват монитора и запись/чтение в <code>volatile</code> переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.</li>\n<li>В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.</li>\n</ul>\n<p>Можно выделить несколько основных областей, имеющих отношение к модели памяти:</p>\n<p><em>Видимость (visibility)</em>. Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.</p>\n<p>К вопросу видимости имеют отношение следующие ключевые слов языка Java: <code>synchronized</code>, <code>volatile</code>, <code>final</code>.</p>\n<p>С точки зрения Java все переменные (за исключением локальных переменных, объявленных внутри метода) хранятся в главной памяти, которая доступна всем потокам. Кроме этого, каждый поток имеет локальную—рабочую—память, где он хранит копии переменных, с которыми он работает, и при выполнении программы поток работает только с этими копиями. Надо отметить, что это описание не требование к реализации, а всего лишь модель, которая объясняет поведение программы, так, в качестве локальной памяти не обязательно выступает кэш память, это могут быть регистры процессора или потоки могут вообще не иметь локальной памяти.</p>\n<p>При входе в <code>synchronized</code> метод или блок поток обновляет содержимое локальной памяти, а при выходе из <code>synchronized</code> метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение <code>synchronized</code> методов и блоков следует из правил для отношения «происходит раньше»: так как все операции с памятью происходят раньше освобождения монитора и освобождение монитора происходит раньше захвата монитора, то все операции с памятью, которые были сделаны потоком до выхода из <code>synchronized</code> блока должны быть видны любому потоку, который входит в <code>synchronized</code> блок для того же самого монитора. Очень важно, что это правило работает только в том случае, если потоки синхронизируются, используя один и тот же монитор!</p>\n<p>Что касается <code>volatile</code> переменных, то запись таких переменных производится в основную память, минуя локальную. и чтение <code>volatile</code> переменной производится также из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт последнее записанное в неё значение.</p>\n<p>Также модель памяти определяет дополнительную семантику ключевого слова <code>final</code>, имеющую отношение к видимости: после того как объект был корректно создан, любой поток может видеть значения его <code>final</code> полей без дополнительной синхронизации. «Корректно создан» означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Наличие такой семантики для ключевого слова <code>final</code> позволяет создание неизменяемых (immutable) объектов, содержащих только <code>final</code> поля, такие объекты могут свободно передаваться между потоками без обеспечения синхронизации при передаче.</p>\n<p>Есть одна проблема, связанная с <code>final</code> полями: реализация разрешает менять значения таких полей после создания объекта (это может быть сделано, например, с использованием механизма reflection). Если значение <code>final</code> поля—константа, чьё значение известно на момент компиляции, изменения такого поля могут не иметь эффекта, так-как обращения к этой переменной могли быть заменены компилятором на константу. Также спецификация разрешает другие оптимизации, связанные с <code>final</code> полями, например, операции чтения <code>final</code> переменной могут быть переупорядочены с операциями, которые потенциально могут изменить такую переменную. Так что рекомендуется изменять <code>final</code> поля объекта только внутри конструктора, в противном случае поведение не специфицировано.</p>\n<p><em>Reordering (переупорядочивание)</em>. Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде. Тот же эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью. Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее.</p>\n<p>Вопрос reordering также регулируется набором правил для отношения «происходит раньше» и у этих правил есть следствие, касающееся порядка операций, используемое на практике: операции чтения и записи <code>volatile</code> переменных не могут быть переупорядочены с операциями чтения и записи других <code>volatile</code> и не-<code>volatile</code> переменных. Это следствие делает возможным использование <code>volatile</code> переменной как флага, сигнализирующем об окончании какого-либо действия. В остальном правила, касающиеся порядка выполнения операций, гарантируют упорядоченность операций для конкретного набора случаев (таких как, например, захват и освобождение монитора), во всех остальных случаях оставляя компилятору и процессору полную свободу для оптимизаций.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-потокобезопасность","title":"<p>Что такое «потокобезопасность»?</p>","answer":"<p><strong>Потокобезопасность</strong> – свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается. Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чём-разница-между-конкуренцией-и-параллелизмом","title":"<p>В чём разница между <em>«конкуренцией»</em> и <em>«параллелизмом»</em>?</p>","answer":"<p><strong>Конкуренция</strong> — это способ одновременного решения множества задач.</p>\n<p>Признаки:</p>\n<ul>\n<li>Наличие нескольких потоков управления (например <em>Thread</em> в Java, <em>корутина</em> в Kotlin), если поток управления один, то конкурентного выполнения быть не может</li>\n<li>Недетерминированный результат выполнения. Результат зависит от случайных событий, реализации и того как была проведена синхронизация. Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированным</li>\n</ul>\n<p><strong>Параллелизм</strong> — это способ выполнения разных частей одной задачи.</p>\n<p>Признаки:</p>\n<ul>\n<li>Необязательно имеет несколько потоков управления</li>\n<li>Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, не изменится, если умножать его по частям параллельно.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-кооперативная-многозадачность-какой-тип-многозадачности-использует-java-чем-обусловлен-этот-выбор","title":"<p>Что такое <em>«кооперативная многозадачность»</em>? Какой тип многозадачности использует Java? Чем обусловлен этот выбор?</p>","answer":"<p><strong>Кооперативная многозадачность</strong> - это способ деления процессорного времени между потоками, при котором каждый поток обязан отдавать управление следующему добровольно.</p>\n<p>Преимущества такого подхода - простота реализации, меньшие накладные расходы на переключение контекста.</p>\n<p>Недостатки - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда не получат управление.</p>\n<p>Java использует <strong>вытесняющую многозадачность</strong>, при которой решение о переключении между потоками процесса принимает операционная система.</p>\n<p>В отличие от кооперативной многозадачности управление операционной системе передаётся вне зависимости от состояния работающих приложений, благодаря чему, отдельные зависшие потоки процесса, как правило, не «подвешивают» всю систему целиком. За счёт регулярного переключения между задачами также улучшается отзывчивость приложения и повышается оперативность освобождения ресурсов, которые больше не используются.</p>\n<p>В реализации вытесняющая многозадачность отличается от кооперативной, в частности, тем, что требует обработки системного прерывания от аппаратного таймера.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-ordering-as-if-serial-semantics-sequential-consistency-visibility-atomicity-happens-before-mutual-exclusion-safe-publication","title":"<p>Что такое <em>ordering</em>, <em>as-if-serial semantics</em>, <em>sequential consistency</em>, <em>visibility</em>, <em>atomicity</em>, <em>happens-before</em>, <em>mutual exclusion</em>, <em>safe publication</em>?</p>","answer":"<p><strong>ordering</strong> механизм, который определяет, когда один поток может увидеть <em>out-of-order</em> (неверный) порядок исполнения инструкций другого потока. CPU для для повышения производительности может переупорядочивать процессорные инструкции и выполнять их в произвольном порядке  до тех пор пока для потока внутри не будет видно никаких отличий. Гарантия предоставляемая этим механизмом называется <strong>as-if-serial semantics</strong>.</p>\n<p><strong>sequential consistency</strong> - то же что и <em>as-if-serial semantics</em>, гарантия того, что в рамках одного потока побочные эффекты от всех операций будут такие, как будто все операции выполняются последовательно.</p>\n<p><strong>visibility</strong>  определяет, когда действия в одном потоке становятся видны из другого потока.</p>\n<p><strong>happens-before</strong> - логическое ограничение на порядок выполнения инструкций программы. Если указывается, что запись в переменную и последующее ее чтение связаны через эту зависимость, то как бы при выполнении не переупорядочивались инструкции, в момент чтения все связанные с процессом записи результаты уже зафиксированы и видны.</p>\n<p><strong>atomicity</strong> — атомарность операций. Атомарная операция выглядит единой и неделимой командой процессора, которая может быть или уже выполненной или ещё невыполненной.</p>\n<p><strong>mutual exclusion</strong> (взаимоисключающая блокировка, семафор с одним состоянием) - механизм, гарантирующий потоку исключительный доступ к ресурсу. Используется для предотвращения одновременного доступа к общему ресурсу. В каждый момент времени таким ресурсом может владеть только один поток. Простейший пример: <code>synchronized(obj) { … }</code>.</p>\n<p><strong>safe publication</strong>? - показ объектов другим потокам из текущего, не нарушая ограничений <em>visibility</em>. Способы такой публикации в Java:</p>\n<ul>\n<li><code>static{}</code> инициализатор;</li>\n<li><code>volatile</code> переменные;</li>\n<li><code>atomic</code> переменные;</li>\n<li>сохранение в разделяемой переменной, корректно защищенной с использованием <code>synchronized()</code>, синхронизаторов или других конструкций, создающих <em>read/write memory barrier</em>;</li>\n<li><code>final</code> переменные в разделяемом объекте, который был корректно проинициализирован.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-отличается-процесс-от-потока","title":"<p>Чем отличается процесс от потока?</p>","answer":"<p><strong>Процесс</strong> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.</p>\n<p>Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.</p>\n<p><strong>Поток</strong>(thread) — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.\nПотоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах.\nТак как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-зелёные-потоки-и-есть-ли-они-в-java","title":"<p>Что такое <em>«зелёные потоки»</em> и есть ли они в Java?</p>","answer":"<p><strong>Зелёные (легковесные) потоки</strong>(green threads) - потоки эмулируемые виртуальной машиной или средой исполнения. Создание зелёного потока не подразумевает под собой создание реального потока ОС.</p>\n<p>Виртуальная машина Java берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. Это даёт несколько преимуществ. Потоки ОС относительно дороги в большинстве POSIX-систем. Кроме того, переключение между native threads гораздо медленнее, чем между green threads.</p>\n<p>Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads. Система может поддерживать гораздо большее количество green threads, чем потоков ОС. Например, гораздо практичнее запускать новый green thread для нового HTTP-соединения к веб-серверу, вместо создания нового native thread.</p>\n<p>Однако есть и недостатки. Самый большой заключается в том, что вы не можете исполнять два потока одновременно. Поскольку существует только один native thread, только он и вызывается планировщиком ОС. Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.</p>\n<p>Начиная с версии 1.2 Java поддерживает native threads, и с тех пор они используются по умолчанию.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#каким-образом-можно-создать-поток","title":"<p>Каким образом можно создать поток?</p>","answer":"<ul>\n<li>Создать потомка класса <code>Thread</code> и переопределить его метод <code>run()</code>;</li>\n<li>Создать объект класса <code>Thread</code>, передав ему в конструкторе экземпляр класса, реализующего интерфейс <code>Runnable</code>. Эти интерфейс содержит метод <code>run()</code>, который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод <code>run()</code>.</li>\n<li>Вызвать метод <code>submit()</code> у экземпляра класса реализующего интерфейс <code>ExecutorService</code>, передав ему в качестве параметра экземпляр класса реализующего интерфейс <code>Runnable</code> или <code>Callable</code> (содержит метод <code>call()</code>, в котором описывается логика выполнения).</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-различаются-thread-и-runnable","title":"<p>Чем различаются <code>Thread</code> и <code>Runnable</code>?</p>","answer":"<p><code>Thread</code> - это класс, некоторая надстройка над физическим потоком.</p>\n<p><code>Runnable</code> - это интерфейс, представляющий абстракцию над выполняемой задачей.</p>\n<p>Помимо того, что <code>Runnable</code> помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чём-заключается-разница-между-методами-start-и-run","title":"<p>В чём заключается разница между методами <code>start()</code> и <code>run()</code>?</p>","answer":"<p>Несмотря на то, что <code>start()</code> вызывает метод <code>run()</code> внутри себя, это не то же самое, что просто вызов <code>run()</code>. Если <code>run()</code> вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод <code>start()</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-принудительно-запустить-поток","title":"<p>Как принудительно запустить поток?</p>","answer":"<p>Никак. В Java не существует абсолютно никакого способа принудительного запуска потока. Это контролируется JVM и Java не предоставляет никакого API для управления этим процессом.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-монитор-в-java","title":"<p>Что такое <em>«монитор»</em> в Java?</p>","answer":"<p><strong>Монитор</strong>, мьютекс (mutex) – это средство обеспечения контроля за доступом к ресурсу. У монитора может быть максимум\nодин владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для\nобеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения\nмонитора, захватить его и только потом начать использовать ресурс.</p>\n<p>Удобно представлять монитор как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс\nзанят. Можно встать в очередь и ждать его освобождения.</p>\n<p>В Java у каждого экземпляра объекта есть монитор, который контролируется непосредственно виртуальной машиной.\nИспользуется он так: любой нестатический <code>synchronized</code>-метод при своем вызове прежде всего пытается захватить монитор\nтого объекта, у которого он вызван (на который он может сослаться как на <code>this</code>). Если это удалось – метод исполняется.\nЕсли нет – поток останавливается и ждет, пока монитор будет отпущен.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#дайте-определение-понятию-синхронизация","title":"<p>Дайте определение понятию «синхронизация»</p>","answer":"<p>Синхронизация это процесс, который позволяет выполнять потоки параллельно.</p>\n<p>В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к\nкритическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта. Если поток\nполучил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята. Когда\nпоток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается. Теперь другой поток может\nполучить блокировку объекта и выполнить синхронизированный код. Если поток пытается получить блокировку объекта, когда\nдругой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#какие-существуют-способы-синхронизации-в-java","title":"<p>Какие существуют способы синхронизации в Java?</p>","answer":"<ul>\n<li><p><strong>Системная синхронизация с использованием <code>wait()</code>/<code>notify()</code></strong>. Поток, который ждет выполнения каких-либо условий,\nвызывает у этого объекта метод <code>wait()</code>, предварительно захватив его монитор. На этом его работа приостанавливается.\nДругой поток может вызвать на этом же самом объекте метод <code>notify()</code> (опять же, предварительно захватив монитор\nобъекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях\nмонитор надо захватывать в явном виде, через <code>synchronized</code>-блок, потому как методы <code>wait()</code>/<code>notify()</code> не\nсинхронизированы!</p></li>\n<li><p><strong>Системная синхронизация с использованием <code>join()</code></strong>. Метод <code>join()</code>, вызванный у экземпляра класса <code>Thread</code>, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.</p></li>\n<li><p><strong>Использование классов из пакета <code>java.util.concurrent</code></strong>, который предоставляет набор классов для организации межпоточного взаимодействия. Примеры таких классов - <code>Lock</code>, <code>Semaphore</code> и пр.. Концепция данного подхода заключается в использовании атомарных операций и переменных.</p></li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-каких-состояниях-может-находиться-поток","title":"<p>В каких состояниях может находиться поток?</p>","answer":"<p>Потоки могут находиться в одном из следующих состояний:</p>\n<ul>\n<li><strong>Новый (New)</strong>. После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод <code>start()</code>. В этом состоянии поток не считается живым.</li>\n<li><strong>Работоспособный (Runnable)</strong>. Поток переходит в состояние Работоспособный, когда вызывается метод <code>start()</code>. Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован. Когда поток находится в этом состоянии, он считается живым.</li>\n<li><strong>Работающий (Running)</strong>. Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик\nпотоков выбирает его как работающий в данный момент.</li>\n<li><strong>Живой, но не работоспособный (Alive, but not runnable)</strong>. Поток может быть живым, но не работоспособным по\nнескольким причинам:<ul>\n<li><strong>Ожидание (Waiting)</strong>. Поток переходит в состояние Ожидания, вызывая метод <code>wait()</code>. Вызов <code>notify()</code>\nили <code>notifyAll()</code> может перевести поток из состояния Ожидания в состояние Работоспособный.</li>\n<li><strong>Сон (Sleeping)</strong>. Метод <code>sleep()</code> переводит поток в состояние Сна на заданный промежуток времени в\nмиллисекундах.</li>\n<li><strong>Блокировка (Blocked)</strong>. Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за\nблокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится\nдоступен.</li>\n<li><strong>Мёртвый (Dead)</strong>. Поток считается мёртвым, когда его метод <code>run()</code> полностью выполнен. Мёртвый поток не может\nперейти ни в какое другое состояние, даже если для него вызван метод <code>start()</code>.</li></ul></li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#можно-ли-создавать-новые-экземпляры-класса-пока-выполняется-static-synchronized-метод","title":"<p>Можно ли создавать новые экземпляры класса, пока выполняется <code>static synchronized</code> метод?</p>","answer":"<p>Да, можно создавать новые экземпляры класса, так как статические поля не принадлежат к экземплярам класса.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#зачем-может-быть-нужен-private-мьютекс","title":"<p>Зачем может быть нужен <code>private</code> мьютекс?</p>","answer":"<p>Объект для синхронизации делается <code>private</code>, чтобы сторонний код не мог на него синхронизироваться и случайно получить взаимную блокировку.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-работают-методы-wait-и-notifynotifyall","title":"<p>Как работают методы <code>wait()</code> и <code>notify()</code>/<code>notifyAll()</code>?</p>","answer":"<p>Эти методы определены у класса <code>Object</code> и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.</p>\n<ul>\n<li><code>wait()</code>: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод <code>notify()</code>/<code>notifyAll()</code>;</li>\n<li><code>notify()</code>: продолжает работу потока, у которого ранее был вызван метод <code>wait()</code>;</li>\n<li><code>notifyAll()</code>: возобновляет работу всех потоков, у которых ранее был вызван метод <code>wait()</code>.</li>\n</ul>\n<p>Когда вызван метод <code>wait()</code>, поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод <code>notify()</code> подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод <code>notifyAll()</code> заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе <code>wait()</code>, то при вызове <code>notify()</code> или <code>notifyAll()</code> ничего не происходит.</p>\n<p>Поток может вызвать методы <code>wait()</code> или <code>notify()</code> для определённого объекта, только если он в данный момент имеет блокировку на этот объект. <code>wait()</code>, <code>notify()</code> и <code>notifyAll()</code> должны вызываться только из синхронизированного кода.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чем-разница-между-notify-и-notifyall","title":"<p>В чем разница между <code>notify()</code> и <code>notifyAll()</code>?</p>","answer":"<p>Дело в том, что «висеть» на методе <code>wait()</code> одного монитора могут сразу несколько потоков. При вызове <code>notify()</code> только один из них выходит из <code>wait()</code> и пытается захватить монитор, а затем продолжает работу со следующего после <code>wait()</code> оператора. Какой из них выйдет - заранее неизвестно. А при вызове <code>notifyAll()</code>, все висящие на <code>wait()</code> потоки выходят из <code>wait()</code>, и все они пытаются захватить монитор. Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди. Порядок очереди определяется планировщиком потоков Java.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#почему-методы-wait-и-notify-вызываются-только-в-синхронизированном-блоке","title":"<p>Почему методы <code>wait()</code> и <code>notify()</code> вызываются только в синхронизированном блоке?</p>","answer":"<p>Монитор надо захватывать в явном виде (через <code>synchronized</code>-блок), потому что методы <code>wait()</code> и <code>notify()</code> не синхронизированы.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-отличается-работа-метода-wait-с-параметром-и-без-параметра","title":"<p>Чем отличается работа метода <code>wait()</code> с параметром и без параметра?</p>","answer":"<p><code>wait()</code></p>\n<ul>\n<li><strong>без параметров</strong> освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод <code>notify()</code>/<code>notifyAll()</code>,</li>\n<li><strong>с параметрами</strong> заставит поток ожидать заданное количество времени или вызова <code>notify()</code>/<code>notifyAll()</code>.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-отличаются-методы-threadsleep-и-threadyield","title":"<p>Чем отличаются методы <code>Thread.sleep()</code> и <code>Thread.yield()</code>?</p>","answer":"<p>Метод <code>yield()</code> служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска поток может и не быть другим.</p>\n<p>Метод <code>sleep()</code> вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-работает-метод-threadjoin","title":"<p>Как работает метод <code>Thread.join()</code>?</p>","answer":"<p>Когда поток вызывает <code>join()</code> для другого потока, текущий работающий поток будет ждать, пока другой поток, к которому он присоединяется, не будет завершён:</p>\n<pre><code class=\"java language-java\">void join()\nvoid join(long millis)\nvoid join(long millis, int nanos)\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-deadlock","title":"<p>Что такое <em>deadlock</em>?</p>","answer":"<p><strong>Взаимная блокировка (deadlock)</strong> - явление при котором все потоки находятся в режиме ожидания. Происходит, когда достигаются состояния:</p>\n<ol>\n<li>взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и следовательно только один поток может использовать ресурс в любой данный момент времени.</li>\n<li>удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.</li>\n<li>отсутствия предочистки: операционная система не переназначает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.</li>\n<li>цикличного ожидания: поток ждёт освобождения ресурса другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.</li>\n</ol>\n<p>Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-livelock","title":"<p>Что такое <em>livelock</em>?</p>","answer":"<p><em>livelock</em> – тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг от друга. Фактической ошибки не возникает, но КПД системы падает до 0. Часто возникает в результате попыток предотвращения deadlock.</p>\n<blockquote>\n  <p>Реальный пример livelock, – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.</p>\n</blockquote>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-проверить-удерживает-ли-поток-монитор-определённого-ресурса","title":"<p>Как проверить, удерживает ли поток монитор определённого ресурса?</p>","answer":"<p>Метод <code>Thread.holdsLock(lock)</code> возвращает <code>true</code>, когда текущий поток удерживает монитор у определённого объекта.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#на-каком-объекте-происходит-синхронизация-при-вызове-static-synchronized-метода","title":"<p>На каком объекте происходит синхронизация при вызове <code>static synchronized</code> метода?</p>","answer":"<p>У синхронизированного статического метода нет доступа к <code>this</code>, но есть доступ к объекту класса <code>Class</code>, он присутствует в единственном экземпляре и именно он выступает в качестве монитора для синхронизации статических методов. Таким образом, следующая конструкция:</p>\n<pre><code class=\"java language-java\">public class SomeClass {\n\n    public static synchronized void someMethod() {\n        //code\n    }\n}\n</code></pre>\n<p>эквивалентна такой:</p>\n<pre><code class=\"java language-java\">public class SomeClass {\n\n    public static void someMethod(){\n        synchronized(SomeClass.class){\n            //code\n        }\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чём-различия-между-volatile-и-atomic-переменными","title":"<p>В чём различия между <code>volatile</code> и <em>Atomic</em> переменными?</p>","answer":"<p><code>volatile</code> принуждает использовать единственный экземпляр переменной, но не гарантирует атомарность. Например,\nоперация <code>count++</code> не станет атомарной просто потому что <code>count</code> объявлена <code>volatile</code>. C другой\nстороны <code>class AtomicInteger</code> предоставляет атомарный метод для выполнения таких комплексных операций атомарно,\nнапример <code>getAndIncrement()</code> – атомарная замена оператора инкремента, его можно использовать, чтобы атомарно увеличить\nтекущее значение на один. Похожим образом сконструированы атомарные версии и для других типов данных.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чём-заключаются-различия-между-javautilconcurrentatomiccompareandswap-и-javautilconcurrentatomicweakcompareandswap","title":"<p>В чём заключаются различия между <code>java.util.concurrent.Atomic*.compareAndSwap()</code> и <code>java.util.concurrent.Atomic*.weakCompareAndSwap()</code>?</p>","answer":"<ul>\n<li><code>weakCompareAndSwap()</code> не создает <em>memory barrier</em> и не дает гарантии <em>happens-before</em>;</li>\n<li><code>weakCompareAndSwap()</code> сильно зависит от кэша/CPU, и может возвращать <code>false</code> без видимых причин;</li>\n<li><code>weakCompareAndSwap()</code>, более легкая, но поддерживаемая далеко не всеми архитектурами и не всегда эффективная\nоперация.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-значит-приоритет-потока","title":"<p>Что значит <em>«приоритет потока»</em>?</p>","answer":"<p>Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет\nразрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные.\nПрактически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его\nприоритета.</p>\n<p>Чтобы установить приоритет потока, используется метод класса <code>Thread</code>: <code>final void setPriority(int level)</code>. Значение <code>level</code> изменяется в пределах от <code>Thread.MIN_PRIORITY = 1</code> до <code>Thread.MAX_PRIORITY = 10</code>. Приоритет по умолчанию - <code>Thread.NORM_PRlORITY = 5</code>.</p>\n<p>Получить текущее значение приоритета потока можно вызвав метод: <code>final int getPriority()</code> у экземпляра класса <code>Thread</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-потоки-демоны","title":"<p>Что такое <em>«потоки-демоны»</em>?</p>","answer":"<p>Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода <code>setDaemon(boolean value)</code>, вызванного у потока до его запуска. Метод <code>boolean isDaemon()</code> позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода <code>main()</code>, не обращая внимания на то, что поток-демон еще работает.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#можно-ли-сделать-основной-поток-программы-демоном","title":"<p>Можно ли сделать основной поток программы демоном?</p>","answer":"<p>Нет. Потоки-демоны позволяют описывать фоновые процессы, которые нужны только для обслуживания основных потоков выполнения и не могут существовать без них.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-значит-усыпить-поток","title":"<p>Что значит <em>«усыпить»</em> поток?</p>","answer":"<p>Это значит приостановить его на определенный промежуток времени, вызвав в ходе его выполнения статический метод <code>Thread.sleep()</code> передав в качестве параметра необходимое количество времени в  миллисекундах. До истечения этого времени поток может быть выведен из состояния ожидания вызовом <code>interrupt()</code> с выбрасыванием <code>InterruptedException</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-отличаются-два-интерфейса-runnable-и-callable","title":"<p>Чем отличаются два интерфейса <code>Runnable</code> и <code>Callable</code>?</p>","answer":"<ul>\n<li>Интерфейс <code>Runnable</code> повлиял в Java 1.0, а интерфейс <code>Callable</code> был введен в Java 5.0 в составе библиотеки <code>java.util.concurrent</code>;</li>\n<li>Классы, реализующие интерфейс <code>Runnable</code> для выполнения задачи должны реализовывать метод <code>run()</code>. Классы, реализующие интерфейс <code>Callable</code> - метод <code>call()</code>;</li>\n<li>Метод <code>Runnable.run()</code> не возвращает никакого значения, <code>Callable.call()</code> возвращает объект <code>Future</code>, который может содержать результат вычислений;</li>\n<li>Метод <code>run()</code> не может выбрасывать проверяемые исключения, в то время как метод <code>call()</code> может.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-futuretask","title":"<p>Что такое <code>FutureTask</code>?</p>","answer":"<p><code>FutureTask</code> представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс предоставляет базовую реализацию <code>Future</code>, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено. Объекты <code>FutureTask</code> могут быть использованы для обёртки объектов <code>Callable</code> и <code>Runnable</code>. Так как <code>FutureTask</code> реализует <code>Runnable</code>, его можно передать в <code>Executor</code> на выполнение.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-completablefuture","title":"<p>Что такое <code>CompletableFuture</code>?</p>","answer":"<p><code>CompletableFuture</code> используется для асинхронного программирования в Java. Асинхронное программирование — это средство написания неблокирующего кода путём выполнения задачи в отдельном, отличном от главного, потоке, а также уведомление главного потока о ходе выполнения, завершении или сбое. Таким образом, основной поток не блокируется и не ждёт завершения задачи, а значит может параллельно выполнять и другие задания. Наличие такого рода параллелизма значительно повышает производительность программ.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чем-заключаются-различия-между-cyclicbarrier-и-countdownlatch","title":"<p>В чем заключаются различия между <code>CyclicBarrier</code> и <code>CountDownLatch</code>?</p>","answer":"<p><code>CountDownLatch</code> (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор <code>CountDownLatch(int count)</code> обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.</p>\n<blockquote>\n  <p>Примером <code>CountDownLatch</code> из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.</p>\n</blockquote>\n<p><code>CyclicBarrier</code> реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструкторы барьера <code>CyclicBarrier(int parties)</code> и <code>CyclicBarrier(int parties, Runnable barrierAction)</code> обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».</p>\n<blockquote>\n  <p><code>CyclicBarrier</code> является альтернативой метода <code>join()</code>, который «собирает» потоки только после того, как они выполнились.</p>\n</blockquote>\n<p><code>CyclicBarrier</code> похож на <code>CountDownLatch</code>, но главное различие между ними в том, что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, как он «сломается».</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-race-condition","title":"<p>Что такое <em>race condition</em>?</p>","answer":"<p><strong>Состояние гонки</strong> (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные ошибки.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#существует-ли-способ-решения-проблемы-race-condition","title":"<p>Существует ли способ решения проблемы <em>race condition</em>?</p>","answer":"<p>Распространённые способы решения:</p>\n<ul>\n<li><strong>Использование локальной копии</strong> — копирование разделяемой переменной в локальную переменную потока. Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду), использование <code>volatile</code>.</li>\n<li><strong>Синхронизация</strong> - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова <code>synchronized</code>).</li>\n<li><strong>Комбинирование методов</strong> - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.</li>\n</ul>\n<p>Очевидных способов выявления и исправления состояний гонки не существует. Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-остановить-поток","title":"<p>Как остановить поток?</p>","answer":"<p>На данный момент в Java принят уведомительный порядок остановки потока (хотя JDK 1.0 и имеет несколько управляющих выполнением потока методов, например <code>stop()</code>, <code>suspend()</code> и <code>resume()</code> - в следующих версиях JDK все они были помечены как <code>deprecated</code> из-за потенциальных угроз взаимной блокировки).</p>\n<p>Для корректной остановки потока можно использовать метод класса <code>Thread</code> - <code>interrupt()</code>. Этот метод выставляет некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода <code>isInterrupted()</code> или <code>Thread.interrupted()</code> (для текущего потока). Метод <code>interrupt()</code> также способен вывести поток из состояния ожидания или спячки. Т.е. если у потока были вызваны методы <code>sleep()</code> или <code>wait()</code> – текущее состояние прервется и будет выброшено исключение <code>InterruptedException</code>. Флаг в этом случае не выставляется.</p>\n<p>Схема действия при этом получается следующей:</p>\n<ul>\n<li>Реализовать поток.</li>\n<li>В потоке периодически проводить проверку статуса прерывания через вызов <code>isInterrupted()</code>.</li>\n<li>Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются остановить извне.</li>\n<li>Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные потоком ресурсы и закончить выполнение.</li>\n</ul>\n<p>Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован на чтении данных - вызов <code>interrupt()</code> из этого состояния его не выведет. Решения тут различаются в зависимости от типа источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто дождаться выхода из метода <code>read()</code>. Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий ввод-вывод из Java NIO.</p>\n<p>Второй вариант реализации метода остановки (а также и приостановки) – сделать собственный аналог <code>interrupt()</code>. Т.е. объявить в классе потока флаги – на остановку и/или приостановку и выставлять их путем вызова заранее определённых методов извне. Методика действия при этом остаётся прежней – проверять установку флагов и принимать решения при их изменении. Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не «оживить». Во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление переменной у второго потока может произойти через неопределенный промежуток времени (хотя допустимым решением будет объявить переменную-флаг как <code>volatile</code>).</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#почему-не-рекомендуется-использовать-метод-threadstop","title":"<p>Почему не рекомендуется использовать метод <code>Thread.stop()</code>?</p>","answer":"<p>При принудительной остановке (приостановке) потока, <code>stop()</code> прерывает поток в недетерменированном месте выполнения, в результате становится совершенно непонятно, что делать с принадлежащими ему ресурсами. Поток может открыть сетевое соединение - что в таком случае делать с данными, которые еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? Если поток блокировал разделяемый ресурс, то как снять эту блокировку и не переведёт ли принудительное снятие к нарушению консистентности системы? То же самое можно расширить и на случай соединения с базой данных: если поток остановят посередине транзакции, то кто ее будет закрывать? Кто и как будет разблокировать ресурсы?</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-происходит-когда-в-потоке-выбрасывается-исключение","title":"<p>Что происходит, когда в потоке выбрасывается исключение?</p>","answer":"<ul>\n<li>Если исключение не поймано – поток «умирает» (переходит в состояние мёртв (dead)).</li>\n<li>Если установлен обработчик непойманных исключений, то он возьмёт управление на себя. <code>Thread.UncaughtExceptionHandler</code> – интерфейс, определённый как вложенный интерфейс для других обработчиков, вызываемых, когда поток внезапно останавливается из-за непойманного исключения. В случае, если поток собирается остановиться из-за непойманного исключения, JVM проверяет его на наличие <code>UncaughtExceptionHandler</code>, используя <code>Thread.getUncaughtExceptionHandler()</code>, и если такой обработчик найдет, то вызовет у него метод <code>uncaughtException()</code>, передав этот поток и исключение в виде аргументов.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чем-разница-между-interrupted-и-isinterrupted","title":"<p>В чем разница между <code>interrupted()</code> и <code>isInterrupted()</code>?</p>","answer":"<p>Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. Прерывание потока вызовом <code>Thread.interrupt()</code> устанавливает этот флаг. Методы <code>Thread.interrupted()</code> и <code>isInterrupted()</code> позволяют проверить, является ли поток прерванным.</p>\n<p>Когда прерванный поток проверяет статус прерывания, вызывая статический метод <code>Thread.interrupted()</code>, статус прерывания сбрасывается.</p>\n<p>Нестатический метод <code>isInterrupted()</code> используется одним потоком для проверки статуса прерывания у другого потока, не изменяя флаг прерывания.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-пул-потоков","title":"<p>Что такое <em>«пул потоков»</em>?</p>","answer":"<p>Создание потока является затратной по времени и ресурсам операцией. Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool), который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.</p>\n<p>Начиная с Java 1.5 Java API предоставляет фреймворк <code>Executor</code>, который позволяет создавать различные типы пула потоков:</p>\n<ul>\n<li><code>Executor</code> - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;</li>\n<li><code>ExecutorService</code> - расширенный интерфейс пула, с возможностью завершения всех потоков;</li>\n<li><code>AbstractExecutorService</code> - базовый класс пула, реализующий интерфейс <code>ExecutorService</code>;</li>\n<li><code>Executors</code> - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;</li>\n<li><code>ThreadPoolExecutor</code> - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;</li>\n<li><code>ForkJoinPool</code> - пул для выполнения задач типа <code>ForkJoinTask</code>;</li>\n<li>… и другие.</li>\n</ul>\n<p>Методы <code>Executors</code> для создания пулов:</p>\n<ul>\n<li><code>newCachedThreadPool()</code> - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. Потоки не используемые больше минуты завершаются и удаляются и кэша. Размер пула неограничен. Предназначен для выполнения множество небольших асинхронных задач;</li>\n<li><code>newCachedThreadPool(ThreadFactory threadFactory)</code> - аналогично предыдущему, но с собственной фабрикой потоков;</li>\n<li><code>newFixedThreadPool(int nThreads)</code> - создает пул на указанное число потоков. Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. Потоки живут до тех пор, пока пул не будет закрыт явно методом <code>shutdown()</code>.</li>\n<li><code>newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</code> - аналогично предыдущему, но с собственной фабрикой потоков;</li>\n<li><code>newSingleThreadScheduledExecutor()</code> - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.</li>\n<li><code>newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</code> - аналогично предыдущему, но с собственной фабрикой потоков;</li>\n<li><code>newScheduledThreadPool(int corePoolSize)</code> - пул для выполнения задач через указанное время или периодически;</li>\n<li><code>newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</code> - аналогично предыдущему, но с собственной фабрикой потоков;</li>\n<li><code>unconfigurableExecutorService(ExecutorService executor)</code> - обертка на пул, запрещающая изменять его конфигурацию;</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#какого-размера-должен-быть-пул-потоков","title":"<p>Какого размера должен быть пул потоков?</p>","answer":"<p>Настраивая размер пула потоков, важно избежать двух ошибок: слишком мало потоков (очередь на выполнение будет расти, потребляя много памяти) или слишком много потоков (замедление работы всей систему из-за частых переключений контекста).</p>\n<p>Оптимальный размер пула потоков зависит от количества доступных процессоров и природы задач в рабочей очереди. На N-процессорной системе для рабочей очереди, которая будет выполнять исключительно задачи с ограничением по скорости вычислений, можно достигнуть максимального использования CPU с пулом потоков, в котором содержится N или N+1 поток.\nДля задач, которые могут ждать осуществления I/O (ввода - вывода) - например, задачи, считывающей HTTP-запрос из сокета – может понадобиться увеличение размера пула свыше количества доступных процессоров, потому, что не все потоки будут работать все время. Используя профилирование, можно оценить отношение времени ожидания (<code>WT</code>) ко времени обработки (<code>ST</code>) для типичного запроса. Если назвать это соотношение <code>WT/ST</code>, то для N-процессорной системе понадобится примерно <code>N*(1 + WT/ST)</code> потоков для полной загруженности процессоров.</p>\n<p>Использование процессора – не единственный фактор, важный при настройке размера пула потоков. По мере возрастания пула потоков, можно столкнуться с ограничениями планировщика, доступной памяти, или других системных ресурсов, таких, как количество сокетов, дескрипторы открытого файла, или каналы связи базы данных.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-будет-если-очередь-пула-потоков-уже-заполнена-но-подаётся-новая-задача","title":"<p>Что будет, если очередь пула потоков уже заполнена, но подаётся новая задача?</p>","answer":"<p>Если очередь пула потоков заполнилась, то поданная задача будет «отклонена». Например - метод <code>submit()</code> у <code>ThreadPoolExecutor</code> выкидывает <code>RejectedExecutionException</code>, после которого вызывается <code>RejectedExecutionHandler</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чём-заключается-различие-между-методами-submit-и-execute-у-пула-потоков","title":"<p>В чём заключается различие между методами <code>submit()</code> и <code>execute()</code> у пула потоков?</p>","answer":"<p>Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.</p>\n<p><code>execute(Runnable command)</code> определён в интерфейсе <code>Executor</code> и выполняет поданную задачу и ничего не возвращает.</p>\n<p><code>submit()</code> – перегруженный метод, определённый в интерфейсе <code>ExecutorService</code>. Способен принимать задачи типов <code>Runnable</code> и <code>Callable</code> и возвращать объект <code>Future</code>, который можно использовать для контроля и управления процессом выполнения, получения его результата.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#в-чем-заключаются-различия-между-стеком-stack-и-кучей-heap-с-точки-зрения-многопоточности","title":"<p>В чем заключаются различия между стеком (stack) и кучей (heap) с точки зрения многопоточности?</p>","answer":"<p><strong>Стек</strong> – участок памяти, тесно связанный с потоками. У каждого потока есть свой стек, которые хранит локальные переменные, параметры методов и стек вызовов. Переменная, хранящаяся в стеке одного потока, не видна для другого.</p>\n<p><strong>Куча</strong> – общий участок памяти, который делится между всеми потоками. Объекты, неважно локальные или любого другого уровня, создаются в куче. Для улучшения производительности, поток обычно кэширует значения из кучи в свой стек, в этом случае для того, чтобы указать потоку, что переменную следует читать из кучи используется ключевое слово <code>volatile</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-поделиться-данными-между-двумя-потоками","title":"<p>Как поделиться данными между двумя потоками?</p>","answer":"<p>Данными между потоками возможно делиться, используя общий объект или параллельные структуры данных, например <code>BlockingQueue</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#какой-параметр-запуска-jvm-используется-для-контроля-размера-стека-потока","title":"<p>Какой параметр запуска JVM используется для контроля размера стека потока?</p>","answer":"<p><code>-Xss</code></p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-получить-дамп-потока","title":"<p>Как получить дамп потока?</p>","answer":"<p>Среды исполнения Java на основе HotSpot генерируют только дамп в формате HPROF. В распоряжении разработчика имеется несколько интерактивных методов генерации дампов и один метод генерации дампов на основе событий.</p>\n<p>Интерактивные методы:</p>\n<ul>\n<li>Использование <kbd>Ctrl+Break</kbd>: если для исполняющегося приложения установлена опция командной строки <code>-XX:+HeapDumpOnCtrlBreak</code>, то дамп формата HPROF генерируется вместе с дампом потока при наступлении события <code>Ctrl+Break</code> или <code>SIGQUIT</code> (обычно генерируется с помощью <em>kill -3</em>), которое инициируется посредством консоли. Эта опция может быть недоступна в некоторых версиях. В этом случае можно попытаться использовать следующую опцию:\n<code>-Xrunhprof:format=b,file=heapdump.hprof</code></li>\n<li>Использование инструмента <em>jmap</em>: утилита <em>jmap</em>, поставляемая в составе каталога <code>/bin/</code> комплекта JDK, позволяет запрашивать дамп HPROF из исполняющегося процесса.</li>\n<li>Использование операционной системы: Для создания файла ядра можно воспользоваться неразрушающей командой <em>gcore</em> или разрушающими командами <em>kill -6</em> или <em>kill -11</em>. Затем извлечь дамп кучи из файла ядра с помощью утилиты <em>jmap</em>.</li>\n<li>Использование инструмента <em>JConsole</em>. Операция <code>dumpHeap</code> предоставляется в <em>JConsole</em> как MBean-компонент <code>HotSpotDiagnostic</code>. Эта операция запрашивает генерацию дампа в формате HPROF.</li>\n</ul>\n<p>Метод на основе событий:</p>\n<ul>\n<li>Событие <code>OutOfMemoryError</code>: Если для исполняющегося приложения установлена опция командной строки <code>-XX:+HeapDumpOnOutOfMemoryError</code>, то при возникновении ошибки <code>OutOfMemoryError</code> генерируется дамп формата HPROF. Это идеальный метод для «production» систем, поскольку он практически обязателен для диагностирования проблем памяти и не сопровождается постоянными накладными расходами с точки зрения производительности. В старых выпусках сред исполнения Java на базе HotSpot для этого события не устанавливается предельное количество дампов кучи в пересчете на одну JVM; в более новых выпусках допускается не более одного дампа кучи для этого события на каждый запуск JVM.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-threadlocal-переменная","title":"<p>Что такое <em>ThreadLocal-переменная</em>?</p>","answer":"<p><code>ThreadLocal</code> - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.</p>\n<p>У каждого потока - т.е. экземпляра класса <code>Thread</code> - есть ассоциированная с ним таблица <em>ThreadLocal-переменных</em>. Ключами таблицы являются ссылки на объекты класса <code>ThreadLocal</code>, а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через методы <code>get()</code> или <code>set()</code>.</p>\n<p>Например, если мы объявим ThreadLocal-переменную: <code>ThreadLocal&lt;Object&gt; locals = new ThreadLocal&lt;Object&gt;();</code>. А затем, в потоке, сделаем <code>locals.set(myObject)</code>, то ключом таблицы будет ссылка на объект <code>locals</code>, а значением - ссылка на объект <code>myObject</code>. При этом для другого потока существует возможность «положить» внутрь <code>locals</code> другое значение.</p>\n<p>Следует обратить внимание, что <code>ThreadLocal</code> изолирует именно ссылки на объекты, а не сами объекты. Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.</p>\n<p>Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться. Ошибкой является инициализация такой переменной (вызов метода <code>set()</code>) в главном потоке приложения, потому как в данном случае значение, переданное в методе <code>set()</code>, будет «захвачено» для главного потока, и при вызове метода <code>get()</code> в целевом потоке будет возвращен <code>null</code>.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#назовите-различия-между-synchronized-и-reentrantlock","title":"<p>Назовите различия между <code>synchronized</code> и <code>ReentrantLock</code>?</p>","answer":"<p>В Java 5 появился интерфейс <code>Lock</code> предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов. <code>ReentrantLock</code> – распространённая реализация <code>Lock</code>, которая предоставляет <code>Lock</code> с таким же базовым поведением и семантикой, как у <code>synchronized</code>, но расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой <em>состязательности</em>.</p>\n<p>Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой, и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.</p>\n<pre><code class=\"java language-java\">Lock lock = new ReentrantLock();\n\nlock.lock();\ntry {\n  // update object state\n}\nfinally {\n  lock.unlock();\n}\n</code></pre>\n<ul>\n<li>Реализация <code>ReentrantLock</code> гораздо более масштабируема в условиях состязательности, чем реализация <code>synchronized</code>. Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у <code>ReentrantLock</code>, чем у <code>synchronized</code>. JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.</li>\n<li>У <code>ReentrantLock</code> (как и у других реализаций <code>Lock</code>) блокировка должна обязательно сниматься в <code>finally</code> блоке (иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.</li>\n</ul>\n<p>Резюмируя можно сказать, что когда состязания за блокировку нет либо оно очень мало, то <code>synchronized</code> возможно будет быстрее. Если присутствует заметное состязание за доступ к ресурсу, то скорее всего <code>ReentrantLock</code> даст некое преимущество.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-readwritelock","title":"<p>Что такое <code>ReadWriteLock</code>?</p>","answer":"<p><code>ReadWriteLock</code> – это интерфейс расширяющий базовый интерфейс <code>Lock</code>. Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий. Блокировка записи является эксклюзивной.</p>\n<p>Существует реализующий интерфейс <code>ReadWriteLock</code> класс <code>ReentrantReadWriteLock</code>, который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.</p>\n<pre><code class=\"java language-java\">ReadWriteLock rwLock = new ReentrantReadWriteLock();\nLock rLock = rwLock.readLock();\nLock wLock = rwLock.writeLock();\n\nwLock.lock();\ntry {\n    // exclusive write\n} finally {\n    wLock.unlock();\n}\n\nrLock.lock();\ntry {\n    // shared reading\n} finally {\n    rLock.unlock();\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-блокирующий-метод","title":"<p>Что такое <em>«блокирующий метод»</em>?</p>","answer":"<p><strong>Блокирующий метод</strong> – метод, который блокируется, до тех пор, пока задание не выполнится, например метод <code>accept()</code> у <code>ServerSocket</code> блокируется в ожидании подключения клиента. Здесь блокирование означает, что контроль не вернётся к вызывающему методу до тех пор, пока не выполнится задание. Так же существуют асинхронные или неблокирующиеся методы, которые могут завершится до выполнения задачи.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-фреймворк-forkjoin","title":"<p>Что такое <em>«фреймворк Fork/Join»</em>?</p>","answer":"<p>Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров. Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.</p>\n<ul>\n<li>Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.</li>\n<li>Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.</li>\n</ul>\n<p>Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.</p>\n<blockquote>\n  <p>Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.</p>\n</blockquote>\n<p>Ещё одно замечательное преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-semaphore","title":"<p>Что такое <code>Semaphore</code>?</p>","answer":"<p>Semaphore – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-double-checked-locking-singleton","title":"<p>Что такое <em>double checked locking Singleton</em>?</p>","answer":"<p><strong>double checked locking Singleton</strong> - это один из способов создания потокобезопасного класса реализующего шаблон Одиночка. Данный метод пытается оптимизировать производительность, блокируясь только случае, когда экземпляр одиночки создаётся впервые.</p>\n<pre><code class=\"java language-java\">class DoubleCheckedLockingSingleton {\n    private static volatile DoubleCheckedLockingSingleton instance;\n\n    static DoubleCheckedLockingSingleton getInstance() {\n        DoubleCheckedLockingSingleton current = instance;\n        if (current == null) {\n            synchronized (DoubleCheckedLockingSingleton.class) {\n                current = instance;\n\n                if (current == null) {\n                    instance = current = new DoubleCheckedLockingSingleton();\n                }\n            }\n        }\n        return current;\n    }\n}\n</code></pre>\n<p>Следует заметить, что требование <code>volatile</code> обязательно. Проблема Double Checked Lock заключается в модели памяти Java, точнее в порядке создания объектов, когда возможна ситуация, при которой другой поток может получить и начать использовать (на основании условия, что указатель не нулевой) не полностью сконструированный объект. Хотя эта проблема была частично решена в JDK 1.5, однако рекомендация использовать <code>voloatile</code> для Double Checked Lock остаётся в силе.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#как-создать-потокобезопасный-singleton","title":"<p>Как создать потокобезопасный Singleton?</p>","answer":"<ul>\n<li><strong>Static field</strong></li>\n</ul>\n<pre><code class=\"java language-java\">public class Singleton {\n public static final Singleton INSTANCE = new Singleton();\n}\n</code></pre>\n<ul>\n<li><strong>Enum</strong></li>\n</ul>\n<pre><code class=\"java language-java\">public enum Singleton {\n INSTANCE;\n}\n</code></pre>\n<ul>\n<li><strong>Synchronized Accessor</strong></li>\n</ul>\n<pre><code class=\"java language-java\">public class Singleton {\n private static Singleton instance;\n\n public static synchronized Singleton getInstance() {\n  if (instance == null) {\n   instance = new Singleton();\n  }\n  return instance;\n }\n}\n</code></pre>\n<ul>\n<li><strong>Double Checked Locking & <code>volatile</code></strong></li>\n</ul>\n<pre><code class=\"java language-java\">public class Singleton {\n        private static volatile Singleton instance;\n\n        public static Singleton getInstance() {\n  Singleton localInstance = instance;\n  if (localInstance == null) {\n   synchronized (Singleton.class) {\n    localInstance = instance;\n    if (localInstance == null) {\n     instance = localInstance = new Singleton();\n    }\n   }\n  }\n  return localInstance;\n }\n}\n</code></pre>\n<ul>\n<li><strong>On Demand Holder Idiom</strong></li>\n</ul>\n<pre><code class=\"java language-java\">public class Singleton {\n\n public static class SingletonHolder {\n  public static final Singleton HOLDER_INSTANCE = new Singleton();\n }\n\n public static Singleton getInstance() {\n  return SingletonHolder.HOLDER_INSTANCE;\n }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#чем-полезны-неизменяемые-объекты","title":"<p>Чем полезны неизменяемые объекты?</p>","answer":"<p>Неизменяемость (immutability) помогает облегчить написание многопоточного кода. Неизменяемый объект может быть использован без какой-либо синхронизации. К сожалению в Java нет аннотации <code>@Immutable</code>, которая делает объект неизменяемым, для этого разработчикам нужно самим создавать класс с необходимыми характеристиками. Для этого необходимо следовать некоторым общим принципам: инициализация всех полей только конструкторе, отсутствие методов <code>setX()</code> вносящих изменения в поля класса, отсутствие утечек ссылки, организация отдельного хранилища копий изменяемых объектов и т.д.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#что-такое-busy-spin","title":"<p>Что такое <em>busy spin</em>?</p>","answer":"<p><strong>busy spin</strong> – это техника, которую программисты используют, чтобы заставить поток ожидать при определённом условии. В отличие от традиционных методов <code>wait()</code>, <code>sleep()</code> или <code>yield()</code>, которые подразумевают уступку процессорного времени, этот метод вместо уступки выполняет пустой цикл. Это необходимо, для того, чтобы сохранить кэш процессора, т.к. в многоядерных системах, существует вероятность, что приостановленный поток продолжит своё выполнение уже на другом ядре, а это повлечет за собой перестройку состояния процессорного кэша, которая является достаточно затратной процедурой.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#перечислите-принципы-которым-вы-следуете-в-многопоточном-программировании","title":"<p>Перечислите принципы, которым вы следуете в многопоточном программировании?</p>","answer":"<p>При написании многопоточных программ следует придерживаться определённых правил, которые помогают обеспечить достойную производительность приложения в сочетании с удобной отладкой и простотой дальнейшей поддержки кода.</p>\n<ul>\n<li>Всегда давайте значимые имена своим потокам. Процесс отладки, нахождения ошибок или отслеживание исключения в многопоточном коде – довольно сложная задача. <code>OrderProcessor</code>, <code>QuoteProcessor</code> или <code>TradeProcessor</code> намного информативнее, чем <code>Thread1</code>, <code>Thread2</code> и <code>Thread3</code>. Имя должно отражать задачу, выполняемую данным потоком.</li>\n<li>Избегайте блокировок или старайтесь уменьшить масштабы синхронизации. Блокировка затратна, а переключение контекста ещё более ресурсоёмко. Пытайтесь избегать синхронизации и блокировки насколько это возможно, и организуйте критическую секцию в минимально необходимом объёме. Поэтому синхронизированный блок всегда предпочтительней синхронизированного метода, дополнительно наделяя возможностью абсолютного контроля над масштабом блокировки.</li>\n<li>Обрабатывайте прерывание потока с особой тщательностью. Нет ничего хуже оставшегося заблокированным ресурса или системы в неконстистентном, по причине неподтверждённой транзакции, состоянии.</li>\n<li>Помните об обработке исключений. Выброшенные <code>InterruptedException</code> должны быть адекватно обработаны, а не просто подавлены. Так же не стоит пренебрегать <code>Thread.UncaughtExceptionHandler</code>. При использовании пула потоков необходимо помнить, что он зачастую просто «проглатывает» исключения. Так, если вы отправили на выполнение <code>Runnable</code> нужно обязательно поместить код выполнения задачи внутрь блока <code>try-catch</code>. Если в очередь пула помещается <code>Callable</code>, необходимо удостоверится, что результат выполнения всегда изымается помощью блокирующего <code>get()</code>, чтобы в случае возникновения существовала возможность заново выбросить произошедшее исключение.</li>\n<li>Между синхронизаторами и <code>wait()</code> и <code>notify()</code> следует выбирать синхронизаторы. Во-первых, синхронизаторы, типа <code>CountDownLatch</code>, <code>Semaphore</code>, <code>CyclicBarrier</code> или <code>Exchanger</code> упрощают написание кода. Очень сложно реализовывать комплексный управляющий поток, используя <code>wait()</code> и <code>notify()</code>. Во-вторых, эти классы написаны и поддерживаются настоящими мастерами своего дела и есть шанс, что в последующих версиях JDK они будут оптимизированы изнутри или заменены более производительной внешней реализацией.</li>\n<li>Почти всегда использование Concurrent collection выгоднее использования Synchronized collection, т.к. первые более современны (используют все доступные на момент их написания новшества языка) и масштабируемы, чем их синхронизированные аналоги.</li>\n</ul>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#какое-из-следующих-утверждений-о-потоках-неверно","title":"<p>Какое из следующих утверждений о потоках неверно?</p>","answer":"<ol>\n<li>Если метод <code>start()</code> вызывается дважды для одного и того же объекта <code>Thread</code>, во время выполнения генерируется исключение.</li>\n<li>Порядок, в котором запускались потоки, может не совпадать с порядком их фактического выполнения.</li>\n<li>Если метод <code>run()</code> вызывается напрямую для объекта <code>Thread</code>, во время выполнения генерируется исключение.</li>\n<li>Если метод <code>sleep()</code> вызывается для потока, во время выполнения синхронизированного кода, блокировка не снимается.</li>\n</ol>\n<p>Правильный ответ: 3. Если метод <code>run()</code> вызывается напрямую для объекта <code>Thread</code>, во время выполнения исключение не генерируется. Однако код, написанный в методе <code>run()</code> будет выполняться текущим, а не новым потоком. Таким образом, правильный способ запустить поток – это вызов метода <code>start()</code>, который приводит к выполнению метода <code>run()</code> новым потоком.</p>\n<p>Вызов метода <code>start()</code> дважды для одного и того же объекта <code>Thread</code> приведёт к генерированию\nисключения <code>IllegalThreadStateException</code> во время выполнения, следовательно, утверждение 1 верно. Утверждение 2 верно,\nтак как порядок, в котором выполняются потоки, определяется Планировщиком потоков, независимо от того, какой поток\nзапущен первым. Утверждение 4 верно, так как поток не освободит блокировки, которые он держит, когда он переходит в\nсостояние Ожидания.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#даны-3-потока-t1-t2-и-t3-как-реализовать-выполнение-в-последовательности-t1-t2-t3","title":"<p>Даны 3 потока T1, T2 и T3? Как реализовать выполнение в последовательности T1, T2, T3?</p>","answer":"<p>Такой последовательности выполнения можно достичь многими способами, например просто воспользоваться методом <code>join()</code>,\nчтобы запустить поток в момент, когда другой уже закончит своё выполнение. Для реализации заданной последовательности,\nнужно запустить последний поток первым, и затем вызывать метод <code>join()</code> в обратном порядке, то есть T3\nвызывает <code>T2.join</code>, а T2 вызывает <code>T1.join</code>, таким образом T1 закончит выполнение первым, а T3 последним.</p>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-минимальный-неблокирующий-стек-всего-два-метода-—-push-и-pop","title":"<p>Напишите минимальный неблокирующий стек (всего два метода — <code>push()</code> и <code>pop()</code>)</p>","answer":"<pre><code class=\"java language-java\">class NonBlockingStack&lt;T&gt; {\n    private final AtomicReference&lt;Element&gt; head = new AtomicReference&lt;&gt;(null);\n\n    Stack&lt;T&gt; push(final T value) {\n        final Element current = new Element();\n        current.value = value;\n        Element recent;\n        do {\n            recent = head.get();\n            current.previous = recent;\n        } while (!head.compareAndSet(recent, current));\n        return this;\n    }\n\n    T pop() {\n        Element result;\n        Element previous;\n        do {\n            result = head.get();\n            if (result == null) {\n                return null;\n            }\n            previous = result.previous;\n        } while (!head.compareAndSet(result, previous));\n        return result.value;\n    }\n\n    private class Element {\n        private T value;\n        private Element previous;\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-минимальный-неблокирующий-стек-всего-два-метода-—-push-и-pop-с-использованием-semaphore","title":"<p>Напишите минимальный неблокирующий стек (всего два метода — <code>push()</code> и <code>pop()</code>) с использованием <code>Semaphore</code></p>","answer":"<pre><code class=\"java language-java\">class SemaphoreStack&lt;T&gt; {\n    private final Semaphore semaphore = new Semaphore(1);\n    private Node&lt;T&gt; head = null;\n\n    SemaphoreStack&lt;T&gt; push(T value) {\n        semaphore.acquireUninterruptibly();\n        try {\n            head = new Node&lt;&gt;(value, head);\n        } finally {\n            semaphore.release();\n        }\n\n        return this;\n    }\n\n    T pop() {\n        semaphore.acquireUninterruptibly();\n        try {\n            Node&lt;T&gt; current = head;\n            if (current != null) {\n                head = head.next;\n                return current.value;\n            }\n            return null;\n        } finally {\n            semaphore.release();\n        }\n    }\n\n    private static class Node&lt;E&gt; {\n        private final E value;\n        private final Node&lt;E&gt; next;\n\n        private Node(E value, Node&lt;E&gt; next) {\n            this.value = value;\n            this.next = next;\n        }\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-минимальный-неблокирующий-arraylist-всего-четыре-метода-—-add-get-remove-size","title":"<p>Напишите минимальный неблокирующий ArrayList (всего четыре метода — <code>add()</code>, <code>get()</code>, <code>remove()</code>, <code>size()</code>)</p>","answer":"<pre><code class=\"java language-java\">class NonBlockingArrayList&lt;T&gt; {\n    private volatile Object[] content = new Object[0];\n\n    NonBlockingArrayList&lt;T&gt; add(T item) {\n        return add(content.length, item);\n    }\n\n    NonBlockingArrayList&lt;T&gt; add(int index, T item) {\n        if (index &lt; 0) {\n            throw new IllegalArgumentException();\n        }\n        boolean needsModification = index &gt; content.length - 1;\n        if (!needsModification) {\n            if (item == null) {\n                needsModification = content[index] != null;\n            } else {\n                needsModification = item.equals(content[index]);\n            }\n        }\n        if (needsModification) {\n            final Object[] renewed = Arrays.copyOf(content, Math.max(content.length, index + 1));\n            renewed[index] = item;\n            content = renewed;\n        }\n        return this;\n    }\n\n    NonBlockingArrayList&lt;T&gt; remove(int index) {\n        if (index &lt; 0 || index &gt;= content.length) {\n            throw new IllegalArgumentException();\n        }\n        int size = content.length - 1;\n        final Object[] renewed = new Object[size];\n        System.arraycopy(content, 0, renewed, 0, index);\n        if (index + 1 &lt; size) {\n            System.arraycopy(content, index + 1, renewed, index, size - index);\n        }\n        content = renewed;\n        return this;\n    }\n\n    T get(int index) {\n        return (T) content[index];\n    }\n\n    int size() {\n        return content.length;\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-потокобезопасную-реализацию-класса-с-неблокирующим-методом-biginteger-next-который-возвращает-элементы-последовательности-1-2-4-8-16-","title":"<p>Напишите потокобезопасную реализацию класса с неблокирующим методом <code>BigInteger next()</code>, который возвращает элементы последовательности: <code>[1, 2, 4, 8, 16, ...]</code></p>","answer":"<pre><code class=\"java language-java\">class PowerOfTwo {\n    private AtomicReference&lt;BigInteger&gt; current = new AtomicReference&lt;&gt;(null);\n\n    BigInteger next() {\n        BigInteger recent, next;\n        do {\n            recent = current.get();\n            next = (recent == null) ? BigInteger.valueOf(1) : recent.shiftLeft(1);\n        } while (!current.compareAndSet(recent, next));\n        return next;\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-простейший-многопоточный-ограниченный-буфер-с-использованием-synchronized","title":"<p>Напишите простейший многопоточный ограниченный буфер с использованием <code>synchronized</code></p>","answer":"<pre><code class=\"java language-java\">class QueueSynchronized&lt;T&gt; {\n    private volatile int size = 0;\n    private final Object[] content;\n    private final int capacity;\n\n    private int out;\n    private int in;\n\n    private final Object isEmpty = new Object();\n    private final Object isFull = new Object();\n\n    QueueSynchronized(final int capacity) {\n        this.capacity = capacity;\n        content = new Object[this.capacity];\n        out = 0;\n        in = 0;\n        size = 0;\n    }\n\n    private int cycleInc(int index) {\n        return (++index == capacity)\n                ? 0\n                : index;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T get() throws InterruptedException {\n        if (size == 0) {\n            synchronized (isEmpty) {\n                while (size &lt; 1) {\n                    isEmpty.wait();\n                }\n            }\n        }\n        try {\n            synchronized (this) {\n                final Object value = content[out];\n                content[out] = null;\n                if (size &gt; 1) {\n                    out = cycleInc(out);\n                }\n                size--;\n                return (T) value;\n            }\n        } finally {\n            synchronized (isFull) {\n                isFull.notify();\n            }\n        }\n    }\n\n    QueueSynchronized&lt;T&gt; put(T value) throws InterruptedException {\n        if (size == capacity) {\n            synchronized (isFull) {\n                while (size == capacity) {\n                    isFull.wait();\n                }\n            }\n        }\n        synchronized (this) {\n            if (size == 0) {\n                content[in] = value;\n            } else {\n                in = cycleInc(in);\n                content[in] = value;\n            }\n            size++;\n        }\n        synchronized (isEmpty) {\n            isEmpty.notify();\n        }\n        return this;\n    }\n}\n</code></pre>"},{"subject":"Многопоточность в Java","url":"009-concurrency.html#напишите-простейший-многопоточный-ограниченный-буфер-с-использованием-reentrantlock","title":"<p>Напишите простейший многопоточный ограниченный буфер с использованием <code>ReentrantLock</code></p>","answer":"<pre><code class=\"java language-java\">class QueueReentrantLock&lt;T&gt; {\n\n    private volatile int size = 0;\n    private final Object[] content;\n    private final int capacity;\n\n    private int out;\n    private int in;\n\n    private final ReentrantLock lock = new ReentrantLock();\n    private final Condition isEmpty = lock.newCondition();\n    private final Condition isFull = lock.newCondition();\n\n    QueueReentrantLock(int capacity) {\n        try {\n            lock.lock();\n            this.capacity = capacity;\n            content = new Object[capacity];\n            out = 0;\n            in = 0;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private int cycleInc(int index) {\n        return (++index == capacity)\n                ? 0\n                : index;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    T get() throws InterruptedException {\n        try {\n            lock.lockInterruptibly();\n            if (size == 0) {\n                while (size &lt; 1) {\n                    isEmpty.await();\n                }\n            }\n            final Object value = content[out];\n            content[out] = null;\n            if (size &gt; 1) {\n                out = cycleInc(out);\n            }\n            size--;\n            isFull.signal();\n            return (T) value;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    QueueReentrantLock&lt;T&gt; put(T value) throws InterruptedException {\n        try {\n            lock.lockInterruptibly();\n            if (size == capacity) {\n                while (size == capacity) {\n                    isFull.await();\n                }\n            }\n            if (size == 0) {\n                content[in] = value;\n            } else {\n                in = cycleInc(in);\n                content[in] = value;\n            }\n            size++;\n            isEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n        return this;\n    }\n}\n</code></pre>\n<p><a href=\"#многопоточность-в-java\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://habrahabr.ru/post/164487/\">Хабрахабр - Многопоточность в Java</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/ru/library/l-java_universe_multithreading_tasks/\">IBM DeveloperWorks - Выполнение задач в многопоточном режиме</a></li>\n<li><a href=\"http://www.skipy.ru/technics/synchronization.html\">Записки трезвого практика</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/ru/edu/j-scjp/section8.html\">IBM DeveloperWorks - SCJP</a></li>\n<li><a href=\"http://info.javarush.ru/KapChook/2015/02/15/Перевод-Топ-50-интервью-вопросов-по-нитям-Часть-1-.html\">JavaRush</a></li>\n<li><a href=\"https://habrahabr.ru/post/277669/\">Хабрахабр - Справочник по синхронизаторам <code>java.util.concurrent.*</code></a></li>\n<li><a href=\"http://samolisov.blogspot.ru/2011/04/threadlocal.html\">Блог сурового челябинского программиста</a></li>\n<li><a href=\"http://www.ibm.com/developerworks/ru/library/j-jtp10264/\">IBM DeveloperWorks - Более гибкая, масштабируемая блокировка в JDK 5.0</a></li>\n<li><a href=\"https://habrahabr.ru/post/129494/\">Хабрахабр - Правильный Singleton в Java</a></li>\n<li><a href=\"http://www.duct-tape-architect.ru/?p=294#3__171_187___Java_HotSpot_JVM6\">duct-tape-architect.ru</a></li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#что-такое-сервлет","title":"<p>Что такое <em>«сервлет»</em>?</p>","answer":"<p><strong>Сервлет</strong> является интерфейсом, реализация которого расширяет функциональные возможности сервера. Сервлет взаимодействует с клиентами посредством принципа запрос-ответ. Хотя сервлеты могут обслуживать любые запросы, они обычно используются для расширения веб-серверов.</p>\n<p>Большинство необходимых для создания сервлетов классов и интерфейсов содержатся в пакетах <code>javax.servlet</code> и <code>javax.servlet.http</code>.</p>\n<p>Основные методы сервлета:</p>\n<ul>\n<li><code>public void init(ServletConfig config) throws ServletException</code> запускается сразу после загрузки сервлета в память;</li>\n<li><code>public ServletConfig getServletConfig()</code> возвращает ссылку на объект, который предоставляет доступ к информации о конфигурации сервлета;</li>\n<li><code>public String getServletInfo()</code> возвращает строку, содержащую информацию о сервлете, например: автор и версия сервлета;</li>\n<li><code>public void service(ServletRequest request, ServletResponse response) throws ServletException, java.io.IOException</code> вызывается для обработки каждого запроса;</li>\n<li><code>public void destroy()</code> выполняется перед выгрузкой сервлета из памяти.</li>\n</ul>\n<p>Текущая спецификация - Servlet 4.0 описана в JSR-369 и принята в июле 2017 году.</p>"},{"subject":"Servlets","url":"010-servlets.html#что-добавилось-в-спецификации-servlet-25-30-31-40","title":"<p>Что добавилось в спецификации Servlet 2.5, 3.0, 3.1, 4.0?</p>","answer":"<ul>\n<li><strong>версия 2.5 принята в сентябре 2005 года</strong> - Требует J2SE 5.0, поддержка аннотаций.</li>\n<li><strong>версия 3.0 принята в декабре 2009 года</strong> - Pluggability, простота разработки, асинхронные сервлеты, безопасность, загрузка файлов.</li>\n<li><strong>версия 3.1 принята в майе 2013 года</strong> - Неблокирующий ввод-вывод, поддержка нестандартных протоколов поверх HTTP</li>\n<li><strong>версия 4.0 принята в июле 2017 года</strong> - HTTP/2, Server Push.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#в-чем-заключаются-преимущества-технологии-сервлетов-над-cgi-common-gateway-interface","title":"<p>В чем заключаются преимущества технологии сервлетов над CGI (Common Gateway Interface)?</p>","answer":"<ul>\n<li>Сервлеты предоставляют лучшую производительность обработки запросов и более эффективное использование памяти за счет использования преимущество многопоточности (на каждый запрос создается новая нить, что быстрее выделения памяти под новый объект для каждого запроса, как это происходит в CGI).</li>\n<li>Сервлеты, как платформа и система являются независимыми. Таким образом веб-приложение написанное с использованием сервлетов может быть запущена в любом контейнере сервлетов, реализующим этот стандарт и в любой операционной системе.</li>\n<li>Использование сервлетов повышает надежность программы, т.к. контейнер сервлетов самостоятельно заботится о жизненном цикле сервлетов (а значит и за утечками памяти), безопасности и сборщике мусора.</li>\n<li>Сервлеты относительно легки в изучении и поддержке, таким образом разработчику необходимо заботиться только о бизнес-логике приложения, а не внутренней реализации веб-технологий.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#что-такое-контейнер-сервлетов","title":"<p>Что такое <em>«контейнер сервлетов»</em>?</p>","answer":"<p><strong>Контейнер сервлетов</strong> — программа, представляющая собой сервер, который занимается системной поддержкой сервлетов и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный веб-сервер, быть поставщиком страниц для другого веб-сервера, или интегрироваться в Java EE сервер приложений.</p>\n<p>Контейнер сервлетов обеспечивает обмен данными между сервлетом и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего сервлета, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.</p>\n<p>Наиболее известные реализации контейнеров сервлетов:</p>\n<ul>\n<li>Apache Tomcat</li>\n<li>Jetty</li>\n<li>JBoss</li>\n<li>WildFly</li>\n<li>GlassFish</li>\n<li>IBM WebSphere</li>\n<li>Oracle Weblogic</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#зачем-нужны-сервера-приложений-если-есть-контейнеры-сервлетов","title":"<p>Зачем нужны сервера приложений, если есть контейнеры сервлетов?</p>","answer":"<ul>\n<li><strong>Пулы соединений с БД</strong><ul>\n<li>Возможность периодического тестирования доступности СУБД и обновления соединения в случае восстановления после\nсбоев</li>\n<li>Замена прав доступа при подключении</li>\n<li>Балансировка нагрузки между несколькими СУБД, определение доступность или недоступность того или иного узла</li>\n<li>Защита пула соединений от некорректного кода в приложении, которое по недосмотру не возвращает соединения, просто\nотбирая его после какого-то таймаута.</li></ul></li>\n<li><strong>JMS</strong><ul>\n<li>Доступность сервера очередей сообщений \"из-коробки\".</li>\n<li>Возможность кластеризации очередей, т.е. доступность построения распределенных очередей, расположенных сразу на\nнескольких серверах, что существенно увеличивает масштабируемость и доступность приложения</li>\n<li>Возможность миграции очередей - в случае падения одного из серверов, его очереди автоматически перемещаются на\nдругой, сохраняя необработанные сообщения.</li>\n<li>В некоторых серверах приложений поддерживается <em>Unit-of-Order</em> - гарантированный порядок обработки сообщений,\nудовлетворяющих некоторым критериям.</li></ul></li>\n<li><strong>JTA</strong> Встроенная поддержка распределенных транзакций для обеспечения согласованности данных в разные СУБД или\nочереди.</li>\n<li><strong>Безопасность</strong><ul>\n<li>Наличие множества провайдеров безопасности и аутентификации:<ul>\n<li>во встроенном или внешнем <em>LDAP-сервере</em></li>\n<li>в базе данных</li>\n<li>в различных <em>Internet-directory</em> (специализированных приложениях для управления правами доступа)</li></ul></li>\n<li>Доступность <em>Single-Sign-On</em> (возможности разделения пользовательской сессии между приложениями) посредством\n<em>Security Assertion Markup Language (SAML) 1/2</em> или <em>Simple and Protected Negotiate (SPNEGO)</em> и <em>Kerberos</em>: один\nиз серверов выступает в роли базы для хранения пользователей, все другие сервера при аутентификации пользователя\nобращаются к этой базе.</li>\n<li>Возможность авторизации посредством протокола <em>eXtensible Access Control Markup Language (XACML)</em>, позволяющего\nописывать довольно сложные политики (например, приложение доступно пользователю только в рабочее время).</li>\n<li>Кластеризация всего вышеперечисленного</li></ul></li>\n<li><strong>Масштабируемость и высокая доступность</strong> Для контейнера сервлетов обычно так же возможно настроить кластеризацию, но\nона будет довольно примитивной, так как в случае его использования имеются следующие ограничения:<ul>\n<li>Сложность передачи пользовательской сессии из одного <em>центра обработки данных (ЦОД)</em> в другой через Интернет</li>\n<li>Отсутствие возможности эффективно настроить репликации сессий на большом (состоящем из 40-50 экземпляров серверов)\nкластере</li>\n<li>Невозможность обеспечения миграции экземпляров приложения на другой сервер</li>\n<li>Недоступность механизмов автоматического мониторинга и реакции на ошибки</li></ul></li>\n<li><strong>Управляемость</strong><ul>\n<li>Присутствие единого центра управления, т.н. <em>AdminServer</em> и аналога <em>NodeManager</em>’а, обеспечивающего<ul>\n<li>Возможность одновременного запуска нескольких экземпляров сервера</li>\n<li>Просмотр состояния запущенных экземпляров сервера, обработчиков той или иной очереди, на том или ином сервере,\nколичества соединений с той или иной БД</li></ul></li></ul></li>\n<li><strong>Административный канал и развертывание в промышленном режиме</strong> Некоторые сервера приложений позволяют включить так\nназываемый \"административный канал\" - отдельный порт, запросы по которому имеют приоритет.<ul>\n<li>Просмотр состояния (выполняющихся транзакций, потоков, очередей) в случае недоступности (\"зависания\") сервера</li>\n<li>Обновление приложений \"на-лету\", без простоя:<ul>\n<li>добавление на сервер новой версии приложения в \"закрытом\" режиме, пока пользователи продолжают работать со\nпредыдущей</li>\n<li>тестирование корректности развертывания новой версии</li>\n<li>\"скрытый\" перевод на использование новой версии всех пользователей</li></ul></li></ul></li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#как-контейнер-сервлетов-управляет-жизненным-циклом-сервлета-когда-и-какие-методы-вызываются","title":"<p>Как контейнер сервлетов управляет жизненным циклом сервлета, когда и какие методы вызываются?</p>","answer":"<p>Контейнер сервлетов управляет четырьмя фазами жизненного цикла сервлета:</p>\n<ul>\n<li>Загрузка класса сервлета — когда контейнер получает запрос для сервлета, то происходит загрузка класса сервлета в память и вызов его конструктора без параметров.</li>\n<li>Инициализация класса сервлета — после того как класс загружен контейнер инициализирует объект <code>ServletConfig</code> для этого сервлета и внедряет его через <code>init()</code> метод. Это и есть место где сервлет класс преобразуется из обычного класса в сервлет.</li>\n<li>Обработка запросов — после инициализации сервлет готов к обработке запросов. Для каждого запроса клиента сервлет контейнер порождает новый поток и вызывает метод <code>service()</code> путем передачи ссылки на объекты ответа и запроса.</li>\n<li>Удаление - когда контейнер останавливается или останавливается приложение, то контейнер сервлетов уничтожает классы сервлетов путем вызова <code>destroy()</code> метода.</li>\n</ul>\n<p>Таким образом, сервлет создаётся при первом обращении к нему и живёт на протяжении всего времени работы приложения (в отличие от объектов классов, которые уничтожаются сборщиком мусора после того как они уже не используются) и весь жизненный цикл сервлета можно описать как последовательность вызова методов:</p>\n<ul>\n<li><code>public void init(ServletConfig config)</code> – используется контейнером для инициализации сервлета. Вызывается один раз за время жизни сервлета.</li>\n<li><code>public void service(ServletRequest request, ServletResponse response)</code> – вызывается для каждого запроса. Метод не может быть вызван раньше выполнения <code>init()</code> метода.</li>\n<li><code>public void destroy()</code> – вызывается для уничтожения сервлета (один раз за время жизни сервлета).</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#что-такое-дескриптор-развертывания","title":"<p>Что такое <em>«дескриптор развертывания»</em>?</p>","answer":"<p>Дескриптор развертывания — это конфигурационный файл артефакта, который будет развернут в контейнере сервлетов. В спецификации Java Platform, Enterprise Edition дескриптор развертывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развернуто.</p>\n<p>Этот конфигурационный файл указывает параметры развертывания для модуля или приложения с определенными настройками, параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развертывания используется язык XML.</p>\n<p>Для веб-приложений дескриптор развертывания должен называться <code>web.xml</code> и находиться в директории <code>WEB-INF</code>, в корне веб-приложения. Этот файл является стандартным дескриптором развертывания, определенным в спецификации. Также есть и другие типы дескрипторов, такие, как файл дескриптора развертывания <code>sun-web.xml</code>, содержащий специфичные для <em>Sun GlassFish Enterprise Server</em> данные для развертывания именно для этого сервера приложений или файл <code>application.xml</code> в директории <code>META-INF</code> для приложений <em>J2EE</em>.</p>"},{"subject":"Servlets","url":"010-servlets.html#какие-действия-необходимо-проделать-при-создании-сервлетов","title":"<p>Какие действия необходимо проделать при создании сервлетов?</p>","answer":"<p>Чтобы создать сервлет <code>ExampleServlet</code>, необходимо описать его в дескрипторе развёртывания:</p>\n<pre><code class=\"xml language-xml\">&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/example&lt;/url-pattern&gt;\n&lt;/servlet-mapping&gt;\n&lt;servlet&gt;\n    &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;xyz.company.ExampleServlet&lt;/servlet-class&gt;\n    &lt;init-param&gt;\n        &lt;param-name&gt;config&lt;/param-name&gt;\n        &lt;param-value&gt;default&lt;/param-value&gt;\n    &lt;/init-param&gt;\n&lt;/servlet&gt;\n</code></pre>\n<p>Затем создать класс <code>xyz.company.ExampleServlet</code> путём наследования от <code>HttpServlet</code> и реализовать логику его работы в методе <code>service()</code> или методах <code>doGet()</code>/<code>doPost()</code>.</p>"},{"subject":"Servlets","url":"010-servlets.html#какие-наиболее-распространенные-задачи-выполняются-в-контейнере-сервлетов","title":"<p>Какие наиболее распространенные задачи выполняются в контейнере сервлетов?</p>","answer":"<ul>\n<li>Поддержка обмена данными. Контейнер сервлетов предоставляет легкий способ обмена данными между веб клиентом (браузером) и сервлетом. Благодаря контейнеру нет необходимости создавать слушателя сокета на сервере для отслеживания запросов от клиента, а так же разбирать запрос и генерировать ответ. Все эти важные и комплексные задачи решаются с помощью контейнера и разработчик может сосредоточиться на бизнес логике приложения.</li>\n<li>Управление жизненным циклом сервлетов и ресурсов. Начиная от загрузки сервлета в память, инициализации, внедрения методов и заканчивая уничтожением сервлета. Контейнер так же предоставляет дополнительные утилиты, например JNDI, для управления пулом ресурсов.</li>\n<li>Поддержка многопоточности. Контейнер самостоятельно создает новую нить для каждого запроса и предоставляет ей запрос и ответ для обработки. Таким образом сервлет не инициализируется заново для каждого запроса и тем самым сохраняет память и уменьшает время до обработки запроса.</li>\n<li>Поддержка JSP. JSP классы не похожи на стандартные классы Java, но контейнер сервлетов преобразует каждую JSP в сервлет и далее управляется контейнером как обычным сервлетом.</li>\n<li>Различные задачи. Контейнер сервлетов управляет пулом ресурсов, памятью приложения, сборщиком мусора. Предоставляются возможности настройки безопасности и многое другое.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#что-вы-знаете-о-сервлетных-фильтрах","title":"<p>Что вы знаете о <em>сервлетных фильтрах</em>?</p>","answer":"<p><strong>Сервлетный фильтр</strong> - это Java-код, пригодный для повторного использования и позволяющий преобразовать содержание HTTP-запросов, HTTP-ответов и информацию, содержащуюся в заголовках HTML. Сервлетный фильтр занимается предварительной обработкой запроса, прежде чем тот попадает в сервлет, и/или последующей обработкой ответа, исходящего из сервлета.</p>\n<p>Сервлетные фильтры могут:</p>\n<ul>\n<li>перехватывать инициацию сервлета прежде, чем сервлет будет инициирован;</li>\n<li>определить содержание запроса прежде, чем сервлет будет инициирован;</li>\n<li>модифицировать заголовки и данные запроса, в которые упаковывается поступающий запрос;</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#когда-стоит-использовать-фильтры-сервлетов-а-когда-слушателей","title":"<p>Когда стоит использовать фильтры сервлетов, а когда слушателей?</p>","answer":"<p>Следует использовать фильтры, если необходимо обрабатывать входящие или исходящие данные (например: для аутентификации, преобразования формата, компрессии, шифрования и т.д.), в случае, когда необходимо реагировать на события - лучше применять слушателей.</p>"},{"subject":"Servlets","url":"010-servlets.html#какие-основные-особенности-появились-в-спецификации-servlet-3","title":"<p>Какие основные особенности появились в спецификации <em>Servlet 3</em>?</p>","answer":"<ul>\n<li><strong>Servlet Annotations</strong>. До Servlet 3 вся конфигурация содержалась в <code>web.xml</code>, что приводило к ошибкам и неудобству при работе с большим количестве сервлетов. Примеры аннотаций: <code>@WebServlet</code>, <code>@WebInitParam</code>, <code>@WebFilter</code>, <code>@WebListener</code>.</li>\n<li><strong>Web Fragments</strong>. Одностраничное веб приложение может содержать множество модулей: все модули прописываются в <code>fragment.xml</code> в папке <code>META-INF\\</code>. Это позволяет разделять веб приложение на отдельные модули, собранные как .jar-файлы в отдельной <code>lib\\</code> директории.</li>\n<li><strong>Динамическое добавление веб компонентов</strong>. Появилась возможность программно добавлять фильтры и слушатели, используя <code>ServletContext</code> объект. Для этого применяются методы <code>addServlet()</code>, <code>addFilter()</code>, <code>addListener()</code>. Используя это нововведение стало доступным построение динамической системы, в которой необходимый объект будет создан и вызван только по необходимости.</li>\n<li><strong>Асинхронное выполнение</strong>. Поддержка асинхронной обработки позволяет передать выполнение запроса в другой поток без удержания всего сервера занятым.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#какие-способы-аутентификации-доступны-сервлету","title":"<p>Какие способы аутентификации доступны сервлету?</p>","answer":"<p>Спецификация сервлетов определяет четыре типа проверки подлинности:</p>\n<ul>\n<li><strong>HTTP Basic Authentication</strong> - <code>BASIC</code>. При доступе к закрытым ресурсам появится окно, которое попросит ввести данные для аутентификации.</li>\n<li><strong>Form Based Login</strong> - <code>FORM</code>. Используется собственная html форма:</li>\n<li><strong>HTTP Digest Authentication</strong> - <code>DIGEST</code>. Цифровая аутентификация с шифрованием.</li>\n<li><strong>HTTPS Authentication</strong> - <code>CLIENT-CERT</code>. Аутентификация с помощью клиентского сертификата.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#что-такое-java-server-pages-jsp","title":"<p>Что такое <em>Java Server Pages (JSP)</em>?</p>","answer":"<p><strong>JSP (JavaServer Pages)</strong> — платформонезависимая переносимая и легко расширяемая технология разработки веб-приложений,\nпозволяющая веб-разработчикам создавать содержимое, которое имеет как статические, так и динамические компоненты.\nСтраница JSP содержит текст двух типов: статические исходные данные, которые могут быть оформлены в одном из текстовых\nформатов HTML, SVG, WML, или XML, и <em>JSP-элементы</em>, которые конструируют динамическое содержимое. Кроме этого могут\nиспользоваться <em>библиотеки JSP-тегов</em>, а также <em>EL (Expression Language)</em>, для внедрения Java-кода в статичное\nсодержимое JSP-страниц. Код JSP-страницы транслируется в Java-код сервлета с помощью компилятора JSP-страниц <em>Jasper</em>, и\nзатем компилируется в байт-код JVM. JSP-страницы загружаются на сервере и управляются Java EE Web Application. Обычно\nтакие страницы упакованы в файловые архивы .war и .ear.</p>"},{"subject":"Servlets","url":"010-servlets.html#зачем-нужен-jsp","title":"<p>Зачем нужен JSP?</p>","answer":"<p>JSP расширяет технологию сервлетов обеспечивая возможность создания динамических страницы с HTML подобным синтаксисом.\nХотя создание представлений поддерживается и в сервлетах, но большая часть любой веб-страницы является статической,\nпоэтому код сервлета в таком случае получается чересчур перегруженным, замусоренным и поэтому при его написании легко\nдопустить ошибку. Еще одним преимуществом JSP является горячее развертывание - возможность заменить одну страницу на\nдругую непосредственно в контейнере без необходимости перекомпилировать весь проект или перезапускать сервер. Однако\nрекомендуется избегать написания серьёзной бизнес-логики в JSP и использовать страницу только в качестве представления.</p>"},{"subject":"Servlets","url":"010-servlets.html#взаимодействие-jsp-сервлет-jsp","title":"<p>Взаимодействие <em>JSP - сервлет - JSP</em></p>","answer":"<p><em>«JSP - сервлет - JSP»</em> архитектура построения приложений носит название <em>MVC (Model/View/Controller)</em>:</p>\n<ul>\n<li><strong>Model</strong> - классы данных и бизнес-логики;</li>\n<li><strong>View</strong> - страницы JSP;</li>\n<li><strong>Controller</strong> - сервлеты.</li>\n</ul>"},{"subject":"Servlets","url":"010-servlets.html#опишите-общие-практические-принципы-работы-с-jsp","title":"<p>Опишите общие практические принципы работы с JSP</p>","answer":"<p>Хорошей практикой работы с технологией JSP является соблюдение следующих правил:</p>\n<ul>\n<li>Следует избегать использования элементов скриптлетов на странице. Если элементы <em>action</em>, <em>JSTL</em>, <em>JSP EL</em> не\nудовлетворяют потребностям, то желательно написать собственный тег.</li>\n<li>Рекомендуется использовать разные виды комментариев: так JSP комментарии необходимы для уровня кода и отладки, т.к.\nони не будут показаны клиенту.</li>\n<li>Не стоит размещать какой-либо бизнес логики внутри JSP страницы. Страницы должны использоваться только для создания\nответов клиенту.</li>\n<li>Для повышения производительности лучше отключать создание сессии на странице, когда это не требуется.</li>\n<li>Директивы <code>taglib</code>, <code>page</code> в начале JSP страницы улучшают читабельность кода.</li>\n<li>Следует правильно использовать директиву <code>include</code> и элемент <code>jsp:include action</code>. Первая используется для статических\nресурсов, а второй для динамических ресурсов времени выполнения.</li>\n<li>Обработку исключений нужно производить с помощью страниц ошибок. Это помогает избегать запуска специальных служебных\nметодов и может повысить производительность.</li>\n<li>Использующиеся CSS и JavaScript должны быть разнесены в разные файлы и подключаться в начале страницы.</li>\n<li>В большинстве случаев JSTL должно хватать для всех нужд. Если это не так, то в начале следует проанализировать логику своего приложения, и попробовать перенести выполнения кода в сервлет, а далее с помощью установки атрибутов использовать на JSP странице только результат.</li>\n</ul>\n<p><a href=\"#servlets\">к оглавлению</a></p>"},{"subject":"Spring","url":"011-spring.html#какие-методы-реализации-принципа-инверсия-управления-ioc-вы-знаете","title":"<p>Какие методы реализации принципа Инверсия управления (IoC) вы знаете?</p>","answer":"<ul>\n<li><strong>Шаблон «Фабрика» (англ. Factory pattern)</strong></li>\n<li><strong>Локатор служб</strong></li>\n<li><strong>Внедрение зависимости (англ. Dependency injection)</strong></li>\n<li><strong>Контекстный поиск (англ. contextualized lookup)</strong></li>\n</ul>"},{"subject":"Spring","url":"011-spring.html#какими-способами-можно-реализовать-внедрение-зависимостей-в-java","title":"<p>Какими способами можно реализовать «внедрение зависимостей» в Java?</p>","answer":"<ul>\n<li><strong>Через конструктор</strong></li>\n<li><strong>Через getter/setter</strong></li>\n<li><strong>C помощью механизмов рефлексии</strong></li>\n</ul>"},{"subject":"Spring","url":"011-spring.html#что-такое-spring","title":"<p>Что такое Spring?</p>","answer":"<p><strong>Spring Framework (или коротко Spring)</strong> - универсальный фреймворк с открытым исходным кодом для Java-платформы. Центральной частью Spring является контейнер Inversion of Control, который предоставляет средства конфигурирования и управления объектами Java с помощью рефлексии. Контейнер отвечает за управление жизненным циклом объекта: создание объектов, вызов методов инициализации и конфигурирование объектов путём связывания их между собой.</p>\n<p>Spring имеет множество дочерних под проектов, в том числе:</p>\n<ul>\n<li><em>Data</em> - для работы с хранилищами данных.</li>\n<li><em>MVC</em> - для создания веб приложений.</li>\n<li><em>Boot</em> - для быстрой компоновки и создания приложения на основе других Spring проектов.</li>\n<li><em>Cloud</em> - для создания распределённой приложений.</li>\n</ul>"},{"subject":"Spring","url":"011-spring.html#какие-основные-отличия-в-версиях-spring","title":"<p>Какие основные отличия в версиях Spring?</p>","answer":"<ul>\n<li><strong>Версия 3 (2009)</strong> - Поддержка Java 5 (annotations, generics, varargs, …).</li>\n</ul>"},{"subject":"Spring","url":"011-spring.html#в-чем-разница-между-inversion-of-control-и-application-context","title":"<p>В чем разница между Inversion of Control и Application Context?</p>","answer":"<p><em>IoC</em> — инверсия управления. Вместо ручного внедрения зависимостей, фреймворк забирает ответственность за это.\n<em>ApplicationContext</em> — реализация IoC в Spring.\n<em>Bean Factory</em> — это базовая версия IoC контейнера\n<em>Application Context</em> также включает дополнительные функции, которые обычно нужны для разработки корпоративных\nприложений</p>"},{"subject":"Spring","url":"011-spring.html#в-чем-различие-между-webxml-и-the-spring-context-servletxml","title":"<p>В чем различие между web.xml и the Spring Context - servlet.xml?</p>","answer":"<p>web.xml — Метаданные и конфигурация любого веб-приложения, совместимого с Java EE. Java EE стандарт для веб-приложений.\nservlet.xml — файл конфигурации, специфичный для Spring Framework.</p>"},{"subject":"Spring","url":"011-spring.html#сравните-application-context-ioc-container-vs-web-container-и-ejb-container-нужен-ли-web-container-для-запуска-spring-boot-приложения","title":"<p>Сравните Application Context, IoC Container, vs Web Container и EJB Container. Нужен ли Web Container для запуска Spring Boot приложения?</p>","answer":"<p>Web Container и EJB Containers являются частью приложения/веб-сервера, таких как Tomcat, Websphere, Weblogic. Они добавляют свою дополнительную функциональность к ним. Java EE определяет контракт для веб-приложений, эти контейнеры являются реализацией этих контрактов.</p>\n<p>Spring контейнер может являться частью любого приложения, которое вы делаете на java. Spring может работать внутри\nвеб-контейнера, ejb контейнера или даже без них.</p>"},{"subject":"Spring","url":"011-spring.html#как-происходит-запуск-ioc-контейнера-spring","title":"<p>Как происходит запуск IoC-контейнера Spring?</p>","answer":"<ol>\n<li><strong>Парсинг конфигурации и создание BeanDefinition</strong> - конфигурация с помощью XNL, аннотаций, JavaConfig.</li>\n<li><strong>Настройка созданных BeanDefinition</strong> - на данном этапе происходит настройка еще не созданных бинов через классы, реализующие <code>BeanFactoryPostProcessor</code>. Например, <code>PropertySourcesPlaceholderConfigurer</code></li>\n<li><strong>Создание кастомных FactoryBean</strong> - <code>FactoryBean</code> — это generic интерфейс, которому можно делегировать процесс создания бинов.</li>\n<li><strong>Создание экземпляров бинов</strong>  - созданием экземпляров бинов занимается <code>BeanFactory</code> при этом, если нужно, делегирует это кастомным <code>FactoryBean</code>. Экземпляры бинов создаются на основе ранее созданных <code>BeanDefinition</code>.</li>\n<li><strong>Настройка созданных бинов</strong> - Интерфейс <code>BeanPostProcessor</code> позволяет вклиниться в процесс настройки ваших бинов до того, как они попадут в контейнер. Интерфейс несет в себе несколько методов.</li>\n</ol>"},{"subject":"Spring","url":"011-spring.html#какие-способы-конфигурирование-spring-существуют","title":"<p>Какие способы конфигурирование Spring существуют?</p>","answer":"<ul>\n<li><p><strong>XML конфигурация</strong> — <code>ClassPathXmlApplicationContext(“context.xml”)</code>. Используется класс — <code>XmlBeanDefinitionReader</code>, который реализует интерфейс <code>BeanDefinitionReader</code>. Тут все достаточно прозрачно. <code>XmlBeanDefinitionReader</code> получает InputStream и загружает Document через <code>DefaultDocumentLoader</code>. Далее обрабатывается каждый элемент документа и если он является бином, то создается <code>BeanDefinition</code> на основе заполненных данных (id, name, class, alias, init-method, destroy-method и др.). Каждый <code>BeanDefinition</code> помещается в Mindmap. Mindmap хранится в классе <code>DefaultListableBeanFactory</code>.</p></li>\n<li><p><strong>Аннотация/JavaConfig</strong> — с указанием пакета для сканирования — <code>AnnotationConfigApplicationContext(“package.name”)</code> или  через аннотации с указанием класса (или массива классов) помеченного аннотацией <code>@Configuration</code> - <code>AnnotationConfigApplicationContext(JavaConfig.class)</code>. Внутри <code>AnnotationConfigApplicationContext</code>, то можно увидеть два поля.</p></li>\n</ul>\n<pre><code class=\"java language-java\">    private final AnnotatedBeanDefinitionReader reader;\n\n    private final ClassPathBeanDefinitionScanner scanner;\n</code></pre>\n<p><code>ClassPathBeanDefinitionScanner</code> сканирует указанный пакет на наличие классов помеченных аннотацией @Component (или любой другой аннотацией которая включает в себя <code>@Component</code>). Найденные классы разбираются и для них создаются BeanDefinition. Чтобы сканирование было запущено, в конфигурации должен быть указан пакет для сканирования. @ComponentScan({\"package.name\"}) или <context:component-scan base-package=\"package.name\"/></p>\n<p><code>AnnotatedBeanDefinitionReader</code> работает в несколько этапов. Первый этап — это регистрация всех <code>@Configuration</code> для дальнейшего разбора. Если в конфигурации используются Conditional, то будут зарегистрированы только те конфигурации, для которых Condition вернет true. Аннотация Conditional появилась в четвертой версии Spring. Она используется в случае, когда на момент поднятия контекста нужно решить, создавать бин/конфигурацию или нет. Причем решение принимает специальный класс, который обязан реализовать интерфейс Condition. Второй этап — это регистрация специального <code>BeanFactoryPostProcessor</code>, а именно <code>BeanDefinitionRegistryPostProcessor</code>, который при помощи класса <code>ConfigurationClassParser</code> разбирает JavaConfig и создает BeanDefinition.</p>\n<ul>\n<li><strong>Groovy конфигурация</strong> — <code>GenericGroovyApplicationContext(“context.groovy”)</code>. Данная конфигурация очень похожа на конфигурацию через Xml, за исключением того, что в файле не XML, а Groovy. Чтением и анализом groovy конфигурации занимается класс GroovyBeanDefinitionReader.</li>\n</ul>"},{"subject":"Spring","url":"011-spring.html#что-предпочитаете-использовать-для-конфигурации-spring","title":"<p>Что предпочитаете использовать для конфигурации Spring?</p>","answer":"<p>Предпочитаю аннотации, если кодовая база хорошо описывается такими элементами,\nкак <code>@Service</code>, <code>@Component</code>, <code>@Autowired</code>\nОднако когда дело доходит до конфигурации, у меня нет каких-либо предпочтений. Я бы оставил этот вопрос команде.</p>"},{"subject":"Spring","url":"011-spring.html#что-такое-beanpostprocessor","title":"<p>Что такое <code>BeanPostProcessor</code>?</p>","answer":"<p>Интерфейс <code>BeanPostProcessor</code> позволяет вклиниться в процесс настройки ваших бинов до того, как они попадут в контейнер. Интерфейс несет в себе несколько методов.</p>\n<pre><code class=\"java language-java\">public interface BeanPostProcessor {\n    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n</code></pre>\n<p>Оба метода вызываются для каждого бина. У обоих методов параметры абсолютно одинаковые. Разница только в порядке их вызова. Первый вызывается до init-метода, второй, после. Важно понимать, что на данном этапе экземпляр бина уже создан и идет его дополнительная настройка. Тут есть два важных момента:</p>\n<ul>\n<li>Оба метода в итоге должны вернуть бин. Если в методе вы вернете null, то при получении этого бина из контекста вы получите null, а поскольку через <code>BeanPostProcessor</code> проходят все бины, после поднятия контекста, при запросе любого бина вы будете получать фиг, в смысле null.</li>\n<li>Если вы хотите сделать прокси над вашим объектом, то имейте ввиду, что это принято делать после вызова init метода, иначе говоря это нужно делать в методе <code>postProcessAfterInitialization</code>.</li>\n</ul>\n<p>Процесс дополнительной настройки показан на рисунке ниже. Порядок в котором будут вызваны BeanPostProcessor не известен,\nно мы точно знаем что выполнены они будут последовательно.</p>"},{"subject":"Spring","url":"011-spring.html#для-чего-нужен-component-scan","title":"<p>Для чего нужен Component Scan?</p>","answer":"<p>Первый шаг для описания Spring Beans это добавление аннотации — <code>@Component</code>, или <code>@Service</code>, или <code>@Repository</code>. Однако\nSpring ничего не знает об этих бинах, если он не знает где искать их. То, что скажет Spring где искать эти бины и\nназывается Component Scan. В <code>@ComponentScan</code> вы указываете пакеты, которые должны сканироваться. Spring будет искать\nбины не только в пакетах для сканирования, но и в их подпакетах.</p>"},{"subject":"Spring","url":"011-spring.html#в-чём-отличие-между-component-и-componentscan","title":"<p>В чём отличие между <code>@Component</code> и <code>@ComponentScan</code>?</p>","answer":"<p><code>@Component</code> помечает класс в качестве кандидата для создания Spring бина.\n<code>@ComponentScan</code> указывает где Spring искать классы, помеченные аннотацией @Component или его производной</p>"},{"subject":"Spring","url":"011-spring.html#для-чего-используется-аннотация-bean","title":"<p>Для чего используется аннотация <code>@Bean</code>?</p>","answer":"<p>В классах конфигурации Spring, @Bean используется для определения компонентов с кастомной логикой.</p>"},{"subject":"Spring","url":"011-spring.html#в-чём-разница-между-bean-и-component","title":"<p>В чём разница между <code>@Bean</code> и <code>@Component</code>?</p>","answer":"<p><code>@Bean</code> используется в конфигурационных классах Spring. Он используется для непосредственного создания бина.\n<code>@Component</code> используется со всеми классами, которыми должен управлять Spring. Когда Spring видит класс с <code>@Component</code>,\nSpring определяет этот класс как кандидата для создания bean.</p>"},{"subject":"Spring","url":"011-spring.html#в-чём-разница-между-component-service-и-repository-аннотациями","title":"<p>В чём разница между <code>@Component</code>, <code>@Service</code> и <code>@Repository</code> аннотациями?</p>","answer":"<p>Все они определяют бины Spring. Однако между ними всё же есть разница.</p>\n<p><code>@Component</code> — универсальный компонент\n<code>@Repository</code> — компонент, который предназначен для хранения, извлечения и поиска. Как правило, используется для работы с базами данных.\n<code>@Service</code> — фасад для некоторой бизнес логики</p>\n<p>Пользовательские аннотации, производные от @Component, могут добавлять специальную логику в бинах.\nНапример, бины, получившиеся при помощи @Repository, дополнительно имеют обработку для JDBC Exception</p>"},{"subject":"Spring","url":"011-spring.html#можем-ли-мы-использовать-component-вместо-service-для-бизнес-логики","title":"<p>Можем ли мы использовать <code>@Component</code> вместо <code>@Service</code> для бизнес логики?</p>","answer":"<p>Если <code>@Component</code> является универсальным стереотипом для любого Spring компонента, то <code>@Service</code> в настоящее время\nявляется его псевдонимом. Однако в официальной документации Spring рекомендуется использовать именно <code>@Service</code> для\nбизнес логики. Вполне возможно, что в будущих версиях фреймворка, для данного стереотипа добавится дополнительная\nсемантика, и его бины станут обладать дополнительной логикой.</p>"},{"subject":"Spring","url":"011-spring.html#можем-ли-мы-применить-autowired-с-не-сеттерами-и-не-конструкторами-методами","title":"<p>Можем ли мы применить <code>@Autowired</code> с не сеттерами и не конструкторами методами?</p>","answer":"<p><code>@Autowired</code> может использоваться вместе с конструкторами, сеттерами или любым другими методами. Когда Spring\nнаходит <code>@Autowired</code> на методе, Spring автоматически вызовет этот метод, после создания экземпляра бина. В качестве\nаргументов, будут подобраны подходящие объекты из контекста Spring.</p>"},{"subject":"Spring","url":"011-spring.html#в-чем-разница-между-сквозной-функциональностью-cross-cutting-concerns-и-аоп-аспектно-ориентированное-программирование","title":"<p>В чем разница между Сквозной Функциональностью (Cross Cutting Concerns) и АОП (аспектно ориентированное программирование)?</p>","answer":"<p>Сквозная Функциональность — функциональность, которая может потребоваться вам на нескольких различных уровнях —\nлогирование, управление производительностью, безопасность и т.д.\nАОП — один из подходов к реализации данной проблемы</p>"},{"subject":"Spring","url":"011-spring.html#почему-возвращаемое-значение-при-применении-аспекта-around-может-потеряться-назовите-причины","title":"<p>Почему возвращаемое значение при применении аспекта <code>@Around</code> может потеряться? Назовите причины</p>","answer":"<p>Метод, помеченный аннотацией @Around, должен возвращать значение, которое он (метод) получил из joinpoint.proceed()</p>\n<pre><code class=\"java language-java\">@Around(\"trackTimeAnnotation()\")\npublic Object around(ProceedingJoinPoint joinPoint) throws Throwable{\n    long startTime = System.currentTimeMillis();\n    Object retVal = joinPoint.proceed();\n    long timeTaken = System.currentTimeMillis() - startTime;\n    logger.info(\"Time taken by {} is equal to {}\",joinPoint, timeTaken);\n    return retVal;\n}\n</code></pre>"},{"subject":"Spring","url":"011-spring.html#как-вы-решаете-какой-бин-внедрить-если-у-вас-несколько-подходящих-бинов-расскажите-о-primary-и-qualifier","title":"<p>Как вы решаете какой бин внедрить, если у вас несколько подходящих бинов. Расскажите о <code>@Primary</code> и <code>@Qualifier</code>?</p>","answer":"<p>Если есть бин, который вы предпочитаете большую часть времени по сравнению с другими, то используйте <code>@Primary</code>, и используйте <code>@Qualifier</code> для нестандартных сценариев.</p>\n<p>Если все бины имеют одинаковый приоритет, мы всегда будем использовать <code>@Qualifier</code></p>\n<p>Если бин надо выбрать во время исполнения программы, то эти аннотации вам не подойдут. Вам надо в конфигурационном\nклассе создать метод, пометить его аннотацией <code>@Bean</code>, и вернуть им требуемый бин.</p>"},{"subject":"Spring","url":"011-spring.html#как-вы-добавите-component-scan-в-spring-boot","title":"<p>Как вы добавите Component Scan в Spring Boot?</p>","answer":"<pre><code class=\"java language-java\">@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n<p><code>@SpringBootApplication</code> определяет автоматическое сканирование пакета, где находится класс Application.</p>"},{"subject":"Spring","url":"011-spring.html#какие-возможности-предоставляет-аннотация-controller","title":"<p>Какие возможности предоставляет аннотация <code>@Controller</code>?</p>","answer":"<p><code>@Controller</code> - уточнение интерфейса <code>@Component</code>. Экземпляр класса, помеченного такой аннотация, также становиться\nбином в Spring.\nИспользуется для указание точек взаимодействия с приложением в Spring MVC. Обычно используется с\nаннотацией <code>@RequestMapping</code>.</p>"},{"subject":"Spring","url":"011-spring.html#в-чём-разница-между-controller-и-restcontroller","title":"<p>В чём разница между <code>@Controller</code> и <code>@RestController</code>?</p>","answer":"<p><code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code></p>\n<p><code>@RestController</code> превращает помеченный класс в Spring-бин. Этот бин для конвертации входящих/исходящих данных\nиспользует Jackson message converter. Как правило целевые данные представлены в json или xml.</p>"},{"subject":"Spring","url":"011-spring.html#как-мы-можем-выбрать-подходящий-бин-при-помощи-applicationproperties","title":"<p>Как мы можем выбрать подходящий бин при помощи application.properties?</p>","answer":"<p>Рассмотрим пример:</p>\n<pre><code class=\"java language-java\">interface GreetingService {\n    public String sayHello();\n}\n</code></pre>\n<p>и два компонента</p>\n<pre><code class=\"java language-java\">@Component(value=\"real\")\nclass RealGreetingService implements GreetingService {\n    public String sayHello() {\n        return \"I'm real\";\n    }\n}\n</code></pre>\n<pre><code class=\"java language-java\">@Component(value=\"mock\")\nclass MockGreetingService implements GreetingService {\n    public String sayHello() {\n        return \"I'm mock\";\n    }\n}\n</code></pre>\n<p>Тогда в application.properties добавим свойство application.greeting: <code>real</code></p>\n<p>Воспользуемся данным решением:</p>\n<pre><code class=\"java language-java\">@RestController\npublic class WelcomeController {\n    @Resource(name=\"${application.greeting}\")\n    private GreeterService service1;\n}\n</code></pre>"},{"subject":"Spring","url":"011-spring.html#почему-иногда-мы-используем-responsebody-а-иногда-responseentity","title":"<p>Почему иногда мы используем <code>@ResponseBody</code>, а иногда <code>ResponseEntity</code>?</p>","answer":"<p>ResponseEntity необходим, только если мы хотим кастомизировать ответ, добавив к нему статус ответа. Во всех остальных случаях будем использовать <code>@ResponseBody</code>.</p>\n<pre><code class=\"java language-java\">@GetMapping(value=”/resource”)\n@ResponseBody\npublic Resource sayHello() { return resource; }\n\n@PostMapping(value=”/resource”)\npublic ResponseEntity createResource() {\n    ….\n    return ResponseEntity.created(resource).build();\n}\n</code></pre>\n<p>Стандартные HTTP коды статусов ответов, которые можно использовать.\n200 — SUCCESS\n201 — CREATED\n404 — RESOURCE NOT FOUND\n400 — BAD REQUEST\n401 — UNAUTHORIZED\n500 — SERVER ERROR</p>\n<p>Для <code>@ResponseBody</code> единственные состояния статуса это SUCCESS(200), если всё хорошо и SERVER ERROR(500), если произошла какая-либо ошибка.</p>\n<p>Допустим мы что-то создали и хотим отправить статус CREATED(201). В этом случае мы используем <code>ResponseEntity</code>.</p>"},{"subject":"Spring","url":"011-spring.html#в-чем-разница-между-filters-listeners-and-interceptors","title":"<p>В чем разница между Filters, Listeners and Interceptors?</p>","answer":"<p>Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим?</p>\n<p>Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.\nJava EE использует термин Filter, Spring называет их Interceptors. Именно здесь AOP используется в полную силу,\nблагодаря чему возможно перехватывание вызовов любых объектов.</p>"},{"subject":"Spring","url":"011-spring.html#в-чем-разница-между-modelmap-и-modelandview","title":"<p>В чем разница между <code>ModelMap</code> и <code>ModelAndView</code>?</p>","answer":"<p>Model — интерфейс, ModelMap его реализация. ModelAndView является контейнером для пары, как ModelMap и View. Обычно я\nлюблю использовать ModelAndView. Однако есть так же способ когда мы задаем необходимые атрибуты в ModelMap, и возвращаем\nназвание View обычной строкой из метода контроллера.</p>"},{"subject":"Spring","url":"011-spring.html#в-чем-разница-между-modelput-и-modeladdattribute","title":"<p>В чем разница между <code>model.put()</code> и <code>model.addAttribute()</code>?</p>","answer":"<p>Метод addAttribute отделяет нас от работы с базовой структурой hashmap. По сути addAttribute это обертка над put, где делается дополнительная проверка на null. Метод addAttribute в отличие от put возвращает modelmap.</p>\n<pre><code class=\"java language-java\">model.addAttribute(“attribute1”,”value1”).addAttribute(“attribute2”,”value2”);\n</code></pre>"},{"subject":"Spring","url":"011-spring.html#что-можете-рассказать-про-form-binding","title":"<p>Что можете рассказать про Form Binding?</p>","answer":"<p>Нам это может понадобиться, если мы, например, захотим взять некоторое значение с HTML страницы и сохранить его в БД.\nДля этого нам надо это значение переместить в контроллер Spring. Если мы будем использовать Spring MVC form tags, Spring\nавтоматически свяжет переменные на HTML странице с бином Spring.</p>"},{"subject":"Spring","url":"011-spring.html#почему-мы-используем-hibernate-validator","title":"<p>Почему мы используем Hibernate Validator?</p>","answer":"<p>Hibernate Validator никак не связан с БД. Это просто библиотека для валидации. Hibernate Validator версии 5.x является\nэталонной реализацией Bean Validation 1.1</p>\n<p>Так же если взглянуть по адресу <a href=\"http://beanvalidation.org/2.0\">http://beanvalidation.org/2.0</a>, то Hibernate Validator является единственным, который\nсертифицирован.</p>"},{"subject":"Spring","url":"011-spring.html#где-должны-располагаться-статические-css-js-html-ресурсы-в-spring-mvc-приложении","title":"<p>Где должны располагаться статические (css, js, html) ресурсы в Spring MVC приложении?</p>","answer":"<p>Расположение статических ресурсов можно настроить. В документации Spring Boot рекомендуется использовать /static, или\n/public, или /resources, или /META-INF/resources.</p>"},{"subject":"Spring","url":"011-spring.html#можно-ли-передать-в-запросе-один-и-тот-же-параметр-несколько-раз","title":"<p>Можно ли передать в запросе один и тот же параметр несколько раз?</p>","answer":"<p>Пример: <code>http://localhost:8080/login?name=Ranga&amp;name=Ravi&amp;name=Sathish</code>\nДа, можно принять все значения, используя массив в методе контроллера</p>\n<pre><code class=\"java language-java\">public String method(@RequestParam(value=\"name\") String[] names){\n}\n</code></pre>\n<p><a href=\"#spring\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/\">Википедия</a></li>\n<li><a href=\"https://habr.com/ru/post/222579/\">Хабрахабр</a></li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#что-такое-jdbc","title":"<p>Что такое <em>JDBC</em>?</p>","answer":"<p><strong>JDBC, Java DataBase Connectivity (соединение с базами данных на Java)</strong> — промышленный стандарт взаимодействия Java-приложений с различными СУБД. Реализован в виде пакета <code>java.sql</code>, входящего в состав Java SE.</p>\n<p>JDBC основан на концепции драйверов, которые позволяют получать соединение с базой данных по специально описанному URL. При загрузке драйвер регистрирует себя в системе и в дальнейшем автоматически вызывается, когда программа требует URL, содержащий протокол, за который этот драйвер отвечает.</p>"},{"subject":"JDBC","url":"012-jdbc.html#в-чем-заключаются-преимущества-использования-jdbc","title":"<p>В чем заключаются преимущества использования JDBC?</p>","answer":"<p>Преимуществами JDBC считают:</p>\n<ul>\n<li>Лёгкость разработки: разработчик может не знать специфики базы данных, с которой работает;</li>\n<li>Код практически не меняется, если компания переходит на другую базу данных (количество изменений зависит исключительно от различий между диалектами SQL);</li>\n<li>Не нужно дополнительно устанавливать клиентскую программу;</li>\n<li>К любой базе данных можно подсоединиться через легко описываемый URL.</li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#что-из-себя-представляет-jdbc-url","title":"<p>Что из себя представляет JDBC URL?</p>","answer":"<p><strong>JDBC URL</strong> состоит из:</p>\n<ul>\n<li><code>&lt;protocol&gt;:</code> (протокола) - всегда <code>jdbc:</code>.</li>\n<li><code>&lt;subprotocol&gt;:</code> (подпротокола) - это имя драйвера или имя механизма соединения с базой данных. Подпротокол может поддерживаться одним или несколькими драйверами. Лежащий на поверхности пример подпротокола - это \"odbc\", отведенный для URL, обозначающих имя источника данных ODBC. В случае необходимости использовать сервис имен (т.е. имя базы данных в JDBC URL не будет действительным именем базы данных), то подпротоколом может выступать сервис имен.</li>\n<li><code>&lt;subname&gt;</code> (доп. имени) - это идентификатор базы данных. Значение доп. имени может меняться в зависимости от подпротокола, и может также иметь доп. имя с синтаксисом, определяемым разработчиком драйвера. Назначение доп. имени - это предоставление всей информации, необходимой для поиска базы данных. Например, если база данных находится в Интернет, то в состав доп. имени JDBC URL должен быть включен сетевой адрес, подчиняющийся следующим соглашениям: <code>//&lt;hostname&gt;:&lt;port&gt;/&lt;subsubname</code>.</li>\n</ul>\n<p>Пример JDBC URL для подключения к MySQL базе данных «Test» расположенной по адресу localhost и ожидающей соединений по порту 3306: <code>jdbc:mysql://localhost:3306/Test</code></p>"},{"subject":"JDBC","url":"012-jdbc.html#из-каких-частей-стоит-jdbc","title":"<p>Из каких частей стоит JDBC?</p>","answer":"<p>JDBC состоит из двух частей:</p>\n<ul>\n<li><strong>JDBC API</strong>, который содержит набор классов и интерфейсов, определяющих доступ к базам данных. Эти классы и методы\nобъявлены в двух пакетах - <code>java.sql</code> и <code>javax.sql</code>;</li>\n<li><strong>JDBC-драйвер</strong>, компонент, специфичный для каждой базы данных.</li>\n</ul>\n<p>JDBC превращает вызовы уровня API в «родные» команды того или иного сервера баз данных.</p>"},{"subject":"JDBC","url":"012-jdbc.html#перечислите-основные-классы-и-интерфейсы-jdbc","title":"<p>Перечислите основные классы и интерфейсы JDBC</p>","answer":"<ul>\n<li><p><code>java.sql.DriverManager</code> - позволяет загрузить и зарегистрировать необходимый JDBC-драйвер, а затем получить\nсоединение с базой данных.</p></li>\n<li><p><code>javax.sql.DataSource</code> - решает те же задачи, что и <em>DriverManager</em>, но более удобным и универсальным образом.\nСуществуют также <code>javax.sql.ConnectionPoolDataSource</code> и <code>javax.sq1.XADataSource</code> задача которых - обеспечение\nподдержки пула соединений.</p></li>\n<li><p><code>java.sql.Connection</code>  - обеспечивает формирование запросов к источнику данных и управление транзакциями. Также\nпредусмотрены интерфейсы <code>javax.sql.PooledConnection</code> и <code>javax.sql.XAConnection</code>.</p></li>\n<li><p><code>java.sql.Statement</code> , <code>java.sql.PreparedStatement</code> и <code>java.sql.CallableStatement</code>  - эти интерфейсы позволяют\nотправить запрос к источнику данных.</p></li>\n<li><p><code>java.sql.ResultSet</code>  - объявляет методы, которые позволяют перемещаться по набору данных и считывать значения\nотдельных полей в текущей записи.</p></li>\n<li><p><code>java.sql.ResultSetMetaData</code>  - позволяет получить информацию о структуре набора данных.</p></li>\n<li><p><code>java.sql.DatabaseMetaData</code> - позволяет получить информацию о структуре источника данных.</p></li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#перечислите-основные-типы-данных-используемые-в-jdbc-как-они-связаны-с-типами-java","title":"<p>Перечислите основные типы данных используемые в JDBC. Как они связаны с типами Java?</p>","answer":"<table>\n<thead>\n<tr>\n<th style=\"text-align:right;\">JDBC Type</th>\n<th>Java Object Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right;\"><strong>CHAR</strong></td>\n<td><code>String</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>VARCHAR</strong></td>\n<td><code>String</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>LONGVARCHAR</strong></td>\n<td><code>String</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>NUMERIC</strong></td>\n<td><code>java.math.BigDecimal</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>DECIMAL</strong></td>\n<td><code>java.math.BigDecimal</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>BIT</strong></td>\n<td><code>Boolean</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>TINYINT</strong></td>\n<td><code>Integer</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>SMALLINT</strong></td>\n<td><code>Integer</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>INTEGER</strong></td>\n<td><code>Integer</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>BIGINT</strong></td>\n<td><code>Long</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>REAL</strong></td>\n<td><code>Float</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>FLOAT</strong></td>\n<td><code>Double</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>DOUBLE</strong></td>\n<td><code>Double</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>BINARY</strong></td>\n<td><code>byte[]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>VARBINARY</strong></td>\n<td><code>byte[]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>LONGVARBINARY</strong></td>\n<td><code>byte[]</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>DATE</strong></td>\n<td><code>java.sql.Date</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>TIME</strong></td>\n<td><code>java.sql.Time</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>TIMESTAMP</strong></td>\n<td><code>java.sql.Timestamp</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>CLOB</strong></td>\n<td><code>Clob</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>BLOB</strong></td>\n<td><code>Blob</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>ARRAY</strong></td>\n<td><code>Array</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>STRUCT</strong></td>\n<td><code>Struct</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>REF</strong></td>\n<td><code>Ref</code></td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>DISTINCT</strong></td>\n<td>сопоставление базового типа</td>\n</tr>\n<tr>\n<td style=\"text-align:right;\"><strong>JAVA_OBJECT</strong></td>\n<td>базовый класс Java</td>\n</tr>\n</tbody>\n</table>"},{"subject":"JDBC","url":"012-jdbc.html#опишите-основные-этапы-работы-с-базой-данных-при-использовании-jdbc","title":"<p>Опишите основные этапы работы с базой данных при использовании JDBC</p>","answer":"<ul>\n<li>Регистрация драйверов;</li>\n<li>Установление соединения с базой данных;</li>\n<li>Создание запроса(ов) к базе данных;</li>\n<li>Выполнение запроса(ов) к базе данных;</li>\n<li>Обработка результата(ов);</li>\n<li>Закрытие соединения с базой данных.</li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#как-зарегистрировать-драйвер-jdbc","title":"<p>Как зарегистрировать драйвер JDBC?</p>","answer":"<p>Регистрацию драйвера можно осуществить несколькими способами:</p>\n<ul>\n<li><p><code>java.sql.DriverManager.registerDriver(%объект класса драйвера%)</code>.</p></li>\n<li><p><code>Class.forName(«полное имя класса драйвера»).newInstance()</code>.</p></li>\n<li><p><code>Class.forName(«полное имя класса драйвера»)</code>;</p></li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#как-установить-соединение-с-базой-данных","title":"<p>Как установить соединение с базой данных?</p>","answer":"<p>Для установки соединения с базой данных используется статический вызов <code>java.sql.DriverManager.getConnection(...)</code> .</p>\n<p>В качестве параметра может передаваться:</p>\n<ul>\n<li>URL базы данных</li>\n</ul>\n<pre><code class=\"java language-java\">static Connection getConnection(String url)\n</code></pre>\n<ul>\n<li>URL базы данных и набор свойств для инициализации</li>\n</ul>\n<pre><code class=\"java language-java\">static Connection getConnection(String url, Properties info)\n</code></pre>\n<ul>\n<li>URL базы данных, имя пользователя и пароль</li>\n</ul>\n<pre><code class=\"java language-java\">static Connection getConnection(String url, String user, String password)\n</code></pre>\n<p>В результате вызова будет установлено соединение с базой данных и создан объект класса <code>java.sql.Connection</code> - своеобразная «сессия», внутри контекста которой и будет происходить дальнейшая работа с базой данных.</p>"},{"subject":"JDBC","url":"012-jdbc.html#какие-уровни-изоляции-транзакций-поддерживаются-в-jdbc","title":"<p>Какие уровни изоляции транзакций поддерживаются в JDBC?</p>","answer":"<p><strong>Уровень изолированности транзакций</strong> — значение, определяющее уровень, при котором в транзакции допускаются несогласованные данные, то есть степень изолированности одной транзакции от другой. Более высокий уровень изолированности повышает точность данных, но при этом может снижаться количество параллельно выполняемых транзакций. С другой стороны, более низкий уровень изолированности позволяет выполнять больше параллельных транзакций, но снижает точность данных.</p>\n<p>Во время использования транзакций, для обеспечения целостности данных, СУБД использует блокировки, чтобы заблокировать доступ других обращений к данным, участвующим в транзакции. Такие блокировки необходимы, чтобы предотвратить:</p>\n<ul>\n<li><p><em>«грязное» чтение (dirty read)</em> — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);</p></li>\n<li><p><em>неповторяющееся чтение (non-repeatable read)</em> — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;</p></li>\n<li><p><em>фантомное чтение (phantom reads)</em> — ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.</p></li>\n</ul>\n<p>Уровни изоляции транзакций определены в виде констант интерфейса <code>java.sql.Connection</code>:</p>\n<ul>\n<li><p><code>TRANSACTION_NONE</code> – драйвер не поддерживает транзакции;</p></li>\n<li><p><code>TRANSACTION_READ_UNCOMMITTED</code> – позволяет транзакциям видеть несохраненные изменения данных: разрешает грязное, непроверенное и фантомное чтения;</p></li>\n<li><p><code>TRANSACTION_READ_COMMITTED</code> – любое изменение, сделанное в транзакции, не видно вне неё, пока она не сохранена: предотвращает грязное чтение, но разрешает непроверенное и фантомное;</p></li>\n<li><p><code>TRANSACTION_REPEATABLE_READ</code> – запрещает грязное и непроверенное, фантомное чтение разрешено;</p></li>\n<li><p><code>TRANSACTION_SERIALIZABLE</code> – грязное, непроверенное и фантомное чтения запрещены.</p></li>\n</ul>\n<blockquote>\n  <p><strong>NB!</strong> Сервер базы данных может не поддерживать все уровни изоляции. Интерфейс <code>java.sql.DatabaseMetaData</code> предоставляет информацию об уровнях изолированности транзакций, которые поддерживаются данной СУБД.</p>\n</blockquote>\n<p>Уровень изоляции транзакции используемый СУБД можно задать с помощью метода <code>setTransactionIsolation()</code> объекта <code>java.sql.Connection</code>. Получить информацию о применяемом уровне изоляции поможет метод <code>getTransactionIsolation()</code>.</p>"},{"subject":"JDBC","url":"012-jdbc.html#при-помощи-чего-формируются-запросы-к-базе-данных","title":"<p>При помощи чего формируются запросы к базе данных?</p>","answer":"<p>Для выполнения запросов к базе данных в Java используются три интерфейса:</p>\n<ul>\n<li><code>java.sql.Statement</code> - для операторов SQL без параметров;</li>\n<li><code>java.sql.PreparedStatement</code> - для операторов SQL с параметрами и часто выполняемых операторов;</li>\n<li><code>java.sql.CallableStatement</code> -  для исполнения хранимых в базе процедур.</li>\n</ul>\n<p>Объекты-носители интерфейсов создаются при помощи методов объекта <code>java.sql.Connection</code>:</p>\n<ul>\n<li><code>java.sql.createStatement()</code> возвращает объект <em>Statement</em>;</li>\n<li><code>java.sql.prepareStatement()</code> возвращает объект <em>PreparedStatement</em>;</li>\n<li><code>java.sql.prepareCall()</code> возвращает объект <em>CallableStatement</em>;</li>\n</ul>"},{"subject":"JDBC","url":"012-jdbc.html#чем-отличается-statement-от-preparedstatement","title":"<p>Чем отличается Statement от PreparedStatement?</p>","answer":"<ul>\n<li><strong>Statement</strong>: используется для простых случаев запроса без параметров.</li>\n<li><strong>PreparedStatement</strong>: предварительно компилирует запрос, который может содержать входные параметры и выполняться несколько раз с разным набором этих параметров.</li>\n</ul>\n<p>Перед выполнением СУБД разбирает каждый запрос, оптимизирует его и создает «план» (query plan) его выполнения. Если один и тот же запрос выполняется несколько раз, то СУБД в состоянии кэшировать план его выполнения и не производить этапов разборки и оптимизации повторно. Благодаря этому запрос выполняется быстрее.</p>\n<p>Суммируя: <em>PreparedStatement</em> выгодно отличается от <em>Statement</em> тем, что при повторном использовании с одним или несколькими наборами параметров позволяет получить преимущества заранее скомпилированного и кэшированного запроса, помогая при этом избежать SQL Injection.</p>"},{"subject":"JDBC","url":"012-jdbc.html#как-осуществляется-запрос-к-базе-данных-и-обработка-результатов","title":"<p>Как осуществляется запрос к базе данных и обработка результатов?</p>","answer":"<p>Выполнение запросов осуществляется при помощи вызова методов объекта, реализующего интерфейс <code>java.sql.Statement</code>:</p>\n<ul>\n<li><p><strong><code>executeQuery()</code></strong> -  для запросов, результатом которых является один набор значений, например запросов <code>SELECT</code>. Результатом выполнения является объект класса <code>java.sql.ResultSet</code>;</p></li>\n<li><p><strong><code>executeUpdate()</code></strong> - для выполнения операторов <code>INSERT</code>, <code>UPDATE</code> или <code>DELETE</code>, а также для операторов <em>DDL (Data Definition Language)</em>. Метод возвращает целое число, показывающее, сколько записей было модифицировано;</p></li>\n<li><p><strong><code>execute()</code></strong> – исполняет SQL-команды, которые могут возвращать различные результаты. Например, может использоваться для операции <code>CREATE TABLE</code>. Возвращает <code>true</code>, если первый результат содержит <em>ResultSet</em> и <code>false</code>, если первый результат - это количество модифицированных записей или результат отсутствует. Чтобы получить первый результат необходимо вызвать метод <code>getResultSet()</code> или <code>getUpdateCount()</code>. Остальные результаты доступны через вызов <code>getMoreResults()</code>, который при необходимости может быть произведён многократно.</p></li>\n</ul>\n<p>Объект с интерфейсом <code>java.sql.ResultSet</code> хранит в себе результат запроса к базе данных - некий набор данных, внутри которого есть курсор, указывающий на один из элементов набора данных - текущую запись.</p>\n<p>Используя курсор можно перемещаться по набору данных при помощи метода <code>next()</code>.</p>\n<blockquote>\n  <p><strong>NB!</strong> Сразу после получения набора данных его курсор находится перед первой записью и чтобы сделать её текущей необходимо вызвать метод <code>next()</code>.</p>\n</blockquote>\n<p>Содержание полей текущей записи доступно через вызовы методов <code>getInt()</code>, <code>getFloat()</code>, <code>getString()</code>, <code>getDate()</code> и им подобных.</p>"},{"subject":"JDBC","url":"012-jdbc.html#как-вызвать-хранимую-процедуру","title":"<p>Как вызвать хранимую процедуру?</p>","answer":"<p><strong>Хранимые процедуры</strong> – это именованный набор операторов SQL хранящийся на сервере. Такую процедуру можно вызвать из Java-класса с помощью вызова методов объекта реализующего интерфейс <code>java.sql.Statement</code>.</p>\n<p>Выбор объекта зависит от характеристик хранимой процедуры:</p>\n<ul>\n<li>без параметров → <code>Statement</code></li>\n<li>с входными параметрами → <code>PreparedStatement</code></li>\n<li>с входными и выходными параметрами → <code>CallableStatement</code></li>\n</ul>\n<blockquote>\n  <p>Если неизвестно, как была определена хранимая процедура, для получения информации о хранимой процедуре (например, имен и типов параметров) можно использовать методы <code>java.sql.DatabaseMetaData</code> позволяющие получить информацию о структуре источника данных.</p>\n</blockquote>\n<p>Пример вызова хранимой процедуры с входными и выходными параметрами:</p>\n<pre><code class=\"java language-java\">public vois runStoredProcedure(final Connection connection) throws Exception {\n    // описываем хранимую процедуру\n    String procedure = \"{ call procedureExample(?, ?, ?) }\";\n\n    // подготавливаем запрос\n    CallableStatement cs = connection.prepareCall(procedure);\n\n    // устанавливаем входные параметры\n    cs.setString(1, \"abcd\");\n    cs.setBoolean(2, true);\n    cs.setInt(3, 10);\n\n    // описываем выходные параметры\n    cs.registerOutParameter(1, java.sql.Types.VARCHAR);\n    cs.registerOutParameter(2, java.sql.Types.INTEGER);\n\n    // запускаем выполнение хранимой процедуры\n    cs.execute();\n\n    // получаем результаты\n    String parameter1 = cs.getString(1);\n    int parameter2 = cs.getInt(2);\n\n    // заканчиваем работу с запросом\n    cs.close();\n}\n</code></pre>"},{"subject":"JDBC","url":"012-jdbc.html#как-закрыть-соединение-с-базой-данных","title":"<p>Как закрыть соединение с базой данных?</p>","answer":"<p>Соединение с базой данной закрывается вызовом метода <code>close()</code> у соответствующего объекта <code>java.sql.Connection</code> или посредством использования механизма try-with-resources при создании такого объекта, появившегося в Java 7.</p>\n<blockquote>\n  <p><strong>NB!</strong> Предварительно необходимо закрыть все запросы созданные этим соединением.</p>\n</blockquote>\n<p><a href=\"#jdbc\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/Java_Database_Connectivity\">Википедия - JDBC</a></li>\n<li><a href=\"http://www.ibm.com/developerworks/ru/library/dm-1209storedprocedures/\">IBM developerWorks®</a></li>\n<li><a href=\"https://docs.oracle.com/javase/7/docs/api/java/sql/package-summary.html\">Документация к пакету java.sql</a></li>\n<li><a href=\"https://ru.wikipedia.org/wiki/Уровень_изолированности_транзакций\">Википедия - Уровень изолированности транзакции</a></li>\n</ul>"},{"subject":"Логирование","url":"015-log.html#какие-существуют-типы-логов","title":"<p>Какие существуют типы логов?</p>","answer":"<ul>\n<li>системы (System);</li>\n<li>безопасности (Security);</li>\n<li>приложения (Application, Buisness).</li>\n</ul>\n<blockquote>\n  <p>Пользователь входит в приложение, проверяется пароль. Это действие относится к безопасности (Security). Дальше он запускает какой-нибудь модуль. Это событие уровня приложения (Application). Модуль при старте обращается к другому модулю за какими-то дополнительными данными, производит какие-либо еще вызовы – это уже системные действия (System).</p>\n</blockquote>"},{"subject":"Логирование","url":"015-log.html#из-каких-частей-состоит-система-журналирования-log4j","title":"<p>Из каких частей состоит система журналирования log4j?</p>","answer":"<p>Система журналирования состоит из трёх основных частей:</p>\n<ul>\n<li>управляющей Логированием - <strong>logger</strong>;</li>\n<li>добавляющей в журнал - <strong>appender</strong>;</li>\n<li>определяющей формат добавления - <strong>layout</strong>.</li>\n</ul>"},{"subject":"Логирование","url":"015-log.html#что-такое-logger-в-log4j","title":"<p>Что такое <em>Logger</em> в log4j?</p>","answer":"<p><strong>Logger</strong> представляет собой объект класса <code>org.apache.log4j.Logger</code>, который используется как управляющий интерфейс для журналирования сообщений с возможностью задавать уровень детализации. Именно logger проверяет нужно ли обрабатывать сообщение и если Логирование необходимо, то сообщение передаётся в appender, если нет - система завершает обработку данного сообщения.</p>"},{"subject":"Логирование","url":"015-log.html#что-такое-appender-в-log4j","title":"<p>Что такое <em>Appender</em> в log4j?</p>","answer":"<p><strong>Appender</strong> - это именованный объект журнала событий, реализующий интерфейс <code>org.apache.log4j.Appender</code> и добавляющий события в журнал. Appender вызывает разные вспомогательные инструменты - компоновщик, фильтр, обработчик ошибок (если они определены и необходимы). В ходе этой работы окончательно устанавливается необходимость записи сообщения, сообщению придаются окончательные содержание и форма.</p>\n<p>В log4j журнал может представлять:</p>\n<ul>\n<li>консоль;</li>\n<li>файл;</li>\n<li>сокет;</li>\n<li>объект класса реализующего <code>java.io.Writer</code> или <code>java.io.OutputStream</code>;</li>\n<li>JDBC хранилище;</li>\n<li>тему (topic) JMS;</li>\n<li>NT Event Log;</li>\n<li>SMTP;</li>\n<li>Syslog;</li>\n<li>Telnet.</li>\n</ul>\n<p>Наиболее часто используемые log4j appender-ы:</p>\n<ul>\n<li><code>org.apache.log4j.ConsoleAppender</code> - вывод в консоль;</li>\n<li><code>org.apache.log4j.FileAppender</code> - добавление в файл;</li>\n<li><code>org.apache.log4j.DailyRollingFileAppender</code> - добавление в файл с обновлением файла через заданный промежуток времени;</li>\n<li><code>org.apache.log4j.RollingFileAppender</code> - добавление в файл с обновлением файла по достижению определенного размера;</li>\n<li><code>org.apache.log4j.varia.ExternallyRolledFileAppender</code> - расширение <em>RollingFileAppender</em> обновляющее файл по команде принятой с заданного порта;</li>\n<li><code>org.apache.log4j.net.SMTPAppender</code> - сообщение по SMTP;</li>\n<li><code>org.apache.log4j.AsyncAppender</code> - позволяет, используя отдельный поток, организовать асинхронную работу, когда сообщения фиксируются лишь при достижении определенного уровня заполненности промежуточного буфера.</li>\n<li><code>org.apache.log4j.nt.NTEventLogAppender</code> - добавление в NT Event Log;</li>\n<li><code>org.apache.log4j.net.SyslogAppender</code> - добавление в Syslog;</li>\n<li><code>org.apache.log4j.jdbc.JDBCAppender</code> - запись в хранилище JDBC;</li>\n<li><code>org.apache.log4j.lf5.LF5Appender</code> - сообщение передаётся в специальный GUI интерфейс LogFactor5</li>\n<li><code>org.apache.log4j.net.SocketAppender</code> - трансляция сообщения по указанному адресу и порту;</li>\n<li><code>org.apache.log4j.net.SocketHubAppender</code> - рассылка сообщения сразу нескольким удалённым серверам соединённым по заданному порту;</li>\n<li><code>org.apache.log4j.net.TelnetAppender</code> - отсылка сообщения по протоколу Telenet;</li>\n<li><code>org.apache.log4j.net.JMSAppender</code> - добавление сообщения в JMS.</li>\n</ul>"},{"subject":"Логирование","url":"015-log.html#что-такое-layout-в-log4j","title":"<p>Что такое <em>Layout</em> в log4j?</p>","answer":"<p><strong>Layout</strong> - наследник класса <code>org.apache.log4j.Layout</code> предоставляющий возможность форматирования сообщения перед добавлением в журнал.</p>\n<p>В log4j существуют следующие типы layout:</p>\n<ul>\n<li><code>org.apache.log4j.SimpleLayout</code> - на выходе получается строка содержащая лишь уровень вывода и сообщение;</li>\n<li><code>org.apache.log4j.HTMLLayout</code> - форматирует сообщение в виде элемента HTML-таблицы;</li>\n<li><code>org.apache.log4j.xml.XMLLayout</code> - компонует сообщение в виде XML формате;</li>\n<li><code>org.apache.log4j.TTCCLayout</code> - на выходе сообщение дополняется информацией о времени, потоке, имени логгера и\nвложенном диагностическом контексте;</li>\n<li><code>org.apache.log4j.PatternLayout</code> / <code>org.apache.log4j.EnhancedPatternLayout</code> - настройка форматирования сообщения при\nпомощи шаблона заданного пользователем.</li>\n</ul>"},{"subject":"Логирование","url":"015-log.html#перечислите-уровни-журналирования-в-log4j-назовите-порядок-их-приоритетности","title":"<p>Перечислите уровни журналирования в log4j? Назовите порядок их приоритетности</p>","answer":"<ul>\n<li><strong>OFF</strong> - отсутствие журналирования;</li>\n<li><strong>FATAL</strong> - фатальная ошибка;</li>\n<li><strong>ERROR</strong> - ошибка;</li>\n<li><strong>WARN</strong> - предупреждение;</li>\n<li><strong>INFO</strong> - информация;</li>\n<li><strong>DEBUG</strong> - детальная информация для отладки;</li>\n<li><strong>TRACE</strong> – трассировка всех сообщений.</li>\n</ul>\n<p>Между уровнями логирования установлен следующий порядок приоритетов:</p>\n<p><code>OFF &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; ALL</code></p>"},{"subject":"Логирование","url":"015-log.html#какие-существуют-способы-конфигурирования-log4j","title":"<p>Какие существуют способы конфигурирования log4j?</p>","answer":"<p>Для того, чтобы log4j начал работать нужно предоставить ему конфигурацию. Это можно сделать несколькими путями:</p>\n<ul>\n<li>Создать конфигурацию программно, т.е. получить logger, определить уровень журналирования, прикрепить appender и задать способ форматирования.</li>\n<li>Указать файл или URL как аргумент при запуске java-машины <code>-Dlog4j.configuration=путь/к/файлу/конфигурации</code>, а затем прочитать его в программе при помощи <code>PropertyConfigurator.configure(...)</code>/ <code>DOMConfigurator.configure(...)</code> для формата <code>.properties</code> или <code>XML</code> соответственно.</li>\n<li>Загрузить конфигурацию из файла в формате <code>XML</code> или <code>.properties</code>: log4j ищет файл конфигурации в classpath. Сначала ищется файл <code>log4j.xml</code> и, если таковой не найден, -  файл <code>log4j.properties</code>.</li>\n</ul>\n<p><a href=\"#Логирование\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"http://www.quizful.net/\">Quizful</a></li>\n<li><a href=\"http://skipy.ru/useful/logging.html#log4j_concepts_logger\">Skipy</a></li>\n</ul>"},{"subject":"Тестирование","url":"016-test.html#опишите-подход-test-driven-development","title":"<p>Опишите подход Test-Driven Development</p>","answer":"<p><strong>Test-driven development(TDD, Разработка через тестирование)</strong> - это стиль разработки, в котором развитие системы определяется тестами в коротких циклах:</p>\n<ul>\n<li>Написать один тест.</li>\n<li>Написать только лишь необходимое количество кода, чтобы тест проходил.</li>\n<li>Провести рефакторинг кода, чтобы сделать его \"чистым\".</li>\n</ul>\n<p>В языках программирования, таких как Java, такие циклы занимают не более пяти минут. В старых языках, с медленной компиляцией и меньшей поддержкой автоматизации рефакторинга, такой цикл занимает больше времени - около 20 минут.</p>"},{"subject":"Тестирование","url":"016-test.html#что-такое-пирамида-тестирования","title":"<p>Что такое <em>«пирамида тестирования»</em>?</p>","answer":"<p><strong>«Пирамида тестирования»</strong> - метафора, представляющая собой пирамиду, состоящую из разного уровня тестов - модульных, интеграционных, пользовательских. В основе пирамиды модульные тесты, которые занимать 70-80% от общего количества тестов. Далее идут интеграционные в количестве 15-20%. На вершине пирамиды пользовательские (e2e) тесты, которые должны быть в количестве 5%. Такая структура позволяет добиться наибольшего профита от автоматизации тестирования.</p>"},{"subject":"Тестирование","url":"016-test.html#что-такое-модульное-тестирование","title":"<p>Что такое <em>«модульное тестирование»</em>?</p>","answer":""},{"subject":"Тестирование","url":"016-test.html#зачем-нужны-модульные-тесты","title":"<p>Зачем нужны модульные тесты?</p>","answer":"<ul>\n<li><strong>Меньше времени на выполнение функциональных тестов</strong>. Функциональные тесты требуют большого количества ресурсов. Как правило, приходится открывать приложение и выполнять ряд действий, чтобы проверить ожидаемое поведение. Тест-инженеры не всегда знают, что это за действия, и им приходится обращаться к специалистам в этой области. Само тестирование может занимать несколько секунд, если это обычные изменения, или несколько минут для более масштабных изменений. Наконец, этот процесс необходимо повторять для каждого изменения, внесенного в систему.Модульные тесты, с другой стороны, занимают миллисекунды, выполняются простым нажатием кнопки и не обязательно требуют знаний о всей системе в целом. Успешность прохождения теста зависит от средства выполнения теста, а не от пользователя.</li>\n<li><strong>Защита от регрессии</strong>. Дефекты регрессии вводятся при внесении изменений в приложение. Довольно часто тест-инженеры тестируют не только новую функцию, но и функции, существовавшие до этого, чтобы проверить, что эти функции по-прежнему работают должным образом.\nС модульным тестированием можно повторно запускать весь набор тестов после каждой сборки или даже после изменения строки кода. Это дает вам уверенность, что ваш новый код не нарушил существующие функциональные возможности.</li>\n<li><strong>Исполняемая документация</strong>. Не всегда очевидно, что делает конкретный метод или как он себя ведет при определенных входных данных. Вы можете спросить себя: как поведет себя метод, если я передам ему пустую строку? А значение NULL?\nЕсли у вас есть набор модульных тестов с понятными именами, каждый тест сможет четко объяснить, какими будут выходные данные для определенных входных данных. Кроме того, он сможет проверить, что это действительно работает.</li>\n<li><strong>Менее связанный код</strong>. Если код тесно связан, он плохо подходит для модульного тестирования. Без создания модульных тестов для кода это связывание может быть менее очевидным. Когда вы пишете тесты для кода, вы естественным образом разделяете его, иначе его будет сложнее тестировать.</li>\n</ul>"},{"subject":"Тестирование","url":"016-test.html#какие-характеристики-хорошего-модульного-теста-вы-знаете","title":"<p>Какие характеристики хорошего модульного теста Вы знаете?</p>","answer":"<ul>\n<li><strong>Быстрый</strong>. В хорошо разработанных проектах могут быть тысячи модульных тестов. Модульные тесты должны выполняться очень быстро. За миллисекунды.</li>\n<li><strong>Изолированный</strong>. Модульные тесты являются автономными, могут выполняться изолированно и не имеют зависимостей от внешних факторов, таких как файловая система или база данных.</li>\n<li><strong>Повторяемый</strong>. Запуски модульного теста должны иметь согласованные результаты, то есть всегда возвращать одинаковый результат, если вы не вносите никаких изменений между запусками.</li>\n<li><strong>Самопроверяемый</strong>. Тест должен автоматически определять, пройден он или нет, без участия пользователя.</li>\n<li><strong>Уместный</strong>. Время на написание модульного теста не должно значительно превышать время написания тестируемого кода. Если вам кажется, что тестирование кода занимает слишком много времени по сравнению с написанием кода, продумайте структуру, более подходящую для тестирования.</li>\n</ul>"},{"subject":"Тестирование","url":"016-test.html#какие-существуют-шаблоны-модульных-тестов","title":"<p>Какие существуют шаблоны модульных тестов?</p>","answer":"<ul>\n<li><p><strong>AAA (Arrange, Act, Assert)</strong> – хороший шаблон для написания модульных тестов. (входные данные, действие, ожидаемый результат). Один модульный тест должен тестировать что-то одно. Следовательно, каждый тест-кейс должен содержать только один AAA-набор. Тест-кейс не должен быть слишком большим (больше 10 строк кода), если он следует шаблону AAA.</p></li>\n<li><p><strong>BDD-style (Given, When, Then)</strong>- использует три других ключевых слова для описания каждого тест-кейса: Given, When and Then. Подход “given-when-then” почти аналогичен подходу “arrange-act-assert”. Они оба просто определяют переход из одного состояния в другое в Конечном Автомате (Finite State Machine, FSM).</p></li>\n</ul>\n<p>Отличия AAA и BDD-style:</p>\n<ul>\n<li>BDD-style смотрит на модуль как-бы “снаружи”, т.е фокусируется на его внешнем поведении</li>\n<li>Используя BDD, вы должны определить язык предметной области (domain specific language, DSL) при написании ваших тестовых спецификаций. Из-за этого, обычно требуется использовать другой фреймворк.</li>\n</ul>"},{"subject":"Тестирование","url":"016-test.html#что-такое-интеграционное-тестирование","title":"<p>Что такое <em>«интеграционное тестирование»</em>?</p>","answer":"<p><strong>Интеграционное тестирование (integration testing)</strong> — это тестирование, проверяющие работоспособность двух или более модулей системы в совокупности — то есть нескольких объектов как единого блока. В тестах взаимодействия же тестируется конкретный, определенный объект и то, как именно он взаимодействует с внешними зависимостями.</p>"},{"subject":"Тестирование","url":"016-test.html#чем-интеграционное-тестирование-отличается-от-модульного","title":"<p>Чем интеграционное тестирование отличается от модульного?</p>","answer":"<p>С технологической точки зрения интеграционное тестирование является количественным развитием модульного, поскольку так же, как и модульное тестирование, оперирует интерфейсами модулей и подсистем и требует создания тестового окружения, включая заглушки на месте отсутствующих модулей. Основная разница между модульным и интеграционным тестированием состоит в целях, то есть в типах обнаруживаемых дефектов, которые, в свою очередь, определяют стратегию выбора входных данных и методов анализа.</p>\n<blockquote>\n  <p>Допустим, есть класс, который при определенных условиях взаимодействует с web-сервисом через зависимый объект. И нам надо проверить, что определенный метод зависимого объекта действительно вызывается. Если в качестве зависимого класса передать:</p>\n  <ul>\n  <li><p>реальный класс, работающий с web-сервисом, то это будет интеграционное тестирование.</p></li>\n  <li><p>заглушку, то это будет тестирование состояния.</p></li>\n  <li><p>шпиона, а в конце теста проверить, что определенный метод зависимого объекта действительно был вызван, то это будет тест взаимодействия.</p></li>\n  </ul>\n</blockquote>"},{"subject":"Тестирование","url":"016-test.html#какие-существуют-виды-тестовых-объектов","title":"<p>Какие существуют виды тестовых объектов?</p>","answer":"<p><strong>пустышка (dummy)</strong> - объект, который обычно передается в тестируемый класс в качестве параметра, но не имеет поведения: с ним ничего не происходит и никакие его методы не вызываются.</p>\n<blockquote>\n  <p>Примером dummy-объектов являются new object(), null, «Ignored String» и т.д.</p>\n</blockquote>\n<p><strong>фальшивка (fake object)</strong> применяется в основном для ускорения запуска ресурсоёмких тестов и является заменой тяжеловесного внешнего зависимого объекта его легковесной реализацией.</p>\n<blockquote>\n  <p>Основные примеры — эмулятор базы данных (fake database) или фальшивый web-сервис.</p>\n</blockquote>\n<p><strong>заглушка (test stub)</strong> используется для получения данных из внешней зависимости, подменяя её. При этом заглушка игнорирует все данные поступающие из тестируемого объекта, возвращая заранее определённый результат.</p>\n<blockquote>\n  <p>Тестируемый объект использует чтение из конфигурационного файла? Тогда передаем ему заглушку <code>ConfigFileStub</code> возвращающую тестовые строки конфигурации без обращения к файловой системе.</p>\n</blockquote>\n<p><strong>шпион (test spy)</strong> - разновидность заглушки, которая умеет протоколировать сделанные к ней обращения из тестируемой системы, чтобы проверить их правильность в конце теста. При этом фиксируется количество, состав и содержание параметров вызовов.</p>\n<blockquote>\n  <p>Если существует необходимость проверки, что определённый метод тестируемого класса вызывался ровно 1 раз, то шпион - именно то, что нам нужно.</p>\n</blockquote>\n<p><strong>фикция (mock object)</strong> похож на <em>шпиона</em>, но обладает расширенной функциональностью, заранее заданными поведением и реакцией на вызовы.</p>"},{"subject":"Тестирование","url":"016-test.html#чем-stub-отличается-от-mock","title":"<p>Чем <em>stub</em> отличается от <em>mock</em>?</p>","answer":"<p><em>stub</em> используется как заглушка сервисов, методов, классов и т.д. с заранее запрограммированным ответом на вызовы.</p>\n<p><em>mock</em> использует подмену результатов вызова, проверяет сам факт взаимодействия, протоколирует и контролирует его.</p>"},{"subject":"Тестирование","url":"016-test.html#что-такое-фикстуры","title":"<p>Что такое <em>«фикстуры»</em>?</p>","answer":"<p><strong>Фикстуры (fixtures)</strong> - состояние среды тестирования, которое требуется для успешного выполнения теста. Основная задача фикстур заключается в подготовке тестового окружения с заранее фиксированным/известным состоянием, чтобы гарантировать повторяемость процесса тестирования.</p>"},{"subject":"Тестирование","url":"016-test.html#какие-аннотации-фикстур-существуют-в-junit4-или-5","title":"<p>Какие аннотации фикстур существуют в JUnit4 или 5?</p>","answer":"<ul>\n<li><code>@BeforeClass</code> в JUnit4 / <code>@BeforeAll</code> в JUnit5 - определяет код, который должен единожды выполниться перед запуском набора тестовых методов.</li>\n<li><code>@AfterClass</code> в JUnit4 / <code>@AfterAll</code> в JUnit5  - код, выполняемый один раз после исполнения набора тестовых методов.</li>\n<li><code>@Before</code> в JUnit4 / <code>@BeforeEach</code> в JUnit5  - определяет код, который должен выполняться каждый раз перед запуском любого тестовым методом.</li>\n<li><code>@After</code> в JUnit4 / <code>@AfterEach</code> в JUnit5  - код, выполняемый каждый раз после исполнения любого тестового метода.</li>\n</ul>"},{"subject":"Тестирование","url":"016-test.html#для-чего-в-junit-используется-аннотация-ignore-или-disabled","title":"<p>Для чего в JUnit используется аннотация <code>@Ignore</code> или <code>@Disabled</code>?</p>","answer":"<p><code>@Ignore</code> в JUnit4 или <code>@Disabled</code> в JUnit5 указывает на необходимость пропустить данный тестовый метод.</p>"},{"subject":"Тестирование","url":"016-test.html#какие-фреймворки-для-поддержки-автоматизированного-приемочного-тестирования-вы-знаете","title":"<p>Какие фреймворки для поддержки автоматизированного приемочного тестирования Вы знаете?</p>","answer":"<p>Cucumber, Jbehave, Spock.</p>"},{"subject":"Тестирование","url":"016-test.html#какие-утилиты-для-нагрузочного-тестирования-вы-знаете","title":"<p>Какие утилиты для нагрузочного тестирования Вы знаете?</p>","answer":"<p>Apache JMeter, The Grinder, Gatling, HP Perfomance Tester (Load Runner).</p>\n<p><a href=\"#Тестирование\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/Тестирование_программного_обеспечения\">Википедия</a></li>\n<li><a href=\"https://habrahabr.ru/post/116372/\">Хабрахабр</a></li>\n<li><a href=\"http://www.intuit.ru/department/se/testing/5/2.html\">Интуит</a></li>\n</ul>"},{"subject":"Kotlin","url":"020-kotlin.html#что-такое-kotlin","title":"<p>Что такое Kotlin?</p>","answer":"<p><strong>Kotlin</strong> - это надежный язык программирования, разработанный для работы поверх JVM (виртуальная машина Java). Он разработан Jetbrains, популярной\nИТ-компанией, известной созданием высококачественных инструментов разработки. Kotlin имеет статическую типизацию и предлагает исключительную поддержку\nфункционального программирования.</p>\n<p>Кроме того, Kotlin решает некоторые вопиющие проблемы, с которыми сталкиваются многие программисты Java, такие как\nошибки, связанные с нулевым\nзначением. Его можно использовать для разработки приложений как для Android, так и для iOS вместе с универсальным\nпрограммным обеспечением. Благодаря\nисключительной совместимости с Java, разработчики могут писать новые функции для своих приложений на основе Java\nнепосредственно в Kotlin.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#зачем-использовать-kotlin-в-разработке-мобильных-приложений","title":"<p>Зачем использовать Kotlin в разработке мобильных приложений?</p>","answer":"<p>Поскольку Kotlin упрощает многие синтаксические элементы Java, проще писать краткий, хорошо документированный код. Кроме того, поскольку он работает\nнепосредственно на JVM, предприятиям вряд ли нужно вкладывать средства в новые технологические стеки. Так что корректировка рентабельности отличная.</p>\n<p>Более того, Kotlin уже начал заменять многие приложения для Android на базе Java, наряду с приложениями для iOS,\nнаписанными на Swift. Со временем это\nчисло будет только увеличиваться, и переход на Kotlin станет необходимостью для современных предприятий. Итак, чтобы\nоставаться впереди конкурентов,\nразработчики должны принять Kotlin уже сегодня.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#в-чем-заключаются-лучшие-особенности-kotlin","title":"<p>В чем заключаются лучшие особенности Kotlin?</p>","answer":"<p>Некоторые из лучших функций Kotlin:</p>\n<ul>\n<li>Он поддерживает парадигму как объектно-ориентированного, так и функционального программирования.</li>\n<li>Он предоставляет простые в использовании лямбда-функции, недоступные в Java.</li>\n<li>Обслуживание Kotlin значительно дешевле и обеспечивает отличную отказоустойчивость.</li>\n<li>Позволяет разрабатывать приложения и JVM на Node.js.</li>\n<li>Отличная поддержка асинхронного общения.</li>\n<li>Исключительная совместимость с существующими кодами Java.</li>\n</ul>"},{"subject":"Kotlin","url":"020-kotlin.html#что-такое-нулевая-безопасность-в-kotlin","title":"<p>Что такое нулевая безопасность в Kotlin?</p>","answer":"<p>Kotlin имеет встроенную защиту от нежелательных нулевых ссылок, что делает его более отказоустойчивым. Таким образом,\nэто позволяет программам\nсократить <code>NullPointerExceptions</code> во время выполнения и предотвращает нежелательные сбои программы. Это обычная\nпроблема, с которой сталкивается\nбольшинство существующего программного обеспечения Java, и приводит к убыткам в миллионы долларов. Это часто называют\nНулевая безопасность среди\nразработчиков Kotlin.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#какими-способами-можно-объявить-переменные-в-kotlin","title":"<p>Какими способами можно объявить переменные в Kotlin?</p>","answer":"<p>Соискателям работы часто задают этот вопрос в своих вопросах на собеседовании на Kotlin. Kotlin позволяет объявлять переменные двумя разными\nспособами. Он обнажает вал и вар ключевое слово для этой цели. Однако, как вы увидите, они совершенно разные в своей работе.</p>\n<pre><code class=\"kotlin language-kotlin\">var number: Int = 10\nnumber = 15\n</code></pre>\n<p>Первая строка объявляет целочисленную переменную с именем number и присваивает ей значение 10. Затем вторая строка заменяет это 10 новым значением 15.\nВам нужно будет объявить переменные таким образом, если вы захотите изменить их позже в программе.</p>\n<pre><code class=\"kotlin language-kotlin\">val number: Int = 10\nnumber = 15\n</code></pre>\n<p>Однако приведенный выше блок кода недействителен и приведет к ошибкам компиляции. Kotlin не позволяет пользователям\nизменять значения переменных,\nсозданных с помощью ключевого слова val. Вы должны использовать его для объявления значений, которые остаются\nнеизменными во всем вашем коде.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#что-такое-nullability-в-kotlin","title":"<p>Что такое Nullability в Kotlin?</p>","answer":"<p>Многие языки программирования, такие как C и Java, позволяют объявлять переменные без установки начальных значений. Эти переменные обычно содержат\nзначение типа null. Если вы позже вызовете методы для таких переменных в своей программе, во время выполнения произойдет сбой. Kotlin не позволяет\nпрограммистам объявлять переменные таким образом и значительно снижает количество сбоев, связанных с нулевым значением.</p>\n<pre><code class=\"kotlin language-kotlin\">val name: String = null\n</code></pre>\n<p>Таким образом, приведенная выше строка не будет компилироваться в Kotlin. Вам нужно будет определить переменные как допускающие значение NULL, если вы\nхотите, чтобы они содержали значения NULL.</p>\n<pre><code class=\"kotlin language-kotlin\">val name: String? = null\n</code></pre>\n<p>На этот раз имя может содержать либо String, либо null.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#позволяет-ли-kotlin-вызывать-функции-java","title":"<p>Позволяет ли Kotlin вызывать функции Java?</p>","answer":"<p>Да, Kotlin позволяет программисту вызывать существующие процедуры Java из программы Kotlin. Такие функции, как дуэт получателей и установщиков,\nпредставлены как свойства. Kotlin назначает Unit каждому пустому значению, полученному от функции Java. Таким образом, модуль в Kotlin просто\nнедействителен в коде Java.</p>\n<p>Однако вам нужно будет избежать некоторых ключевых слов Kotlin в Java. Поскольку такие ключевые слова, как is, in и\nobject, являются допустимыми\nидентификаторами в Java, вам нужно будет экранировать их в библиотеках Java с помощью символа обратной кавычки (`).\nКроме того, Kotlin реализует такие\nфункции, как типы платформ и аннотации, чтобы гарантировать нулевую безопасность при вызове внешних функций Java.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#почему-в-kotlin-нет-явных-тернарных-условных-операторов","title":"<p>Почему в Kotlin нет явных тернарных условных операторов?</p>","answer":"<p>Kotlin не предлагает никаких конкретных тернарных операторов, как Java или C. Он опускает эту опцию, потому что вы\nможете сделать то же самое с\nвыражением <code>if</code> . Поскольку указанный выше тернарный оператор по существу является выражением формы (if? then:\nelse), Kotlin просто позволяет\nсделать это с помощью стандартного ключевого слова <code>if</code>.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#как-перенести-java-код-на-kotlin","title":"<p>Как перенести Java-код на Kotlin?</p>","answer":"<p>Мы можем легко перенести существующие коды Java на Kotlin, используя IntelliJ IDEA от JetBrains. В следующем разделе показано, как это сделать\nпоследовательно.</p>\n<ul>\n<li>Обновите файл сборки для поддержки компиляции Kotlin</li>\n<li>Откройте необходимый файл .java с помощью IDEA</li>\n<li>Скопируйте все необходимые фрагменты кода</li>\n<li>Создайте файл Kotlin с расширением .kt</li>\n<li>Вставьте фрагменты кода в этот файл Kotlin</li>\n<li>Введите Да, когда IDEA спросит, следует ли преобразовывать код Java в Kotlin</li>\n<li>Посетите это официальное руководство, чтобы узнать больше об этой проблеме</li>\n</ul>"},{"subject":"Kotlin","url":"020-kotlin.html#как-бывают-конструкторы-в-kotlin","title":"<p>Как бывают конструкторы в Kotlin?</p>","answer":"<p>Kotlin предлагает два разных конструктора для инициализации атрибутов класса. В этом отношении он отличается от Java,\nпоскольку последний\nпредоставляет только один конструктор. Эти два конструктора известны в Kotlin как первичные конструкторы и вторичные\nконструкторы. Во время многих\nвопросов на собеседовании Kotlin соискателей просят указать на различия между ними.</p>\n<p>Первичный конструктор - находится в заголовке объявления класса\nВторичный конструктор - объявлен внутри тела класса Kotlin и может иметь несколько экземпляров.</p>"},{"subject":"Kotlin","url":"020-kotlin.html#можно-ли-выполнить-код-kotlin-без-jvm","title":"<p>Можно ли выполнить код Kotlin без JVM?</p>","answer":"<p>Как мы уже много раз упоминали, Kotlin компилируется в байт-код и работает поверх виртуальной машины Java (JVM). Однако также можно скомпилировать\nKotlin в собственный машинный код и, таким образом, успешно выполнить его, вообще не требуя какой-либо JVM.</p>\n<p>Для этого разработчики могут использовать инструмент Kotlin / Native. Это эффективный бэкенд LLVM, который позволяет нам\nсоздавать автономные\nисполняемые файлы. Он также предоставляет некоторые дополнительные функции. Проконсультируйтесь с их официальная\nдокументация за дополнительной\nинформацией.</p>\n<p><a href=\"#kotlin\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ciksiti.com/ru/chapters/5968-50-frequently-asked-kotlin-interview-questions-and-answers\">Ciksiti</a></li>\n</ul>"},{"subject":"Хранение данных","url":"030-db.html#что-такое-база-данных","title":"<p>Что такое <em>«база данных»</em>?</p>","answer":"<p><strong>База данных</strong> — организованный и адаптированный для обработки вычислительной системой набор информации.</p>"},{"subject":"Хранение данных","url":"030-db.html#что-такое-система-управления-базами-данных","title":"<p>Что такое <em>«система управления базами данных»</em>?</p>","answer":"<p><strong>Система управления базами данных (СУБД)</strong> - набор средств общего или специального назначения, обеспечивающий создание, доступ к материалам и управление базой данных.</p>\n<p>Основные функции СУБД:</p>\n<ul>\n<li>управление данными</li>\n<li>журнализация изменений данных</li>\n</ul>"},{"subject":"Хранение данных","url":"030-db.html#сравните-реляционные-и-нереляционные-субд","title":"<p>Сравните реляционные и нереляционные СУБД</p>","answer":"<table>\n<thead>\n<tr>\n<th></th>\n<th>Реляционные (RDBMS)</th>\n<th>Нереляционные (NoSQL)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Язык</td>\n<td>SQL + диалекты</td>\n<td>Разные, зависит от типа</td>\n</tr>\n<tr>\n<td>Структура</td>\n<td>В виде таблиц</td>\n<td>Хэш-таблицы, документы, графы, …</td>\n</tr>\n<tr>\n<td>Масштабирование</td>\n<td>Вертикальное (чаще)</td>\n<td>Горизонтальное (чаще)</td>\n</tr>\n<tr>\n<td>CAP-теорема</td>\n<td>AP</td>\n<td>CP или AC</td>\n</tr>\n</tbody>\n</table>\n<p>Традиционные СУБД ориентируются на требования ACID к транзакционной системе, тогда как в NoSQL (кроме графовых) вместо ACID может рассматриваться набор свойств BASE.</p>"},{"subject":"Хранение данных","url":"030-db.html#что-такое-шардинг","title":"<p>Что такое шардинг?</p>","answer":"<p><strong>Шардинг (англ. sharding, иногда шардирование)</strong> — это другая техника масштабирования работы с данными. Суть его в разделении (партиционирование) базы данных на отдельные части так, чтобы каждую из них можно было вынести на отдельный сервер. Этот процесс зависит от структуры Вашей базы данных и выполняется прямо в приложении в отличие от репликации.</p>\n<p><em>Вертикальный шардинг</em> — это выделение таблицы или группы таблиц на отдельный сервер.</p>\n<p><em>Горизонтальный шардинг</em> — это разделение одной таблицы на разные сервера. Это необходимо использовать для огромных таблиц, которые не умещаются на одном сервере.</p>"},{"subject":"Хранение данных","url":"030-db.html#что-такое-in-memory-data-grid","title":"<p>Что такое In-memory Data Grid?</p>","answer":"<p><strong>Распределённое хранение данных в памяти - (англ. In-Memory Data Grid, IMDG)</strong> - это распределённое хранилище объектов, схожее по интерфейсу с обычной многопоточной хэш-таблицей. Вы храните объекты по ключам. Но, в отличие от традиционных систем, в которых ключи и значения ограничены типами данных «массив байт» и «строка», в IMDG Вы можете использовать любой объект из Вашей бизнес-модели в качестве ключа или значения. Это значительно повышает гибкость, позволяя Вам хранить в Data Grid в точности тот объект, с которым работает Ваша бизнес-логика без дополнительной сериализации/де-сериализации, которую требуют альтернативные технологии. Это также упрощает использование Вашего Data Grid-а, поскольку в большинстве случаев Вы можете работать с распределённым хранилищем данных как с обычной хэш-таблицей.</p>\n<p>Продукты класса IMDG</p>\n<ul>\n<li>Apacha Ignite</li>\n<li>Hazelcast</li>\n<li>Infinispan</li>\n<li>Gridgain</li>\n</ul>\n<p>и другие.</p>\n<p><a href=\"#Хранение-данных\">к оглавлению</a></p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-реляционная-модель-данных","title":"<p>Что такое <em>«реляционная модель данных»</em>?</p>","answer":"<p><strong>Реляционная модель данных</strong> — это логическая модель данных и прикладная теория построения реляционных баз данных.</p>\n<p>Реляционная модель данных включает в себя следующие компоненты:</p>\n<ul>\n<li><em>Структурный аспект</em> — данные представляют собой набор отношений.</li>\n<li><em>Аспект целостности</em> — отношения отвечают определенным условиям целостности: уровня домена (типа данных), уровня\nотношения и уровня базы данных.</li>\n<li><em>Аспект обработки (манипулирования)</em> — поддержка операторов манипулирования отношениями (реляционная алгебра,\nреляционное исчисление).</li>\n<li><em>Нормальная форма</em> - свойство отношения в реляционной модели данных, характеризующее его с точки зрения избыточности и\nопределённое как совокупность требований, которым должно удовлетворять отношение.</li>\n</ul>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#дайте-определение-терминам-простой-составной-composite-потенциальный-candidate-и","title":"<p>Дайте определение терминам <em>«простой»</em>, <em>«составной» (composite)</em>, <em>«потенциальный» (candidate)</em> и</p>","answer":"<p><em>«альтернативный» (alternate)</em> ключ</p>\n<p><strong>Простой ключ</strong> состоит из одного атрибута (поля). <strong>Составной</strong> - из двух и более.</p>\n<p><strong>Потенциальный ключ</strong> - простой или составной ключ, который уникально идентифицирует каждую запись набора данных. При\nэтом потенциальный ключ должен обладать критерием несократимости: при удалении любого из полей набор полей перестает\nуникально идентифицировать запись.</p>\n<p>Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют _\n<em>альтернативными</em>_.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-первичный-ключ-primary-key-каковы-критерии-его-выбора","title":"<p>Что такое <em>«первичный ключ» (primary key)</em>? Каковы критерии его выбора?</p>","answer":"<p><strong>Первичный ключ (primary key)</strong> в реляционной модели данных один из <em>потенциальных ключей</em> отношения, выбранный в качестве основного ключа (ключа по умолчанию).</p>\n<p>Если в отношении имеется единственный потенциальный ключ, он является и первичным ключом. Если потенциальных ключей несколько, один из них выбирается в качестве первичного, а другие называют <em>«альтернативными»</em>.</p>\n<p>В качестве первичного обычно выбирается тот из потенциальных ключей, который наиболее удобен. Поэтому в качестве первичного ключа, как правило, выбирают тот, который имеет наименьший размер (физического хранения) и/или включает наименьшее количество атрибутов. Другой критерий выбора первичного ключа — сохранение его уникальности со временем. Поэтому в качестве первичного ключа стараются выбирать такой потенциальный ключ, который с наибольшей вероятностью никогда не утратит уникальность.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-внешний-ключ-foreign-key","title":"<p>Что такое <em>«внешний ключ» (foreign key)</em>?</p>","answer":"<p><strong>Внешний ключ (foreign key)</strong> — подмножество атрибутов некоторого отношения A, значения которых должны совпадать со значениями некоторого потенциального ключа некоторого отношения B.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-нормализация","title":"<p>Что такое <em>«нормализация»</em>?</p>","answer":"<p><em>Нормализация</em> - это процесс преобразования отношений базы данных к виду, отвечающему нормальным формам (пошаговый, обратимый процесс замены исходной схемы другой схемой, в которой наборы данных имеют более простую и логичную структуру).</p>\n<p>Нормализация предназначена для приведения структуры базы данных к виду, обеспечивающему минимальную логическую избыточность, и не имеет целью уменьшение или увеличение производительности работы или же уменьшение или увеличение физического объёма базы данных. Конечной целью нормализации является уменьшение потенциальной противоречивости хранимой в базе данных информации.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#какие-существуют-нормальные-формы","title":"<p>Какие существуют нормальные формы?</p>","answer":"<p><strong>Первая нормальная форма (1NF)</strong> - Отношение находится в 1NF, если значения всех его атрибутов атомарны (неделимы).</p>\n<p><strong>Вторая нормальная форма (2NF)</strong> - Отношение находится в 2NF, если оно находится в 1NF, и при этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.</p>\n<p><strong>Третья нормальная форма (3NF)</strong> - Отношение находится в 3NF, если оно находится в 2NF и все неключевые атрибуты не зависят друг от друга.</p>\n<p><strong>Четвёртая нормальная форма (4NF)</strong> - Отношение находится в 4NF , если оно находится в 3NF и если в нем не содержатся независимые группы атрибутов, между которыми существует отношение «многие-ко-многим».</p>\n<p><strong>Пятая нормальная форма (5NF)</strong> - Отношение находится в 5NF, когда каждая нетривиальная зависимость соединения в ней определяется потенциальным ключом (ключами) этого отношения.</p>\n<p><strong>Шестая нормальная форма (6NF)</strong> - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения, т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной формы для хронологической базы данных.</p>\n<p><strong>Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF)</strong> - Отношение находится в BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.</p>\n<p><strong>Доменно-ключевая нормальная форма (DKNF)</strong> - Отношение находится в DKNF, когда каждое наложенное на неё ограничение\nявляется логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-денормализация-для-чего-она-применяется","title":"<p>Что такое <em>«денормализация»</em>? Для чего она применяется?</p>","answer":"<p><strong>Денормализация базы данных</strong> — это процесс осознанного приведения базы данных к виду, в котором она не будет\nсоответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения\nданных, за счет увеличения избыточности данных.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#какие-существуют-типы-связей-в-базе-данных-приведите-примеры","title":"<p>Какие существуют типы связей в базе данных? Приведите примеры</p>","answer":"<ul>\n<li><strong>Один к одному</strong> - любому значению атрибута А соответствует только одно значение атрибута В, и наоборот.</li>\n</ul>\n<blockquote>\n  <p>Каждый университет гарантированно имеет 1-го ректора: <em>1 университет → 1 ректор</em>.</p>\n</blockquote>\n<ul>\n<li><strong>Один ко многим</strong> - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В.</li>\n</ul>\n<blockquote>\n  <p>В каждом университете есть несколько факультетов: <em>1 университет → много факультетов</em>.</p>\n</blockquote>\n<ul>\n<li><strong>Многие ко многим</strong> - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В, и любому\nзначению атрибута В соответствует 0, 1 или несколько значение атрибута А.</li>\n</ul>\n<blockquote>\n  <p>1 профессор может преподавать на нескольких факультетах, в то же время на 1-ом факультете может преподавать несколько профессоров: <em>Несколько профессоров ↔ Несколько факультетов</em>.</p>\n</blockquote>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-индексы-для-чего-их-используют-в-чём-заключаются-их-преимущества-и-недостатки","title":"<p>Что такое <em>«индексы»</em>? Для чего их используют? В чём заключаются их преимущества и недостатки?</p>","answer":"<p><strong>Индекс (index)</strong> — объект базы данных, создаваемый с целью повышения производительности выборки данных.</p>\n<p>Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким образом, достигается значительный прирост скорости выборки из этих данных.</p>\n<p>Преимущества</p>\n<ul>\n<li>ускорение поиска и сортировки по определенному полю или набору полей.</li>\n<li>обеспечение уникальности данных.</li>\n</ul>\n<p>Недостатки</p>\n<ul>\n<li>требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.</li>\n<li>замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.</li>\n</ul>\n<p>Индексы предпочтительней для:</p>\n<ul>\n<li>Поля-счетчика, чтобы в том числе избежать и повторения значений в этом поле;</li>\n<li>Поля, по которому проводится сортировка данных;</li>\n<li>Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее;</li>\n<li>Поля, которое объявлено первичным ключом (primary key);</li>\n<li>Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с нужным значением, все последующие значения будут расположены рядом.</li>\n</ul>\n<p>Использование индексов нецелесообразно для:</p>\n<ul>\n<li>Полей, которые редко используются в запросах;</li>\n<li>Полей, которые содержат всего два или три значения, например: <em>мужской</em>,  <em>женский пол</em> или значения <em>«да»</em>, <em>«нет»</em>.</li>\n</ul>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#какие-типы-индексов-существуют","title":"<p>Какие типы индексов существуют?</p>","answer":"<p><strong>По порядку сортировки</strong></p>\n<ul>\n<li><em>упорядоченные</em> — индексы, в которых элементы упорядочены;</li>\n<li><em>возрастающие</em>;</li>\n<li><em>убывающие</em>;</li>\n<li><em>неупорядоченные</em> — индексы, в которых элементы неупорядочены.</li>\n</ul>\n<p><strong>По источнику данных</strong></p>\n<ul>\n<li><em>индексы по представлению (view)</em>;</li>\n<li><em>индексы по выражениям</em>.</li>\n</ul>\n<p><strong>По воздействию на источник данных</strong></p>\n<ul>\n<li><em>кластерный индекс</em> - при определении в наборе данных физическое расположение данных перестраивается в соответствии со структурой индекса. Логическая структура набора данных в этом случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены, например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности поиска данных даже по сравнению с обычными индексами. Увеличение производительности особенно заметно при работе с последовательными данными.</li>\n<li><em>некластерный индекс</em> — наиболее типичные представители семейства индексов. В отличие от кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный индекс организует специальные указатели, включающие в себя: информацию об идентификационном номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных; номер искомой записи на соответствующей странице; содержимое столбца.</li>\n</ul>\n<p><strong>По структуре</strong></p>\n<ul>\n<li><em>B*-деревья</em>;</li>\n<li><em>B+-деревья</em>;</li>\n<li><em>B-деревья</em>;</li>\n<li><em>Хэши</em>.</li>\n</ul>\n<p><strong>По количественному составу</strong></p>\n<ul>\n<li><em>простой индекс (индекс с одним ключом)</em> — строится по одному полю;</li>\n<li><em>составной (с несколькими ключами, композитный) индекс</em> — строится по нескольким полям при этом важен порядок их следования;</li>\n<li><em>индекс с включенными столбцами</em> — некластеризованный индекс, дополнительно содержащий кроме ключевых столбцов еще и неключевые;</li>\n<li><em>главный индекс (индекс по первичному ключу)</em> — это тот индексный ключ, под управлением которого в данный момент находится набор данных. Набор данных не может быть отсортирован по нескольким индексным ключам одновременно. Хотя, если один и тот же набор данных открыт одновременно в нескольких рабочих областях, то у каждой копии набора данных может быть назначен свой главный индекс.</li>\n</ul>\n<p><strong>По характеристике содержимого</strong></p>\n<ul>\n<li><em>уникальный индекс</em> состоит из множества уникальных значений поля;</li>\n<li><em>плотный индекс</em> (NoSQL) — индекс, при котором, каждом документе в индексируемой коллекции соответствует запись в индексе, даже если в документе нет индексируемого поля.</li>\n<li><em>разреженный индекс</em> (NoSQL) — тот, в котором представлены только те документы, для которых индексируемый ключ имеет какое-то определённое значение (существует).</li>\n<li><em>пространственный индекс</em> — оптимизирован для описания географического местоположения. Представляет из себя индекс с несколькими ключами состоящий из широты и долготы.</li>\n<li><em>составной пространственный индекс</em> — индекс, включающий в себя кроме широты и долготы ещё какие-либо мета-данные (например теги). Но географические координаты должны стоять на первом месте.</li>\n<li><em>полнотекстовый (инвертированный) индекс</em> — словарь, в котором перечислены все слова и указано, в каких местах они встречаются. При наличии такого индекса достаточно осуществить поиск нужных слов в нём и тогда сразу же будет получен список документов, в которых они встречаются.</li>\n<li><em>хэш-индекс</em> предполагает хранение не самих значений, а их хэшей, благодаря чему уменьшается размер (а, соответственно, и увеличивается скорость их обработки) индексов из больших полей. Таким образом, при запросах с использованием хэш-индексов, сравниваться будут не искомое со значения поля, а хэш от искомого значения с хэшами полей.\nИз-за нелинейности хэш-функций данный индекс нельзя сортировать по значению, что приводит к невозможности использования в сравнениях больше/меньше и «is null». Кроме того, так как хэши не уникальны, то для совпадающих хэшей применяются методы разрешения коллизий.</li>\n<li><em>битовый индекс (bitmap index)</em> — метод битовых индексов заключается в создании отдельных битовых карт (последовательностей 0 и 1) для каждого возможного значения столбца, где каждому биту соответствует запись с индексируемым значением, а его значение равное 1 означает, что запись, соответствующая позиции бита содержит индексируемое значение для данного столбца или свойства.</li>\n<li><em>обратный индекс (reverse index)</em> — B-tree индекс, но с реверсированным ключом, используемый в основном для монотонно возрастающих значений (например, автоинкрементный идентификатор) в OLTP системах с целью снятия конкуренции за последний листовой блок индекса, т.к. благодаря переворачиванию значения две соседние записи индекса попадают в разные блоки индекса. Он не может использоваться для диапазонного поиска.</li>\n<li><em>функциональный индекс, индекс по вычисляемому полю (function-based index)</em> — индекс, ключи которого хранят результат пользовательских функций. Функциональные индексы часто строятся для полей, значения которых проходят предварительную обработку перед сравнением в команде SQL. Например, при сравнении строковых данных без учета регистра символов часто используется функция UPPER. Кроме того, функциональный индекс может помочь реализовать любой другой отсутствующий тип индексов данной СУБД.</li>\n<li><em>первичный индекс</em> — уникальный индекс по полю первичного ключа.</li>\n<li><em>вторичный индекс</em> — индекс по другим полям (кроме поля первичного ключа).</li>\n<li><em>XML-индекс</em> — вырезанное материализованное представление больших двоичных XML-объектов (BLOB) в столбце с типом данных xml.</li>\n</ul>\n<p><strong>По механизму обновления</strong></p>\n<ul>\n<li><em>полностью перестраиваемый</em> — при добавлении элемента заново перестраивается весь индекс.</li>\n<li><em>пополняемый (балансируемый)</em> — при добавлении элементов индекс перестраивается частично (например одна из ветви) и периодически балансируется.</li>\n</ul>\n<p><strong>По покрытию индексируемого содержимого</strong></p>\n<ul>\n<li><em>полностью покрывающий (полный) индекс</em> — покрывает всё содержимое индексируемого объекта.</li>\n<li><em>частичный индекс (partial index)</em> — это индекс, построенный на части набора данных, удовлетворяющей определенному условию самого индекса. Данный индекс создан для уменьшения размера индекса.</li>\n<li><em>инкрементный (delta) индекс</em> — индексируется малая часть данных(дельта), как правило, по истечении определённого времени. Используется при интенсивной записи. Например, полный индекс перестраивается раз в сутки, а дельта-индекс строится каждый час. По сути это частичный индекс по временной метке.</li>\n<li><em>индекс реального времени (real-time index)</em> — особый вид инкрементного индекса, характеризующийся высокой скоростью построения. Предназначен для часто меняющихся данных.</li>\n</ul>\n<p><strong>Индексы в кластерных системах</strong></p>\n<ul>\n<li><em>глобальный индекс</em> — индекс по всему содержимому всех сегментов БД (shard).</li>\n<li><em>сегментный индекс</em> — глобальный индекс по полю-сегментируемому ключу (shard key). Используется для быстрого определения сегмента, на котором хранятся данные в процессе маршрутизации запроса в кластере БД.</li>\n<li><em>локальный индекс</em> —  индекс по содержимому только одного сегмента БД.</li>\n</ul>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#в-чем-отличие-между-кластерными-и-некластерными-индексами","title":"<p>В чем отличие между кластерными и некластерными индексами?</p>","answer":"<p>Некластерные индексы - данные физически расположены в произвольном порядке, но логически упорядочены согласно индексу. Такой тип индексов подходит для часто изменяемого набора данных.</p>\n<p>При кластерном индексировании данные физически упорядочены, что серьезно повышает скорость выборок данных (но только в случае последовательного доступа к данным). Для одного набора данных может быть создан только один кластерный индекс.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#имеет-ли-смысл-индексировать-данные-имеющие-небольшое-количество-возможных-значений","title":"<p>Имеет ли смысл индексировать данные, имеющие небольшое количество возможных значений?</p>","answer":"<p>Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае оптимизация приведет к замедлению выборки.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#когда-полное-сканирование-набора-данных-выгоднее-доступа-по-индексу","title":"<p>Когда полное сканирование набора данных выгоднее доступа по индексу?</p>","answer":"<p>Полное сканирование производится многоблочным чтением. Сканирование по индексу - одноблочным. Также, при доступе по индексу сначала идет сканирование самого индекса, а затем чтение блоков из набора данных. Число блоков, которые надо при этом прочитать из набора зависит от фактора кластеризации. Если суммарная стоимость всех необходимых одноблочных чтений больше стоимости полного сканирования многоблочным чтением, то полное сканирование выгоднее и оно выбирается оптимизатором.</p>\n<p>Таким образом, полное сканирование выбирается при слабой селективности предикатов запроса и/или слабой кластеризации\nданных, либо в случае очень маленьких наборов данных.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#что-такое-транзакция","title":"<p>Что такое <em>«транзакция»</em>?</p>","answer":"<p><strong>Транзакция</strong> - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в\nизменении данных, хранящихся в базе данных.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#назовите-основные-свойства-транзакции","title":"<p>Назовите основные свойства транзакции</p>","answer":"<p><strong>Атомарность (atomicity)</strong> гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо\nвыполнены все её подоперации, либо не выполнено ни одной.</p>\n<p><strong>Согласованность (consistency)</strong>. Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои\nрезультаты, сохраняет согласованность базы данных.</p>\n<p><strong>Изолированность (isolation)</strong>. Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на\nеё результат.</p>\n<p><strong>Долговечность (durability)</strong>. Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в\nоборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения\nсистемы в работу.</p>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#какие-существуют-уровни-изолированности-транзакций","title":"<p>Какие существуют уровни изолированности транзакций?</p>","answer":"<p>В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:</p>\n<ul>\n<li><strong>Чтение неподтверждённых данных (грязное чтение) (read uncommitted, dirty read)</strong> — чтение незафиксированных изменений как своей транзакции, так и параллельных транзакций. Нет гарантии, что данные, изменённые другими транзакциями, не будут в любой момент изменены в результате их отката, поэтому такое чтение является потенциальным источником ошибок. Невозможны потерянные изменения, возможны неповторяемое чтение и фантомы.</li>\n<li><strong>Чтение подтверждённых данных (read committed)</strong> — чтение всех изменений своей транзакции и зафиксированных изменений параллельных транзакций. Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы.</li>\n<li><strong>Повторяемость чтения (repeatable read, snapshot)</strong> — чтение всех изменений своей транзакции, любые изменения, внесённые параллельными транзакциями после начала своей, недоступны. Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы.</li>\n<li><strong>Сериализация (serializable)</strong> — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.</li>\n</ul>"},{"subject":"Реляционные базы данных","url":"031-rdbms.html#какие-проблемы-могут-возникать-при-параллельном-доступе-с-использованием-транзакций","title":"<p>Какие проблемы могут возникать при параллельном доступе с использованием транзакций?</p>","answer":"<p>При параллельном выполнении транзакций возможны следующие проблемы:</p>\n<ul>\n<li><strong>Потерянное обновление (lost update)</strong> — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;</li>\n<li><strong>«Грязное» чтение (dirty read)</strong> — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);</li>\n<li><strong>Неповторяющееся чтение (non-repeatable read)</strong> — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;</li>\n<li><strong>Фантомное чтение (phantom reads)</strong> — одна транзакция в ходе своего выполнения несколько раз выбирает множество записей по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи или изменяет столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества записей.</li>\n</ul>\n<p><a href=\"#Реляционные-базы-данных\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/\">Википедия</a></li>\n<li><a href=\"http://tokarchuk.ru/2012/08/indexes-classification/\">tokarchuk.ru</a></li>\n<li><a href=\"http://www.quizful.net/interview/sql/\">Quizful</a></li>\n</ul>"},{"subject":"SQL","url":"032-sql.html#что-такое-sql","title":"<p>Что такое <em>«SQL»</em>?</p>","answer":"<p>SQL, Structured query language («язык структурированных запросов») — формальный непроцедурный язык программирования, применяемый для создания, модификации и управления данными в произвольной реляционной базе данных, управляемой соответствующей системой управления базами данных (СУБД).</p>"},{"subject":"SQL","url":"032-sql.html#какие-существуют-операторы-sql","title":"<p>Какие существуют операторы SQL?</p>","answer":"<p><strong>операторы определения данных (Data Definition Language, DDL)</strong>:</p>\n<ul>\n<li><code>CREATE</code> создает объект БД (базу, таблицу, представление, пользователя и т. д.),</li>\n<li><code>ALTER</code> изменяет объект,</li>\n<li><code>DROP</code> удаляет объект;</li>\n</ul>\n<p><strong>операторы манипуляции данными (Data Manipulation Language, DML)</strong>:</p>\n<ul>\n<li><code>SELECT</code> выбирает данные, удовлетворяющие заданным условиям,</li>\n<li><code>INSERT</code> добавляет новые данные,</li>\n<li><code>UPDATE</code> изменяет существующие данные,</li>\n<li><code>DELETE</code> удаляет данные;</li>\n</ul>\n<p><strong>операторы определения доступа к данным (Data Control Language, DCL)</strong>:</p>\n<ul>\n<li><code>GRANT</code> предоставляет пользователю (группе) разрешения на определенные операции с объектом,</li>\n<li><code>REVOKE</code> отзывает ранее выданные разрешения,</li>\n<li><code>DENY</code> задает запрет, имеющий приоритет над разрешением;</li>\n</ul>\n<p><strong>операторы управления транзакциями (Transaction Control Language, TCL)</strong>:</p>\n<ul>\n<li><code>COMMIT</code> применяет транзакцию,</li>\n<li><code>ROLLBACK</code> откатывает все изменения, сделанные в контексте текущей транзакции,</li>\n<li><code>SAVEPOINT</code> разбивает транзакцию на более мелкие.</li>\n</ul>"},{"subject":"SQL","url":"032-sql.html#что-означает-null-в-sql","title":"<p>Что означает <code>NULL</code> в SQL?</p>","answer":"<p><code>NULL</code> - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных. NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».</p>\n<p><code>NULL</code> означает отсутствие, неизвестность информации. Значение <code>NULL</code> не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому <code>NULL</code> не равно ни логическому значению <code>FALSE</code>, ни <em>пустой строке</em>, ни <code>0</code>. При сравнении <code>NULL</code> с любым значением будет получен результат <code>NULL</code>, а не <code>FALSE</code> и не <code>0</code>. Более того, <code>NULL</code> не равно <code>NULL</code>!</p>"},{"subject":"SQL","url":"032-sql.html#что-такое-временная-таблица-для-чего-она-используется","title":"<p>Что такое <em>«временная таблица»</em>? Для чего она используется?</p>","answer":"<p><strong>Временная таблица</strong> - это объект базы данных, который хранится и управляется системой базы данных на временной основе. Они могут быть локальными или глобальными. Используется для сохранения результатов вызова хранимой процедуры, уменьшение числа строк при соединениях, агрегирование данных из различных источников или как замена курсоров и параметризованных представлений.</p>"},{"subject":"SQL","url":"032-sql.html#что-такое-представление-view-и-для-чего-оно-применяется","title":"<p>Что такое <em>«представление» (view)</em> и для чего оно применяется?</p>","answer":"<p><strong>Представление</strong>, View - виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом.</p>\n<p>В действительности представление – всего лишь результат выполнения оператора <code>SELECT</code>, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.</p>"},{"subject":"SQL","url":"032-sql.html#каков-общий-синтаксис-оператора-select","title":"<p>Каков общий синтаксис оператора <code>SELECT</code>?</p>","answer":"<p><code>SELECT</code> - оператор DML SQL, возвращающий набор данных (выборку) из базы данных, удовлетворяющих заданному условию. Имеет следующую структуру:</p>\n<pre><code class=\"sql language-sql\">SELECT\n       [DISTINCT | DISTINCTROW | ALL]\n       select_expression,...\n   FROM table_references\n     [WHERE where_definition]\n     [GROUP BY {unsigned_integer | column | formula}]\n     [HAVING where_definition]\n     [ORDER BY {unsigned_integer | column | formula} [ASC | DESC], ...]\n</code></pre>"},{"subject":"SQL","url":"032-sql.html#что-такое-join","title":"<p>Что такое <code>JOIN</code>?</p>","answer":"<p><strong>JOIN</strong> - оператор языка SQL, который является реализацией операции соединения реляционной алгебры. Предназначен для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор.</p>\n<p>Особенностями операции соединения являются следующее:</p>\n<ul>\n<li>в схему таблицы-результата входят столбцы обеих исходных таблиц (таблиц-операндов), то есть схема результата является «сцеплением» схем операндов;</li>\n<li>каждая строка таблицы-результата является «сцеплением» строки из одной таблицы-операнда со строкой второй таблицы-операнда;</li>\n<li>при необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).</li>\n</ul>\n<pre><code class=\"sql language-sql\">SELECT\n  field_name [,... n]\nFROM\n  Table1\n  {INNER | {LEFT | RIGHT | FULL} OUTER | CROSS } JOIN\n  Table2\n    {ON &lt;condition&gt; | USING (field_name [,... n])}\n</code></pre>"},{"subject":"SQL","url":"032-sql.html#какие-существуют-типы-join","title":"<p>Какие существуют типы <code>JOIN</code>?</p>","answer":"<p><strong>(INNER) JOIN</strong>\nРезультатом объединения таблиц являются записи, общие для левой и правой таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.</p>\n<p><strong>LEFT (OUTER) JOIN</strong>\nПроизводит выбор всех записей первой таблицы и соответствующих им записей второй таблицы. Если записи во второй таблице не найдены, то вместо них подставляется пустой результат (<code>NULL</code>). Порядок таблиц для оператора важен, поскольку оператор не является симметричным.</p>\n<p><strong>RIGHT (OUTER) JOIN</strong>\n<code>LEFT JOIN</code> с операндами, расставленными в обратном порядке. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.</p>\n<p><strong>FULL (OUTER) JOIN</strong>\nРезультатом объединения таблиц являются все записи, которые присутствуют в таблицах. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.</p>\n<p><strong>CROSS JOIN (декартово произведение)</strong>\nПри выборе каждая строка одной таблицы объединяется с каждой строкой второй таблицы, давая тем самым все возможные сочетания строк двух таблиц. Порядок таблиц для оператора не важен, поскольку оператор является симметричным.</p>"},{"subject":"SQL","url":"032-sql.html#что-лучше-использовать-join-или-подзапросы","title":"<p>Что лучше использовать <code>JOIN</code> или подзапросы?</p>","answer":"<p>Обычно лучше использовать <code>JOIN</code>, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же <code>JOIN</code> имеет заметное преимущество над подзапросами в случае, когда список выбора <code>SELECT</code> содержит столбцы более чем из одной таблицы.</p>\n<p>Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.</p>"},{"subject":"SQL","url":"032-sql.html#для-чего-используется-оператор-having","title":"<p>Для чего используется оператор <code>HAVING</code>?</p>","answer":"<p><code>HAVING</code> используется для фильтрации результата <code>GROUP BY</code> по заданным логическим условиям.</p>"},{"subject":"SQL","url":"032-sql.html#в-чем-различие-между-операторами-having-и-where","title":"<p>В чем различие между операторами <code>HAVING</code> и <code>WHERE</code>?</p>","answer":"<p><code>HAVING</code> используется как <code>WHERE</code>, но в другой части SQL-выражения и, соответственно, на другой стадии формирования ответа.</p>"},{"subject":"SQL","url":"032-sql.html#для-чего-используется-оператор-order-by","title":"<p>Для чего используется оператор <code>ORDER BY</code>?</p>","answer":"<p><strong>ORDER BY</strong> упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание <code>ASC</code> или убывание <code>DESC</code> для каждого столбца. По умолчанию установлено - возрастание.</p>"},{"subject":"SQL","url":"032-sql.html#для-чего-используется-оператор-group-by","title":"<p>Для чего используется оператор <code>GROUP BY</code>?</p>","answer":"<p><code>GROUP BY</code> используется для агрегации записей результата по заданным признакам-атрибутам.</p>"},{"subject":"SQL","url":"032-sql.html#как-group-by-обрабатывает-значение-null","title":"<p>Как <code>GROUP BY</code> обрабатывает значение <code>NULL</code>?</p>","answer":"<p>При использовании <code>GROUP BY</code> все значения <code>NULL</code> считаются равными.</p>"},{"subject":"SQL","url":"032-sql.html#в-чем-разница-между-операторами-group-by-и-distinct","title":"<p>В чем разница между операторами <code>GROUP BY</code> и <code>DISTINCT</code>?</p>","answer":"<p><code>DISTINCT</code> указывает, что для вычислений используются только уникальные значения столбца. <code>NULL</code> считается как отдельное\nзначение.\n<code>GROUP BY</code> создает отдельную группу для всех возможных значений (включая значение <code>NULL</code>).</p>\n<p>Если нужно удалить только дубликаты лучше использовать <code>DISTINCT</code>, <code>GROUP BY</code> лучше использовать для определения групп\nзаписей, к которым могут применяться агрегатные функции.</p>"},{"subject":"SQL","url":"032-sql.html#перечислите-основные-агрегатные-функции","title":"<p>Перечислите основные агрегатные функции</p>","answer":"<p><strong>Агрегатных функции</strong> - функции, которые берут группы значений и сводят их к одиночному значению.</p>\n<p>SQL предоставляет несколько агрегатных функций:</p>\n<p><code>COUNT</code> - производит подсчет записей, удовлетворяющих условию запроса;\n<code>SUM</code> - вычисляет арифметическую сумму всех значений колонки;\n<code>AVG</code> - вычисляет среднее арифметическое всех значений;\n<code>MAX</code> - определяет наибольшее из всех выбранных значений;\n<code>MIN</code> - определяет наименьшее из всех выбранных значений.</p>"},{"subject":"SQL","url":"032-sql.html#в-чем-разница-между-count-и-countcolumn","title":"<p>В чем разница между <code>COUNT(*)</code> и <code>COUNT({column})</code>?</p>","answer":"<p><code>COUNT (*)</code> подсчитывает количество записей в таблице, не игнорируя значение NULL, поскольку эта функция оперирует записями, а не столбцами.</p>\n<p><code>COUNT ({column})</code> подсчитывает количество значений в <code>{column}</code>. При подсчете количества значений столбца эта форма функции <code>COUNT</code> не принимает во внимание значение <code>NULL</code>.</p>"},{"subject":"SQL","url":"032-sql.html#что-делает-оператор-exists","title":"<p>Что делает оператор <code>EXISTS</code>?</p>","answer":"<p><code>EXISTS</code> берет подзапрос, как аргумент, и оценивает его как <code>TRUE</code>, если подзапрос возвращает какие-либо записи и <code>FALSE</code>, если нет.</p>"},{"subject":"SQL","url":"032-sql.html#для-чего-используются-операторы-in-between-like","title":"<p>Для чего используются операторы <code>IN</code>, <code>BETWEEN</code>, <code>LIKE</code>?</p>","answer":"<p><code>IN</code> - определяет набор значений.</p>\n<pre><code class=\"sql language-sql\">SELECT * FROM Persons WHERE name IN ('Ivan','Petr','Pavel');\n</code></pre>\n<p><code>BETWEEN</code> определяет диапазон значений. В отличие от <code>IN</code>, <code>BETWEEN</code> чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.</p>\n<pre><code class=\"sql language-sql\">SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;\n</code></pre>\n<p><code>LIKE</code> применим только к полям типа <code>CHAR</code> или <code>VARCHAR</code>, с которыми он используется чтобы находить подстроки. В качестве условия используются <em>символы шаблонизации (wildcards</em>) - специальные символы, которые могут соответствовать чему-нибудь:</p>\n<ul>\n<li><p><code>_</code> замещает любой одиночный символ. Например, <code>'b_t'</code> будет соответствовать словам <code>'bat'</code> или <code>'bit'</code>, но не будет соответствовать <code>'brat'</code>.</p></li>\n<li><p><code>%</code> замещает последовательность любого числа символов. Например <code>'%p%t'</code> будет соответствовать словам <code>'put'</code>, <code>'posit'</code>, или <code>'opt'</code>, но не <code>'spite'</code>.</p></li>\n</ul>\n<pre><code class=\"sql language-sql\">SELECT * FROM UNIVERSITY WHERE NAME LIKE '%o';\n</code></pre>"},{"subject":"SQL","url":"032-sql.html#для-чего-применяется-ключевое-слово-union","title":"<p>Для чего применяется ключевое слово <code>UNION</code>?</p>","answer":"<p>В языке SQL ключевое слово <code>UNION</code> применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что <code>UNION</code> сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать <code>ORDER BY</code>.</p>"},{"subject":"SQL","url":"032-sql.html#какие-ограничения-на-целостность-данных-существуют-в-sql","title":"<p>Какие ограничения на целостность данных существуют в SQL?</p>","answer":"<p><code>PRIMARY KEY</code> - набор полей (1 или более), значения которых образуют уникальную комбинацию и используются для однозначной идентификации записи в таблице. Для таблицы может быть создано только одно такое ограничение. Данное ограничение используется для обеспечения целостности сущности, которая описана таблицей.</p>\n<p><code>CHECK</code> используется для ограничения множества значений, которые могут быть помещены в данный столбец. Это ограничение используется для обеспечения целостности предметной области, которую описывают таблицы в базе.</p>\n<p><code>UNIQUE</code> обеспечивает отсутствие дубликатов в столбце или наборе столбцов.</p>\n<p><code>FOREIGN KEY</code> защищает от действий, которые могут нарушить связи между таблицами. <code>FOREIGN KEY</code> в одной таблице указывает на <code>PRIMARY KEY</code> в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей <code>FOREIGN KEY</code>, которым не отвечают записи <code>PRIMARY KEY</code>.</p>"},{"subject":"SQL","url":"032-sql.html#какие-отличия-между-ограничениями-primary-и-unique","title":"<p>Какие отличия между ограничениями <code>PRIMARY</code> и <code>UNIQUE</code>?</p>","answer":"<p>По умолчанию ограничение <code>PRIMARY</code> создает кластерный индекс на столбце, а <code>UNIQUE</code> - некластерный. Другим отличием является то, что <code>PRIMARY</code> не разрешает <code>NULL</code> записей, в то время как <code>UNIQUE</code> разрешает одну (а в некоторых СУБД несколько) <code>NULL</code> запись.</p>"},{"subject":"SQL","url":"032-sql.html#может-ли-значение-в-столбце-на-который-наложено-ограничение-foreign-key-равняться-null","title":"<p>Может ли значение в столбце, на который наложено ограничение <code>FOREIGN KEY</code>, равняться <code>NULL</code>?</p>","answer":"<p>Может, если на данный столбец не наложено ограничение <code>NOT NULL</code>.</p>"},{"subject":"SQL","url":"032-sql.html#как-создать-индекс","title":"<p>Как создать индекс?</p>","answer":"<p>Индекс можно создать либо с помощью выражения <code>CREATE INDEX</code>:</p>\n<pre><code class=\"sql language-sql\">CREATE INDEX index_name ON table_name (column_name)\n</code></pre>\n<p>либо указав ограничение целостности в виде уникального <code>UNIQUE</code> или первичного <code>PRIMARY</code> ключа в операторе создания таблицы <code>CREATE TABLE</code>.</p>"},{"subject":"SQL","url":"032-sql.html#что-делает-оператор-merge","title":"<p>Что делает оператор <code>MERGE</code>?</p>","answer":"<p><code>MERGE</code> позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется <code>UPDATE</code>, а если нет - <code>INSERT</code>. При этом изменять поля таблицы в секции <code>UPDATE</code>, по которым идет связывание двух таблиц, нельзя.</p>"},{"subject":"SQL","url":"032-sql.html#в-чем-отличие-между-операторами-delete-и-truncate","title":"<p>В чем отличие между операторами <code>DELETE</code> и <code>TRUNCATE</code>?</p>","answer":"<p><code>DELETE</code> - оператор DML, удаляет записи из таблицы, которые удовлетворяют критерию <code>WHERE</code> при этом задействуются триггеры, ограничения и т.д.</p>\n<p><code>TRUNCATE</code> - DDL оператор (удаляет таблицу и создает ее заново. Причем если на эту таблицу есть ссылки <code>FOREGIN KEY</code> или таблица используется в репликации, то пересоздать такую таблицу не получится).</p>"},{"subject":"SQL","url":"032-sql.html#что-такое-хранимая-процедура","title":"<p>Что такое <em>«хранимая процедура»</em>?</p>","answer":"<p><strong>Хранимая процедура</strong> — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.</p>\n<p>Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.</p>"},{"subject":"SQL","url":"032-sql.html#что-такое-триггер","title":"<p>Что такое <em>«триггер»</em>?</p>","answer":"<p><strong>Триггер (trigger)</strong> — это хранимая процедура особого типа, которую пользователь не вызывает непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных. Триггеры применяются для обеспечения целостности данных и реализации сложной бизнес-логики. Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. Соответственно, в случае обнаружения ошибки или нарушения целостности данных может произойти откат этой транзакции.</p>\n<p>Момент запуска триггера определяется с помощью ключевых слов <code>BEFORE</code> (триггер запускается до выполнения связанного с ним события) или <code>AFTER</code> (после события). В случае, если триггер вызывается до события, он может внести изменения в модифицируемую событием запись. Кроме того, триггеры могут быть привязаны не к таблице, а к представлению (VIEW). В этом случае с их помощью реализуется механизм «обновляемого представления». В этом случае ключевые слова <code>BEFORE</code> и <code>AFTER</code> влияют лишь на последовательность вызова триггеров, так как собственно событие (удаление, вставка или обновление) не происходит.</p>"},{"subject":"SQL","url":"032-sql.html#что-такое-курсор","title":"<p>Что такое <em>«курсор»</em>?</p>","answer":"<p><strong>Курсор</strong> — это объект базы данных, который позволяет приложениям работать с записями «по одной», а не сразу с множеством, как это делается в обычных SQL командах.</p>\n<p>Порядок работы с курсором такой:</p>\n<ul>\n<li>Определить курсор (<code>DECLARE</code>)</li>\n<li>Открыть курсор (<code>OPEN</code>)</li>\n<li>Получить запись из курсора (<code>FETCH</code>)</li>\n<li>Обработать запись…</li>\n<li>Закрыть курсор (<code>CLOSE</code>)</li>\n<li>Удалить ссылку курсора (<code>DEALLOCATE</code>). Когда удаляется последняя ссылка курсора, SQL освобождает структуры данных,\nсоставляющие курсор.</li>\n</ul>"},{"subject":"SQL","url":"032-sql.html#опишите-разницу-типов-данных-datetime-и-timestamp","title":"<p>Опишите разницу типов данных <code>DATETIME</code> и <code>TIMESTAMP</code></p>","answer":"<p><code>DATETIME</code> предназначен для хранения целого числа: <code>YYYYMMDDHHMMSS</code>. И это время не зависит от временной зоны\nнастроенной на сервере.\nРазмер: 8 байт</p>\n<p><code>TIMESTAMP</code> хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени\nГринвича. При получении из базы отображается с учётом часового пояса. Размер: 4 байта</p>"},{"subject":"SQL","url":"032-sql.html#для-каких-числовых-типов-недопустимо-использовать-операции-сложениявычитания","title":"<p>Для каких числовых типов недопустимо использовать операции сложения/вычитания?</p>","answer":"<p>В качестве операндов операций сложения и вычитания нельзя использовать числовой тип <code>BIT</code>.</p>"},{"subject":"SQL","url":"032-sql.html#напишите-запрос","title":"<p>Напишите запрос</p>","answer":"<pre><code class=\"sql language-sql\">CREATE TABLE table\n(\n    id      BIGINT(20) NOT NULL AUTO_INCREMENT,\n    created TIMESTAMP NOT NULL DEFAULT 0,\n    PRIMARY KEY (id)\n);\n</code></pre>\n<p>Требуется написать запрос, который вернет максимальное значение <code>id</code> и значение <code>created</code> для этого <code>id</code>:</p>\n<pre><code class=\"sql language-sql\">SELECT id, created FROM table where id = (SELECT MAX(id) FROM table);\n</code></pre>\n<hr />\n<pre><code class=\"sql language-sql\">CREATE TABLE track_downloads (\n  download_id BIGINT(20) NOT NULL AUTO_INCREMENT,\n  track_id INT NOT NULL,\n  user_id BIGINT(20) NOT NULL,\n  download_time TIMESTAMP NOT NULL DEFAULT 0,\n  PRIMARY KEY (download_id)\n);\n</code></pre>\n<p>Напишите SQL-запрос, возвращающий все пары <code>(download_count, user_count)</code>, удовлетворяющие следующему условию: <code>user_count</code> — общее ненулевое число пользователей, сделавших ровно <code>download_count</code> скачиваний <code>19 ноября 2010 года</code>:</p>\n<pre><code class=\"sql language-sql\">SELECT DISTINCT download_count, COUNT(*) AS user_count\nFROM (\n    SELECT COUNT(*) AS download_count\n    FROM track_downloads WHERE download_time=\"2010-11-19\"\n    GROUP BY user_id)\nAS download_count\nGROUP BY download_count;\n</code></pre>\n<p><a href=\"#sql\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/SQL\">Википедия</a></li>\n<li><a href=\"http://www.quizful.net/interview/sql\">Quizful</a></li>\n</ul>"},{"subject":"Нереляционные базы данных","url":"033-nosql.html#что-такое-нереляционная-база-данных-nosql","title":"<p>Что такое <em>«нереляционная база данных (NoSQL)»</em>?</p>","answer":"<p><strong>NoSQL</strong> (от англ. <em>not only SQL — не только SQL</em>) — термин, обозначающий ряд подходов, направленных на реализацию\nсистем управления базами данных, имеющих существенные отличия от моделей, используемых в традиционных реляционных СУБД с\nдоступом к данным средствами языка SQL. Применяется к базам данных, в которых делается попытка решить проблемы\nмасштабируемости и доступности за счёт атомарности (англ. atomicity) и согласованности данных (англ. consistency).</p>\n<p>Сам термин был придуман в 2009, как хештег в Твитере для встречи, на которой обсуждались нереляционные системы хранения.</p>\n<p>Типы NoSQL баз данных:</p>\n<ul>\n<li><p><strong>Модель «ключ — значение»</strong> является простейшим вариантом, использующим ключ для доступа к значению. Такие системы\nиспользуются для хранения изображений, создания специализированных файловых систем, в качестве кэшей для объектов, а\nтакже в системах, спроектированных с прицелом на масштабируемость. Примеры таких хранилищ — Berkeley DB, MemcacheDB,\nRedis, Riak, Amazon DynamoDB.</p></li>\n<li><p><strong>«Семейство столбцов»</strong>, прародитель этого типа — система Google BigTable. В таких системах данные хранятся в виде разреженной матрицы, строки и столбцы которой используются как ключи. Типичным применением этого типа СУБД является веб-индексирование, а также задачи, связанные с большими данными, с пониженными требованиями к согласованности. Примерами СУБД данного типа являются: Apache HBase, Apache Cassandra, ScyllaDB, Apache Accumulo, Hypertable.</p></li>\n<li><p><strong>Документоориентированные СУБД</strong> служат для хранения иерархических структур данных. Находят своё применение в системах управления содержимым, издательском деле, документальном поиске. Примеры СУБД данного типа — CouchDB, Couchbase, MongoDB, eXist, Berkeley DB XML.</p></li>\n<li><p><strong>Графовые СУБД</strong> применяются для задач, в которых данные имеют большое количество связей, например, социальные сети, выявление мошенничества. Примеры: Neo4j, OrientDB, AllegroGraph, Blazegraph, InfiniteGraph, FlockDB, Titan.</p></li>\n</ul>\n<p><a href=\"#Нереляционные-базы-данных\">к оглавлению</a></p>"},{"subject":"Передача сообщений","url":"040-mq.html#что-такое-message-oriented-middleware","title":"<p>Что такое Message-oriented Middleware?</p>","answer":"<p>…\n<a href=\"#Передача-сообщений\">к оглавлению</a></p>"},{"subject":"Основы сетей","url":"050-net.html#какие-существуют-уровни-модели-osi","title":"<p>Какие существуют уровни модели <em>OSI</em>?</p>","answer":"<table>\n<thead>\n<tr>\n<th>#</th>\n<th>Уровень (layer)</th>\n<th>Тип данных (PDU)</th>\n<th>Функции</th>\n<th>Примеры</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>7</td>\n<td>Прикладной (application)</td>\n<td>-</td>\n<td>Доступ к сетевым службам</td>\n<td>HTTP, FTP</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Представительский (представления) (presentation)</td>\n<td>-</td>\n<td>Представление и шифрование данных</td>\n<td>ASCII, JPEG</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Сеансовый (session)</td>\n<td>-</td>\n<td>Управление сеансом связи</td>\n<td>RPC, PAP</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Транспортный (transport)</td>\n<td>Сегменты(segment) / Дейтаграммы(datagram)</td>\n<td>Прямая связь между конечными пунктами и надежность</td>\n<td>TCP, UDP</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Сетевой (network)</td>\n<td>Пакеты (packet)</td>\n<td>Определение маршрута и логическая адресация</td>\n<td>IP, AppleTalk</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Канальный (data link)</td>\n<td>Биты (bit) / Кадры (frame)</td>\n<td>Физическая адресация</td>\n<td>Ethernet, IEEE 802.2, L2TP</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Физический (physical)</td>\n<td>Биты (bit)</td>\n<td>Работа со средой передачи, сигналами и двоичными данными</td>\n<td>USB, витая пара</td>\n</tr>\n</tbody>\n</table>"},{"subject":"Основы сетей","url":"050-net.html#что-такое-tcpip","title":"<p>Что такое <em>TCP/IP</em>?</p>","answer":"<p><strong>TCP/IP</strong> - это два основных сетевых протокола Internet. Часто это название используют и для обозначения сетей, работающих на их основе.</p>\n<p><strong>IP (Internet Protocol)</strong> - маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию, фрагментацию и восстановление пакетов. В его задачу входит продвижение пакета между сетями – от одного маршрутизатора до другого и тех пор, пока пакет не попадет в сеть назначения. В отличие от протоколов прикладного и транспортного уровней, протокол IP разворачивается не только на хостах, но и на всех шлюзах (маршрутизаторах). Этот протокол работает без установления соединения и без гарантированной доставки.</p>\n<p>В настоящее время используются следующие две версии протокола IP:</p>\n<ul>\n<li><em>IPv6</em> — IP-адрес имеет разрядность 128 бит и записывается в виде восьми 16-битных полей, с использованием шестнадцатеричной системы счисления и с возможностью сокращения двух и более последовательных нулевых полей до <code>::</code>, например: <code>2001:db8:42::1337:cafe</code></li>\n<li><em>IPv4</em> — IP-адрес имеет разрядность 32 бита и записывается в виде четырех десятичных чисел в диапазоне 0 … 255 через точку, например: <code>192.0.2.34</code>.</li>\n</ul>\n<p><strong>TCP (Transfer Control Protocol)</strong> - протокол, обеспечивающий надежную, требующую логического соединения связь между двумя компьютерами. Отвечает за установление соединения, упорядочивание посылаемых пакетов и восстановление пакетов, потерянных в процессе передачи.</p>\n<p>Стек протоколов <em>TCP/IP</em> включает в себя четыре уровня:</p>\n<ol>\n<li><em>канальный уровень (link layer)</em> - например Ethernet, IEEE 802.11 Wireless Ethernet, физическая среда и принципы кодирования информации</li>\n<li><em>сетевой уровень (Internet layer)</em> - например IP</li>\n<li><em>транспортный уровень (transport layer)</em> - например TCP, UDP</li>\n<li><em>прикладной уровень (application layer)</em> - например HTTP, FTP, DNS</li>\n</ol>\n<p>TCP-соединение двух узлов начинается с <em>handshake (рукопожатия)</em>:</p>\n<ul>\n<li>Узел <em>A</em> посылает узлу <em>B</em> специальный пакет <code>SYN</code> — приглашение к соединению</li>\n<li><em>B</em> отвечает пакетом <code>SYN-ACK</code> — согласием об установлении соединения</li>\n<li><em>A</em> посылает пакет <code>ACK</code> — подтверждение, что согласие получено</li>\n</ul>\n<p>После этого <em>TCP соединение</em> считается установленным и приложения, работающие в этих узлах, могут посылать друг другу пакеты с данными.</p>\n<p>В заголовке <em>TCP/IP</em> пакета указывается:</p>\n<ul>\n<li>IP-адрес отправителя</li>\n<li>IP-адрес получателя</li>\n<li>Номер порта</li>\n</ul>"},{"subject":"Основы сетей","url":"050-net.html#что-такое-udp","title":"<p>Что такое <em>UDP</em>?</p>","answer":"<p><strong>UDP, User Datagram Protocol (Протокол пользовательских датаграмм)</strong> — протокол, который обеспечивает доставку без требований соединения с удаленным модулем UDP и обязательного подтверждения получения.</p>\n<p>К заголовку IP-пакета UDP добавляет всего четыре поля по 2 байта каждое:</p>\n<ol>\n<li><em>поле порта источника (source port)</em></li>\n<li><em>поле порта пункта назначения (destination port)</em></li>\n<li><em>поле длины (length)</em></li>\n<li><em>поле контрольной суммы (checksum)</em></li>\n</ol>\n<p>Поля «порт источника» и «контрольная сумма» не являются обязательными для использования в IPv4. В IPv6 необязательно только поле «порт отправителя».</p>\n<p>UDP используется <em>DNS</em>, <em>SNMP</em>, <em>DHCP</em> и другими приложениями.</p>"},{"subject":"Основы сетей","url":"050-net.html#чем-отличаются-tcp-и-udp","title":"<p>Чем отличаются <em>TCP</em> и <em>UDP</em>?</p>","answer":"<p><strong>TCP</strong> — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки соединения между двумя хостами. Как только соединение установлено, пользователи могут отправлять данные в обоих направлениях.</p>\n<ul>\n<li><em>Надёжность</em> — TCP управляет подтверждением, повторной передачей и тайм-аутом сообщений. Производятся многочисленные попытки доставить сообщение. Если оно потеряется на пути, сервер вновь запросит потерянную часть. В TCP нет ни пропавших данных, ни (в случае многочисленных тайм-аутов) разорванных соединений.</li>\n<li><em>Упорядоченность</em> — если два сообщения последовательно отправлены, первое сообщение достигнет приложения-получателя первым. Если участки данных приходят в неверном порядке, TCP отправляет неупорядоченные данные в буфер до тех пор, пока все данные не могут быть упорядочены и переданы приложению.</li>\n<li><em>Тяжеловесность</em> — TCP необходимо три пакета для установки соединения перед тем, как отправить данные. TCP следит за надёжностью и перегрузками.</li>\n<li><em>Потоковая передача</em> — данные читаются как поток байтов, не передается никаких особых обозначений для границ сообщения или сегментов.</li>\n</ul>\n<p><strong>UDP</strong> — более простой, основанный на сообщениях протокол без установления соединения. Протоколы такого типа не устанавливают выделенного соединения между двумя хостами. Связь достигается путём передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя.</p>\n<ul>\n<li><em>Ненадёжность</em> — когда сообщение посылается, неизвестно, достигнет ли оно своего назначения — оно может потеряться по пути. Нет таких понятий как подтверждение, повторная передача, тайм-аут.</li>\n<li><em>Неупорядоченность</em> — если два сообщения отправлены одному получателю, то порядок их достижения цели не может быть предугадан.</li>\n<li><em>Легковесность</em> — никакого упорядочивания сообщений, никакого отслеживания соединений и т. д. Это лишь транспортный уровень.</li>\n<li><em>Датаграммы</em> — пакеты посылаются по отдельности и проверяются на целостность только если они прибыли. Пакеты имеют определенные границы, которые соблюдаются после получения, то есть операция чтения на получателе выдаст сообщение таким, каким оно было изначально послано.</li>\n<li><em>Отсутствие контроля перегрузок</em> — для приложений с большой пропускной способностью существует шанс вызвать коллапс перегрузок, если только они не реализуют меры контроля на прикладном уровне.</li>\n</ul>"},{"subject":"Основы сетей","url":"050-net.html#что-такое-протокол-передачи-данных-какие-протоколы-вы-знаете","title":"<p>Что такое протокол передачи данных? Какие протоколы вы знаете?</p>","answer":"<p><strong>Протокол передачи данных</strong> — набор соглашений интерфейса логического уровня, которые определяют обмен данными между различными программами. Эти соглашения задают единообразный способ передачи сообщений и обработки ошибок при взаимодействии программного обеспечения разнесённой в пространстве аппаратуры, соединённой тем или иным интерфейсом.</p>\n<p>Наиболее известные протоколы передачи данных:</p>\n<ul>\n<li>HTTP (Hyper Text Transfer Protocol)</li>\n<li>FTP (File Transfer Protocol)</li>\n<li>POP3 (Post Office Protocol)</li>\n<li>SMTP (Simple Mail Transfer Protocol)</li>\n<li>TELNET (TErminaL NETwork)</li>\n</ul>\n<p><a href=\"#Основы-сетей\">к оглавлению</a></p>"},{"subject":"Настройка окружения","url":"051-environment.html#сравните-ос-windows-и-linux","title":"<p>Сравните ОС Windows и Linux</p>","answer":"<p>…</p>"},{"subject":"Настройка окружения","url":"051-environment.html#что-такой-bash","title":"<p>Что такой <code>bash</code>?</p>","answer":"<p>…</p>"},{"subject":"Настройка окружения","url":"051-environment.html#с-помощью-каких-bash-команд-посмотреть-доступные-ресурсы","title":"<p>С помощью каких bash-команд посмотреть доступные ресурсы?</p>","answer":"<ul>\n<li><strong>top</strong> - список выполняемых процессов</li>\n<li><strong>free</strong> - объем ОЗУ</li>\n<li><strong>df</strong> - объем постоянной памяти</li>\n</ul>"},{"subject":"Настройка окружения","url":"051-environment.html#что-такое-docker-контейнер","title":"<p>Что такое Docker-контейнер?</p>","answer":"<p>…</p>"},{"subject":"Настройка окружения","url":"051-environment.html#как-работает-ansible","title":"<p>Как работает Ansible?</p>","answer":"<p>…</p>\n<p><a href=\"#Настройка-окружения\">к оглавлению</a></p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#какие-бывают-инструменты-для-автоматизации-сборки-java-проектов","title":"<p>Какие бывают инструменты для автоматизации сборки Java-проектов?</p>","answer":"<p>bat/bash-скрипт, Ant, Maven, Gradle.</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#сравните-gradle-и-maven","title":"<p>Сравните Gradle и Maven</p>","answer":"<p>…</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#какие-бывают-системы-контроля-версий","title":"<p>Какие бывают системы контроля версий?</p>","answer":"<p><strong>С единым центром</strong> - CVS, SVN.</p>\n<p><strong>Распределённые</strong> - git.</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#что-такое-распределённая-система-контроля-версий-на-примере-git","title":"<p>Что такое распределённая система контроля версий на примере GIT?</p>","answer":"<p>…</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#какие-механизмы-слияния-существуют-в-git","title":"<p>Какие механизмы слияния существуют в GIT?</p>","answer":"<p>…</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#назовите-инструменты-для-версионирования-субд","title":"<p>Назовите инструменты для версионирования СУБД</p>","answer":"<p>FlyWay, LiquidBase.</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#что-такое-ci","title":"<p>Что такое CI?</p>","answer":"<p><strong>Continuous Integration (CI, Непрерывная интеграция)</strong> - это практика разработки программного обеспечения, в которой участники команды часто выполняют интеграцию своих изменений. Как правило, каждый участник выполняет интеграцию как минимум раз в день, и в итоге достигается такой режим работы, при котором интеграция выполняется несколько раз в день. Каждая интеграция проверяется путём автоматической сборки (включающей тестирование), что позволяет находить ошибки интеграции как можно скорее.</p>\n<p>Не стоит путать данную практику с CI-инструментами.</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#что-такое-cd","title":"<p>Что такое CD?</p>","answer":"<p>…</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#в-чём-разница-между-continuous-delivery-и-deployment","title":"<p>В чём разница между Continuous Delivery и Deployment?</p>","answer":"<p>…</p>"},{"subject":"Инструменты для совместной работы","url":"052-tools.html#какие-cicd-инструменты-вы-знаете","title":"<p>Какие CI/CD-инструменты Вы знаете?</p>","answer":"<p>Hudson/Jenkins, Teamcity, Bamboo, GitLab.</p>\n<p><a href=\"Инструменты-для-совместной-работы\">к оглавлению</a></p>"},{"subject":"Основы обеспечения безопасности","url":"053-security.html#что-такое-авторизация-и-аутентификация-чем-они-отличаются","title":"<p>Что такое <em>«авторизация»</em> и <em>«аутентификация»</em>? Чем они отличаются?</p>","answer":"<p><strong>Аутентификация</strong> - это проверка соответствия субъекта и того, за кого он пытается себя выдать, с помощью некой уникальной информации (отпечатки пальцев, цвет радужки, голос и т. д.), в простейшем случае - с помощью имени входа и пароля.</p>\n<p><strong>Авторизация</strong> - это проверка и определение полномочий на выполнение некоторых действий (например, чтение файла) в соответствии с ранее выполненной аутентификацией.</p>\n<p>Очевидно, что это разные понятия, но при этом без первого не может быть второго и наоборот. То есть имея разрешение на работу, вы не сможете оказаться на рабочем месте без предъявления пропуска, равно как и нет смысла в демонстрации пропуска, если вы не планируете работать. Именно тот факт, что одного не бывает без другого, и вызывает у людей заблуждение, что это одно и то же.</p>"},{"subject":"Основы обеспечения безопасности","url":"053-security.html#что-такое-secure-software-development","title":"<p>Что такое Secure Software Development?</p>","answer":"<p>…</p>"},{"subject":"Основы обеспечения безопасности","url":"053-security.html#что-такое-сертификат","title":"<p>Что такое сертификат?</p>","answer":"<p>…</p>"},{"subject":"Основы обеспечения безопасности","url":"053-security.html#что-такое-ssl","title":"<p>Что такое SSL?</p>","answer":"<p>…</p>\n<p><a href=\"#Основы-обеспечения-безопасности\">к оглавлению</a></p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-www","title":"<p>Что такое <em>WWW</em>?</p>","answer":"<p><strong>WWW, World Wide Web (Всемирная паутина)</strong> — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к Интернету. Для обозначения этого термина также используют слово <em>web</em>.</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-w3c","title":"<p>Что такое <em>W3C</em>?</p>","answer":"<p><strong>W3C, World Wide Web Consortium (Консорциум Всемирной паутины)</strong> — организация, разрабатывающая и внедряющая технологические стандарты для WWW.</p>\n<p>W3C разрабатывает для Интернета единые принципы и стандарты, называемые <em>«рекомендациями» (W3C Recommendations)</em>, которые затем внедряются производителями программ и оборудования. Таким образом достигается совместимость между программными продуктами и аппаратурой различных компаний.</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-http-и-https-чем-они-отличаются","title":"<p>Что такое <em>HTTP</em> и <em>HTTPS</em>? Чем они отличаются?</p>","answer":"<p><strong>HTTP, HyperText Transfer Protocol (Протокол передачи гипертекста)</strong> — протокол прикладного уровня передачи данных.</p>\n<p>Основой HTTP является технология «клиент-сервер»:</p>\n<ul>\n<li><em>Потребители (клиенты)</em>, которые инициируют соединение и посылают запрос;</li>\n<li><em>Поставщики (серверы)</em>, которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</li>\n</ul>\n<p>Для идентификации ресурсов HTTP использует глобальные URI.</p>\n<p>HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ».</p>\n<p>Структура протокола:</p>\n<ol>\n<li><em>Стартовая строка (starting line)</em> — определяет тип сообщения;</li>\n<li><em>Заголовки (headers)</em> — характеризуют тело сообщения, параметры передачи и прочие сведения;</li>\n<li><em>Тело сообщения (message body)</em> — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.</li>\n</ol>\n<p>Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом, так как указывает на тип запроса/ответа.</p>\n<p><strong>HTTPS, HyperText Transfer Protocol Secure</strong> — расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS, что обеспечивает защиту от атак, основанных на прослушивании сетевого соединения (при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют).</p>\n<p><strong>Различия <em>HTTP</em> и <em>HTTPS</strong></em>:</p>\n<ul>\n<li><p>HTTPS является расширением HTTP.</p></li>\n<li><p>HTTP использует не зашифрованное соединение. Соединение по HTTPS поддерживает шифрование.</p></li>\n<li><p>Работа по HTTP быстрей и менее ресурсоёмко, т.к. шифрование HTTPS требует дополнительных затрат.</p></li>\n<li><p>Порты по умолчанию: в случае HTTP это TCP-порт <code>80</code>, для HTTPS - TCP-порт <code>443</code>.</p></li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#чем-отличаются-методы-http11-и-http2","title":"<p>Чем отличаются методы HTTP/1.1 и HTTP/2?</p>","answer":"<p>Протокол HTTP/2  является бинарным. По сравнению с предыдущим стандартом изменены способы разбиения данных на фрагменты и транспортирования их между сервером и клиентом. В HTTP/2 сервер имеет право послать то содержимое, которое ещё не было запрошено клиентом. Это позволит серверу сразу выслать дополнительные файлы, которые потребуются браузеру для отображения страниц, без необходимости анализа браузером основной страницы и запрашивания необходимых дополнений. Также часть улучшений получена (в первом черновике HTTP/2, который представлял собой копию спецификации SPDY) за счёт мультиплексирования запросов и ответов для преодоления проблемы «head-of-line blocking» протоколов HTTP 1; сжатия передаваемых заголовков и введения явной приоритизации запросов.</p>"},{"subject":"Основы Web","url":"060-web.html#какие-серии-кодов-состояния-есть-в-http","title":"<p>Какие серии кодов состояния есть в HTTP?</p>","answer":"<p><strong>Код состояния HTTP (англ. HTTP status code)</strong> — часть первой строки ответа сервера при запросах по протоколу HTTP. Он представляет собой целое число из трёх десятичных цифр. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа.</p>\n<ul>\n<li><strong>1xx</strong> (информационные)<ul>\n<li><em>100 - Continue</em></li>\n<li><em>101 - Switching Protocols</em>;</li>\n<li><em>102 - Processing</em>.</li></ul></li>\n<li><strong>2xx</strong><ul>\n<li><em>200 OK</em></li>\n<li><em>201 Created</em></li>\n<li>…</li></ul></li>\n<li><strong>3xx</strong><ul>\n<li><em>300 Multiple Choices</em></li>\n<li><em>301 Moved Permanently</em></li>\n<li><em>302 Moved Temporarily</em></li>\n<li><em>302 Found</em></li>\n<li>…</li></ul></li>\n<li><strong>4xx</strong><ul>\n<li><em>400 Bad Request</em></li>\n<li><em>401 Unauthorized</em></li>\n<li><em>402 Payment Required</em></li>\n<li><em>403 Forbidden</em></li>\n<li><em>404 Not Found</em></li>\n<li><em>405 Method Not Allowed</em></li>\n<li><em>406 Not Acceptable</em></li>\n<li><em>407 Proxy Authentication Required</em></li>\n<li><em>408 Request Timeout</em></li>\n<li>..</li></ul></li>\n<li><strong>5xx</strong><ul>\n<li><em>500 Internal Server Error</em></li>\n<li><em>501 Not Implemented</em></li>\n<li><em>502 Bad Gateway</em></li>\n<li><em>503 Service Unavailable</em></li>\n<li><em>504 Gateway Timeout</em></li>\n<li>…</li></ul></li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#чем-отличаются-методы-get-и-post","title":"<p>Чем отличаются методы <em>GET</em> и <em>POST</em>?</p>","answer":"<p><strong>GET</strong> передает данные серверу используя URL, тогда как <strong>POST</strong> передает данные, используя тело HTTP запроса. Длина URL ограничена 1024 символами, это и будет верхним ограничением для данных, которые можно отослать через GET. POST может отправлять гораздо большие объемы данных. Лимит устанавливается web-server и составляет обычно около 2 Mb.</p>\n<p>Передача данных методом POST более безопасна, чем методом GET, так как секретные данные (например пароль) не отображаются напрямую в web-клиенте пользователя, в отличие от URL, который виден почти всегда. Иногда это преимущество превращается в недостаток - вы не сможете послать данные за кого-то другого.</p>"},{"subject":"Основы Web","url":"060-web.html#чем-отличаются-методы-post-put-и-patch","title":"<p>Чем отличаются методы <em>POST</em>, <em>PUT</em> и <em>PATCH</em>?</p>","answer":"<p>Все эти методы использует тело HTTP запроса для передачи данных.</p>\n<ul>\n<li><strong>POST</strong> —  используется для создания ресурса.</li>\n<li><strong>PUT</strong> — используется для замены ресурса целиком.</li>\n<li><strong>PATCH</strong> — используется для редактирования ресурса.</li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#что-такое-mime-тип","title":"<p>Что такое <em>MIME тип</em>?</p>","answer":"<p><strong>MIME, Multipurpose Internet Mail Extension (Многоцелевые расширения Интернет-почты)</strong> — спецификация для передачи по сети файлов различного типа: изображений, музыки, текстов, видео, архивов и др. В HTML указание MIME-типа используется при  передаче данных форм и вставки на страницу различных объектов.</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-web-service","title":"<p>Что такое <em>Web service</em>?</p>","answer":"<p>…</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-web-server","title":"<p>Что такое <em>Web server</em>?</p>","answer":"<p><strong>Web server (Веб-сервер)</strong> — сервер, принимающий HTTP-запросы от клиентов и выдающий им HTTP-ответы. Так называют как программное обеспечение, выполняющее функции web-сервера, так и непосредственно компьютер, на котором это программное обеспечение работает.</p>\n<p>Web-серверы могут иметь различные дополнительные функции, например:</p>\n<ul>\n<li>автоматизация работы web-страниц;</li>\n<li>ведение журнала обращений пользователей к ресурсам;</li>\n<li>аутентификация и авторизация пользователей;</li>\n<li>поддержка динамически генерируемых страниц;</li>\n<li>поддержка HTTPS для защищённых соединений с клиентами.</li>\n</ul>\n<p>Наиболее известные web-серверы:</p>\n<ul>\n<li>Apache</li>\n<li>Microsoft IIS</li>\n<li>nginx</li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#что-такое-web-application","title":"<p>Что такое <em>Web application</em>?</p>","answer":"<p><strong>Web application (Веб-приложение)</strong> - клиент-серверное приложение, в котором клиентом выступает браузер, а сервером — web-сервер. Логика web application распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, а обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому web application является кроссплатформенным сервисом.</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-application-server","title":"<p>Что такое <em>Application server</em>?</p>","answer":"<p><strong>Application Server (Сервер приложений)</strong> — программа, представляющая собой сервер, который занимается системной поддержкой приложений и обеспечивает их жизненный цикл в соответствии с правилами, определёнными в спецификациях. Может работать как полноценный самостоятельный web-сервер или быть поставщиком страниц для другого web-сервера. Обеспечивает обмен данными между приложениями и клиентами, берёт на себя выполнение таких функций, как создание программной среды для функционирующего приложения, идентификацию и авторизацию клиентов, организацию сессии для каждого из них.</p>\n<p>Наиболее известные серверы приложений Java:</p>\n<ul>\n<li>Apache Tomcat</li>\n<li>Jetty</li>\n<li>JBoss</li>\n<li>GlassFish</li>\n<li>IBM WebSphere</li>\n<li>Oracle Weblogic</li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#чем-отличаются-web-server-и-application-server","title":"<p>Чем отличаются <em>Web server</em> и <em>Application server</em>?</p>","answer":"<p>Понятие web server относится скорее к способу передачи данных (конкретно, по протоколу HTTP), в то время как понятие Application server относится к способу выполнения этих самых приложений (конкретно, удаленная обработка запросов клиентов при помощи каких-то программ, размещенных на сервере). Эти понятия нельзя ставить в один ряд. Они обозначают разные признаки программы. Какие-то программы удовлетворяют только одному признаку, какие-то - нескольким сразу.</p>\n<p>Apache Tomcat умеет выполнять приложения? Да, значит он является application server. Apache Tomcat умеет отдавать данные по HTTP? - Да. Следовательно он является web server.</p>\n<p>Возьмите какую-нибудь базу данных, в которой на хранимых процедурах описана сложная логика и можно в ответ на SQL-запросы отправлять даже sms. Такую базу данных можно назвать application server, но web server - уже нет, потому что все это не работает с клиентом по HTTP протоколу.</p>\n<p>Возьмите чистый Apache, в котором не включены никакие модули для поддержки языков программирования. Он умеет отдавать только статичные файлы и картинки по протоколу HTTP. Это web server, но не application server. Включите модуль для поддержки PHP и разместите там программу на PHP, которая делает запросы к базе данных и динамически формирует страницы. Теперь Apache стал и application server.</p>"},{"subject":"Основы Web","url":"060-web.html#что-такое-websocket","title":"<p>Что такое <em>WebSocket</em>?</p>","answer":"<p><strong>WebSocket</strong> — протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и web-сервером в режиме реального времени.</p>\n<p>Протокол <em>WebSocket</em> определяет две URI схемы</p>\n<ul>\n<li><code>ws:</code> - нешифрованное соединение</li>\n<li><code>wss:</code> - шифрованное соединение</li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#что-такое-cookies","title":"<p>Что такое <em>cookies</em>?</p>","answer":"<p><strong>Cookies («куки»)</strong> — небольшой фрагмент данных, отправленный web-сервером и хранимый на устройстве пользователя. Всякий раз при попытке открыть страницу сайта, web-клиент пересылает соответствующие этому сайту cookies web-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя и на практике обычно используется для:</p>\n<ul>\n<li>аутентификации пользователя;</li>\n<li>хранения персональных предпочтений и настроек пользователя;</li>\n<li>отслеживания состояния сеанса доступа пользователя;</li>\n<li>ведения разнообразной статистики.</li>\n</ul>"},{"subject":"Основы Web","url":"060-web.html#что-такое-сессия","title":"<p>Что такое <em>«сессия»</em>?</p>","answer":"<p><strong>Сессия</strong> – промежуток времени между первым и последним запросами, которые пользователь отправляет со своего устройства на сервер сайта. Завершается сессия в случае, если со стороны пользователя не поступало запросов в течение определенного промежутка времени или же при обрыве связи.</p>\n<p><a href=\"#Основы-web\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/\">Википедия</a></li>\n</ul>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-xml","title":"<p>Что такое <em>XML</em>?</p>","answer":"<p><strong>XML, eXtensible Markup Language (расширяемый язык разметки)</strong> - язык с простым формальным синтаксисом, хорошо приспособленный для создания и обработки документов программами и одновременно удобный для чтения и создания документов человеком.</p>\n<p>XML расширяем, он не фиксирует разметку, используемую в документах и разработчик волен создавать разметку в соответствии с потребностями конкретной области, будучи ограниченным лишь синтаксическими правилами языка.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-dtd","title":"<p>Что такое <em>DTD</em>?</p>","answer":"<p><strong>DTD, Document Type Definition (определение типа документа)</strong> — это заранее определённый свод правил, задающий связи между элементами и атрибутами.</p>\n<blockquote>\n  <p>Например, DTD для HTML гласит, что тэг <code>DIV</code> должен быть внутри тэга <code>BODY</code> и может встречаться многократно, <code>TITLE</code> — в <code>HEAD</code> и всего один раз, а <code>SCRIPT</code> – и там, и там сколь угодно раз.</p>\n</blockquote>\n<p>DTD обычно описывается непосредственно в документе в виде строки-формулировки, начинающейся с <code>&lt;!DOCTYPE ... &gt;</code> или отдельном файле.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#чем-well-formed-xml-отличается-от-valid-xml","title":"<p>Чем <em>well-formed XML</em> отличается от <em>valid XML</em>?</p>","answer":"<p>В зависимости от уровня соответствия стандартам документ может быть «well-formed» («правильно построенный»), либо «valid» («действительный»).</p>\n<p>Основные признаки <em>well-formed XML</em> следуют из формального описания стандарта:</p>\n<ul>\n<li>Документ имеет ровно один корневой элемент, в котором лежат все остальные. То есть, <code>&lt;document&gt;...&lt;/document&gt;&lt;appendix&gt;...&lt;/appendix&gt;</code> - это не XML-документ.</li>\n<li>Все открытые теги обязаны быть закрыты. HTML, например, допускает не закрывать многие теги (<code>&lt;p&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;li&gt;</code>, <code>&lt;td&gt;</code> и многие другие). В XML так делать нельзя.</li>\n<li>Для одиночных тегов (типа <code>&lt;br&gt;</code>) , чтобы отличать их от открывающих, предусмотрена специальная запись: <code>&lt;br/&gt;</code>. Но можно написать и полностью <code>&lt;br&gt;&lt;/br&gt;</code>.</li>\n<li>Имена тегов регистрозависимые. Если вы открываете тег <code>&lt;SiteDescription&gt;</code>, то его надо закрывать именно таким же, <code>&lt;/sitedescription&gt;</code> не допускается.</li>\n<li>Теги не могут нарушать вложенность. Вот такого не должно быть: <code>&lt;em&gt;&lt;b&gt;...&lt;/em&gt;&lt;/b&gt;</code>.</li>\n<li>Все атрибуты тегов обязаны быть заключены в двойные кавычки (<code>\"</code>).</li>\n<li>Есть три символа - <code>&lt;</code>, <code>&gt;</code> и <code>&amp;</code>, которые обязаны быть экранированы везде с помощью <code>&amp;lt;</code>, <code>&amp;gt;</code> и <code>&amp;amp;</code>. Внутри атрибутов надо экранировать еще и двойную кавычку с помощью <code>&amp;quot;</code>.</li>\n<li>Все символы в документе обязаны соответствовать заявленной кодировке.</li>\n</ul>\n<p>Документ является <em>valid</em>, если он сформирован с соблюдением всех синтаксических правил корректности конкретного XML, т.е. соответствует <em>DTD</em>.</p>\n<p><strong><em>well-formed XML</em> - корректен синтаксически (может быть разобран парсером), а <em>valid XML</em> - корректен как синтаксически так и семантически (удовлетворяет правилам заранее описанных словаря и грамматики (DTD)).</strong></p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-пространство-имен-в-xml","title":"<p>Что такое «<em>пространство имен</em>» в XML?</p>","answer":"<p><strong>Пространство имён XML (XML namespace)</strong> - это идентифицируемая с помощью ссылки URI коллекция имен, используемых в XML документах для обозначения типов элементов и именования атрибутов. Пространство имен XML отличается от тех «пространств имен», которые обычно используются в компьютерных дисциплинах, тем, что в варианте для XML оно имеет внутреннюю структуру, и, с математической точки зрения, набором не является.</p>\n<blockquote>\n  <p>Пространства имён объявляются с помощью XML атрибута <code>xmlns</code>, значением которого должен быть <em>URI</em> и префикса, однозначно идентифицирующего пространство имён каждого элемента.</p>\n</blockquote>\n<p>Все имена элементов в пределах пространства имён должны быть уникальны.</p>\n<p>В общем случае пространство имён XML не требует, чтобы был определён его словарь.</p>\n<p>XML-документ может содержать имена элементов и атрибутов из нескольких словарей XML. В каждом словаре задано своё пространство имён — так разрешается проблема неоднозначности имён элементов и атрибутов.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-xsd-в-чём-его-преимущества-перед-xml-dtd","title":"<p>Что такое XSD? В чём его преимущества перед XML DTD?</p>","answer":"<p><strong>XSD, XML Schema Definition, XML Schema (XML схема)</strong> — язык описания структуры XML-документа. В частности, XML Schema описывает:</p>\n<ul>\n<li><em>словарь</em> - имена элементов и атрибутов;</li>\n<li><em>модель содержания</em> - взаимосвязи между элементами и атрибутами, а также их</li>\n<li><em>структуру</em> документа;</li>\n<li>используемые <em>типы данных</em>.</li>\n</ul>\n<p><strong>Преимущества XSD перед DTD</strong> заключаются в следующем:</p>\n<ul>\n<li><p>DTD, в отличие от XSD, не является XML и имеет свой собственный синтаксис. В связи с этим могут возникать разнообразные проблемы с кодировкой и верификацией XML-документов.</p></li>\n<li><p>При использовании XSD XML-парсер может проверить не только правильность синтаксиса XML документа, но также его структуру, модель содержания и типы данных. В XML DTD существует лишь один тип данных – строка и если, например, в числовом поле будет текст, то документ всё же сможет пройти верификацию, так как XML DTD не сможет проверить тип данных.</p></li>\n<li><p>Нельзя поставить в соответствие одному XML документу больше одного DTD. А следовательно и верифицировать документ можно лишь одним DTD описанием. XSD расширяем, и позволяет подключать несколько словарей для описания типовых задач.</p></li>\n<li><p>XSD обладает встроенными средствами документирования, позволяющими создавать самодостаточные документы, не требующие дополнительного описания.</p></li>\n</ul>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#какие-типы-существуют-в-xsd","title":"<p>Какие типы существуют в XSD?</p>","answer":"<p><strong>Простой тип</strong> - это определение типа для значения, которое может использоваться в качестве содержимого элемента или атрибута. Этот тип данных не может содержать элементы или иметь атрибуты.</p>\n<pre><code class=\"xsd language-xsd\">&lt;xsd:element name='price' type='xsd:decimal'/&gt;\n...\n&lt;price&gt;45.50&lt;/price&gt;\n</code></pre>\n<p><strong>Сложный тип</strong> - это определение типа для элементов, которые могут содержать атрибуты и другие элементы.</p>\n<pre><code class=\"xsd language-xsd\">&lt;xsd:element name='price'&gt;\n    &lt;xsd:complexType base='xsd:decimal'&gt;\n        &lt;xsd:attribute name='currency' type='xsd:string'/&gt;\n    &lt;/xsd:complexType&gt;\n&lt;/xsd:element&gt;\n...\n&lt;price currency='US'&gt;45.50&lt;/price&gt;\n</code></pre>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#какие-вы-знаете-методы-чтения-xml-опишите-сильные-и-слабые-стороны-каждого-метода","title":"<p>Какие вы знаете методы чтения XML? Опишите сильные и слабые стороны каждого метода</p>","answer":"<p><strong>DOM (Document Object Model)</strong> - <em>объектный</em> - считывает XML, воссоздавая его в памяти в виде объектной структуры при\nэтом XML документ представляется в виде набора тегов – узлов. Каждый узел может иметь неограниченное количество дочерних\nузлов. Каждый дочерний тоже может содержать несколько уровней потомков или не содержать их вовсе. Таким образом в итоге\nполучается некое дерево.</p>\n<blockquote>\n  <p>➖ Низкая скорость работы.</p>\n  <p>➖ Расходует много памяти.</p>\n  <p>➕ Прост в программировании.</p>\n  <p>➕ Если в XML много объектов с перекрёстными ссылками друг на друга, достаточно дважды пройтись по документу: первый\n  раз создать объекты без ссылок и заполнить словарь «название-объект», второй раз — восстановить ссылки.</p>\n  <p>➕ При ошибке в XML в памяти остаётся созданная на половину структура XML, которая будет автоматически уничтожена.</p>\n  <p>➕ Пригоден как для чтения так и для записи.</p>\n</blockquote>\n<p><strong>SAX (Simple API for XML)</strong> <em>событийный</em> - читает XML документ, реагируя на появляющиеся события (открывающий или закрывающий тег, строку, атрибут) вызовом предоставляемых приложением обработчиков событий. При этом, в отличие от DOM, не сохраняет документ в памяти.</p>\n<blockquote>\n  <p>➕ Высокая скорость работы</p>\n  <p>➕ Расходует мало памяти.</p>\n  <p>➗ Довольно сложен в программировании.</p>\n  <p>➖ Если в XML много объектов с перекрёстными ссылками друг на друга, надо организовать временное хранение строковых ссылок, чтобы потом, когда документ будет считан, преобразовать в указатели.</p>\n  <p>➖ При ошибке в XML в памяти остаётся структура, созданная на половину, предметной отрасли; программист должен своими руками корректно уничтожить её.</p>\n  <p>➖ Пригоден только для чтения.</p>\n</blockquote>\n<p><strong>StAX (Stream API for XML)</strong> <em>потоковый</em> - состоящий из двух наборов API для обработки XML, которые обеспечивают разные уровни абстракции. API с использованием курсора позволяет приложениям работать с XML как с потоком лексем (или событий); приложение может проверить статус анализатора и получить информацию о последней проанализированной лексеме, а затем перейти к следующей. Второй, высокоуровневый API, использующий итераторы событий, позволяет приложению обрабатывать XML как серию объектов событий, каждый из которых взаимодействует с фрагментом XML-структуры приложения. Всё, что требуется от приложения - это определить тип синтаксически разобранного события, отнести его к соответствующему конкретному типу и использовать соответствующие методы для получения информации, относящейся к событию.</p>\n<blockquote>\n  <p>➗ Сохраняет преимущества, которые есть в SAX по сравнению с DOM.</p>\n  <p>➕ Не основан на обратных вызовах обработчиков, приложению не придется обслуживать эмулированное состояние анализатора, как это происходит при использовании SAX.</p>\n  <p>➖ Пригоден только для чтения.</p>\n</blockquote>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#когда-следует-использовать-dom-а-когда-sax-stax-анализаторы","title":"<p>Когда следует использовать <em>DOM</em>, а когда <em>SAX</em>, <em>StAX</em> анализаторы?</p>","answer":"<p>DOM - естественный выбор, когда объектом предметной области является сам XML: когда нужно знать и иметь возможность изменять структуру документа, а также в случае многократного использования информации из документа.</p>\n<p>Для быстрого одноразового чтения оптимальным является использование SAX или StAX.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#какие-вы-знаете-способы-записи-xml","title":"<p>Какие вы знаете способы записи XML?</p>","answer":"<p><strong>Прямая запись</strong> - пишет XML тег за тегом, атрибут за атрибутом.</p>\n<blockquote>\n  <p>➕ Высокая скорость работы.</p>\n  <p>➕ Экономия памяти: при использовании не создаётся промежуточных объектов.</p>\n  <p>➖ Пригоден только для записи.</p>\n</blockquote>\n<p><strong>Запись DOM (Document Object Model)</strong> - создаёт полную структуру XML и только потом записывает её.</p>\n<blockquote>\n  <p>➖ Низкая скорость работы.</p>\n  <p>➖ Не оптимальный расход памяти.</p>\n  <p>➕ Пригоден как для записи так и для чтения.</p>\n</blockquote>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-jaxp","title":"<p>Что такое <em>JAXP</em>?</p>","answer":"<p><strong>JAXP, The Java API for XML Processing (Java API для обработки XML)</strong> — набор API, упрощающих обработку XML данных в программах написанных на Java. Содержит реализации  DOM, SAX и StAX парсеров, поддерживает XSLT и возможность работать с DTD.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-xslt","title":"<p>Что такое <em>XSLT</em>?</p>","answer":"<p><strong>XSLT, eXtensible Stylesheet Language Transformations</strong> — язык преобразования XML-документов.</p>\n<p>XSLT создавался для применения в <em>XSL (eXtensible Stylesheet Language)</em> - языке стилей для XML. Во время XSL-преобразования XSLT-процессор считывает XML-документ и таблицу(ы) стилей XSLT. На основе инструкций, которые процессор находит в таблице(ах) стилей XSLT, он вырабатывает новый XML-документ или его фрагмент.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-json","title":"<p>Что такое <em>JSON</em>?</p>","answer":"<p><strong>JSON, JavaScript Object Notation</strong> — текстовый формат обмена данными, основанный на JavaScript.</p>\n<p>JSON представляет собой (в закодированном виде) одну из двух структур:</p>\n<ul>\n<li><em>Набор пар «ключ:значение»</em>;</li>\n<li><em>Упорядоченный набор значений</em>.</li>\n</ul>\n<p>Ключом может быть только строка (регистрозависимая: имена с буквами в разных регистрах считаются разными).</p>\n<p>В качестве значений могут быть использованы:</p>\n<ul>\n<li><em>Объект</em> — неупорядоченное множество пар «ключ:значение», заключённое в фигурные скобки <code>{ }</code>. Ключ описывается строкой, между ним и значением стоит символ <code>:</code>. Пары ключ-значение отделяются друг от друга запятыми;</li>\n<li><em>Массив (одномерный)</em> — упорядоченное множество значений. Массив заключается в квадратные скобки <code>[ ]</code>. Значения разделяются запятыми.</li>\n<li><em>Число</em>;</li>\n<li><em>Литералы</em> <code>true</code>, <code>false</code> и <code>null</code>;</li>\n<li><em>Строка</em> — упорядоченное множество из нуля или более символов Unicode, заключенное в кавычки <code>\" \"</code>. Символы могут быть указаны с использованием escape-последовательностей, начинающихся с обратной косой черты <code>\\</code>, или записаны шестнадцатеричным кодом в кодировке UTF-8 в виде <code>\\uFFFF</code>.</li>\n</ul>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-json-схема","title":"<p>Что такое <em>JSON схема</em>?</p>","answer":"<p><strong>JSON Schema</strong> — один из языков описания структуры JSON-документа, используя синтаксис JSON.</p>\n<p>Это самоописательный язык: при его использовании для обработки данных и описания их допустимости могут использоваться одни и те же инструменты сериализации/десериализации.</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#сравните-json-и-xml","title":"<p>Сравните <em>JSON</em> и <em>XML</em></p>","answer":"<p>…</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#что-такое-yaml","title":"<p>Что такое <em>YAML</em>?</p>","answer":"<p>…</p>"},{"subject":"Языки разметки: XML, JSON, YAML","url":"061-ml.html#сравните-json-и-yaml","title":"<p>Сравните <em>JSON</em> и <em>YAML</em>?</p>","answer":"<p>…</p>\n<p><a href=\"#Языки-разметки-XML-JSON-YAML\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/XML\">Википедия</a></li>\n<li><a href=\"http://citforum.ru/internet/xnamsps/index.shtml#ns-decl\">CIT Forum</a></li>\n<li><a href=\"http://www.quizful.net/interview/java/xml-and-parsers\">Quizful</a></li>\n</ul>"},{"subject":"Основы HTML","url":"062-html.html#что-такое-html","title":"<p>Что такое <em>«HTML»</em>?</p>","answer":"<p><strong>HTML</strong>, HyperText Markup Language («язык гипертекстовой разметки») — стандартизированный язык разметки документов\nв <WWW>. На данный момент актуальна 5 версия этого языка - HTML5.</p>"},{"subject":"Основы HTML","url":"062-html.html#что-такое-xhtml","title":"<p>Что такое <em>«XHTML»</em>?</p>","answer":"<p><strong>XHTML</strong>, eXtensible HyperText Markup Language («расширяемый язык гипертекстовой разметки») - более строгий вариант\nHTML, следующий всем ограничениям XML и, фактически являющийся приложением языка XML к области разметки гипертекста.</p>"},{"subject":"Основы HTML","url":"062-html.html#что-такое-doctype-и-зачем-он-нужен","title":"<p>Что такое <code>DOCTYPE</code> и зачем он нужен?</p>","answer":"<p>Элемент <code>&lt;!DOCTYPE&gt;</code> предназначен для указания типа текущего документа. Это необходимо, чтобы браузер понимал согласно какого стандарта необходимо интерпретировать данную web-страницу.</p>\n<p>Существует несколько видов <code>&lt;!DOCTYPE&gt;</code>, различающихся версией языка, на который они ориентированы:</p>\n<p><strong>HTML 4.01</strong></p>\n<ul>\n<li><p><code>&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\"&gt;</code>: строгий синтаксис HTML;</p></li>\n<li><p><code>&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\n\"http://www.w3.org/TR/html4/loose.dtd\"&gt;</code>: переходный синтаксис HTML;</p></li>\n<li><p><code>&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\"\n\"http://www.w3.org/TR/html4/frameset.dtd\"&gt;</code>: HTML с фреймами.</p></li>\n</ul>\n<p><strong>HTML 5</strong></p>\n<ul>\n<li><code>&lt;!DOCTYPE html&gt;</code>: для всех документов.</li>\n</ul>\n<p><strong>XHTML 1.0</strong></p>\n<ul>\n<li><p><code>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;</code>: строгий синтаксис XHTML;</p></li>\n<li><p><code>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;</code>: переходный синтаксис XHTML;</p></li>\n<li><p><code>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\"\n\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\"&gt;</code>: XHTML с фреймами.</p></li>\n</ul>\n<p><strong>XHTML 1.1</strong></p>\n<ul>\n<li><code>&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\"\n\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"&gt;</code>: для всех документов.</li>\n</ul>"},{"subject":"Основы HTML","url":"062-html.html#для-чего-предназначен-тег-head","title":"<p>Для чего предназначен тег <code>&lt;head&gt;</code>?</p>","answer":"<p>Тег <code>&lt;head&gt;</code> предназначен для хранения других элементов, цель которых — помочь браузеру в работе с данными. Также внутри этого контейнера находятся <em>метатеги</em>, которые используются для хранения информации предназначенной для браузеров и поисковых систем. Например, механизмы поисковых систем обращаются к метатегам для получения описания сайта, ключевых слов и других данных.</p>\n<p>Содержимое тега <code>&lt;head&gt;</code> не отображается напрямую на web-странице, за исключением тега <code>&lt;title&gt;</code> устанавливающего заголовок окна.</p>\n<p>Внутри контейнера <code>&lt;head&gt;</code> допускается размещать следующие элементы: <code>&lt;base&gt;</code>, <code>&lt;basefont&gt;</code>, <code>&lt;bgsound&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;meta&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, <code>&lt;title&gt;</code>.</p>\n<p>Синтаксис:</p>\n<pre><code class=\"html language-html\">&lt;head&gt;\n  ...\n&lt;/head&gt;\n</code></pre>\n<p>Специфические атрибуты:</p>\n<ul>\n<li><code>profile</code>: указывает адрес профиля метаданных.</li>\n</ul>"},{"subject":"Основы HTML","url":"062-html.html#чем-отличается-div-от-span","title":"<p>Чем отличается <code>&lt;div&gt;</code> от <code>&lt;span&gt;</code>?</p>","answer":"<p><code>&lt;div&gt;</code> - блочный, а <code>&lt;span&gt;</code> - строчный элементы. Поэтому <code>&lt;div&gt;</code> формирует блок из того, что в нем располагается с новой строки, а <code>&lt;span&gt;</code> не переносит элементы, размещая их в строку. Так же стоит отметить, что согласно рекомендациям w3c линейный тег не может включать в себя блочные теги, поэтому <code>&lt;div&gt;</code> обычно используется для разметки блоков, а <code>&lt;span&gt;</code> - отрывков текста.</p>"},{"subject":"Основы HTML","url":"062-html.html#как-обозначаются-комментарии-в-html","title":"<p>Как обозначаются комментарии в HTML?</p>","answer":"<p>Комментарий в HTML-коде задаётся так: <code>&lt;!-- комментарий --&gt;</code></p>\n<p>Комментарии можно использовать в любом месте страницы, кроме тега <code>&lt;title&gt;</code> — внутри него они не работают. Внутри тега <code>&lt;style&gt;</code> HTML-комментарии тоже не работают, так как в CSS код комментируется другим способом.</p>"},{"subject":"Основы HTML","url":"062-html.html#каким-образом-задаётся-адрес-документа-на-который-следует-перейти","title":"<p>Каким образом задаётся адрес документа, на который следует перейти?</p>","answer":"<p>Для создания ссылок на другие документы используется тег <code>&lt;a&gt;</code>. В зависимости от присутствия атрибутов <code>name</code> или <code>href</code> тег <code>&lt;a&gt;</code> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри web-страницы.</p>\n<p>Синтаксис:</p>\n<ul>\n<li><code>&lt;a href=\"URL\"&gt;...&lt;/a&gt;</code></li>\n<li><code>&lt;a name=\"идентификатор\"&gt;...&lt;/a&gt;</code></li>\n</ul>\n<p>Специфические атрибуты:</p>\n<ul>\n<li><code>accesskey</code>: активация ссылки с помощью комбинации клавиш;</li>\n<li><code>coords</code>: устанавливает координаты активной области;</li>\n<li><code>download</code>: предлагает скачать указанный по ссылке файл;</li>\n<li><code>href</code>: задает адрес документа, на который следует перейти. Адрес ссылки может быть абсолютным и относительным. Абсолютные адреса работают везде и всюду независимо от имени сайта или веб-страницы, где прописана ссылка. Относительные ссылки, как следует из их названия, построены относительно текущего документа или корня сайта;</li>\n<li><code>hreflang</code>: идентифицирует язык текста по ссылке;</li>\n<li><code>name</code>: устанавливает имя якоря внутри документа;</li>\n<li><code>rel</code>: отношения между ссылаемым и текущим документами;</li>\n<li><code>rev</code>: отношения между текущим и ссылаемым документами;</li>\n<li><code>shape</code>: задает форму активной области ссылки для изображений;</li>\n<li><code>tabindex</code>: определяет последовательность перехода между ссылками при нажатии на кнопку <kbd>Tab</kbd>;</li>\n<li><code>target</code>: имя окна или фрейма, куда браузер будет загружать документ;</li>\n<li><code>title</code>: добавляет всплывающую подсказку к тексту ссылки;</li>\n<li><code>type</code>: указывает MIME-тип документа, на который ведёт ссылка.</li>\n</ul>"},{"subject":"Основы HTML","url":"062-html.html#как-сделать-ссылку-на-адрес-электронной-почты","title":"<p>Как сделать ссылку на адрес электронной почты?</p>","answer":"<p>Создание ссылки на адрес электронной почты делается почти также, как и ссылка на web-страницу. Только вместо URL указывается <code>mailto:\"адрес электронной почты\"</code></p>\n<pre><code class=\"html language-html\">&lt;a href=\"mailto:user@address.net\"&gt;Напиши мне!&lt;/a&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#для-чего-предназначен-тег-em","title":"<p>Для чего предназначен тег <code>&lt;em&gt;</code>?</p>","answer":"<p>Тег <code>&lt;em&gt;</code> предназначен для акцентирования текста. Браузеры отображают такой текст курсивным начертанием.</p>\n<pre><code class=\"html language-html\">&lt;em&gt;Текст&lt;/em&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#для-чего-предназначены-теги-ol-ul-li","title":"<p>Для чего предназначены теги <code>&lt;ol&gt;</code>, <code>&lt;ul&gt;</code>, <code>&lt;li&gt;</code>?</p>","answer":"<p>Теги <code>&lt;ol&gt;</code>, <code>&lt;ul&gt;</code> и <code>&lt;li&gt;</code> предназначены для оформления списков.</p>\n<ul>\n<li><code>&lt;ol&gt;</code>: нумерованный список, т.е. каждый элемент списка начинается с числа или буквы и увеличивается по нарастающей.</li>\n<li><code>&lt;ul&gt;</code>: маркированный список, каждый элемент которого начинается с небольшого символа — маркера.</li>\n<li><code>&lt;li&gt;</code>: отдельный элемент списка. Внешний тег <code>&lt;ul&gt;</code> или <code>&lt;ol&gt;</code> устанавливает тип списка — маркированный или нумерованный.</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;ol&gt;Нумерованный список\n    &lt;li&gt;первый&lt;/li&gt;\n    &lt;li&gt;второй&lt;/li&gt;\n    &lt;li&gt;третий&lt;/li&gt;\n&lt;/ol&gt;\n\n&lt;ul&gt;Маркированный список\n    &lt;li&gt;первый&lt;/li&gt;\n    &lt;li&gt;второй&lt;/li&gt;\n    &lt;li&gt;третий&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#для-чего-предназначены-теги-dl-dt-dd","title":"<p>Для чего предназначены теги <code>&lt;dl&gt;</code>, <code>&lt;dt&gt;</code>, <code>&lt;dd&gt;</code>?</p>","answer":"<p>Теги <code>&lt;dl&gt;</code>, <code>&lt;dt&gt;</code>, <code>&lt;dd&gt;</code> предназначены для создания списка определений.</p>\n<p>Каждый такой список начинается с контейнера <code>&lt;dl&gt;</code>, куда входит тег <code>&lt;dt&gt;</code> создающий термин и тег <code>&lt;dd&gt;</code> задающий определение этого термина. Закрывающий тег <code>&lt;/dd&gt;</code> не обязателен, поскольку следующий тег сообщает о завершении предыдущего элемента. Тем не менее, хорошим стилем является закрывать все теги.</p>\n<pre><code class=\"html language-html\">&lt;dl&gt;Список определений\n    &lt;dt&gt;Термин&lt;/dt&gt;\n    &lt;dd&gt;Определение&lt;/dd&gt;\n&lt;/dl&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#для-чего-предназначены-теги-tr-th-td","title":"<p>Для чего предназначены теги <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, <code>&lt;td&gt;</code>?</p>","answer":"<p><code>&lt;tr&gt;</code>: служит контейнером для создания строки таблицы. Каждая ячейка в пределах такой строки может задаваться с помощью тега <code>&lt;th&gt;</code> или <code>&lt;td&gt;</code>.\n<code>&lt;th&gt;</code>: предназначен для создания одной ячейки заголовка таблицы.\n<code>&lt;td&gt;</code>: предназначен для создания одной ячейки таблицы.</p>\n<pre><code class=\"html language-html\">&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th&gt;Заголовок&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;Строка&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#обязательно-ли-писать-атрибут-alt-в-теге-img","title":"<p>Обязательно ли писать атрибут <code>alt</code> в теге <code>&lt;img&gt;</code>?</p>","answer":"<p>Да, писать его обязательно.</p>\n<p>Атрибут <code>alt</code> устанавливает альтернативный текст для изображений. Такой текст позволяет получить текстовую информацию о рисунке при отключенной в браузере загрузке изображений. Поскольку загрузка изображений происходит после получения браузером информации о нем, то замещающий рисунок текст появляется раньше. А уже по мере загрузки текст будет сменяться изображением.</p>\n<pre><code class=\"html language-html\">&lt;img src=\"forest.jpg\" alt=\"Лес\"&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#в-каком-регистре-лучше-писать-html-код","title":"<p>В каком регистре лучше писать HTML-код?</p>","answer":"<p>Весь HTML-код рекомендуется писать в нижнем регистре: это относится к названиям элементов, названиям атрибутов, значениям атрибутов (кроме текста/<code>CDATA</code>), селекторам, свойствам и их значениям (кроме текста).</p>\n<p>Не рекомендуется</p>\n<pre><code class=\"html language-html\">&lt;A HREF=\"/\"&gt;Домой&lt;/A&gt;\n</code></pre>\n<p>Рекомендуется</p>\n<pre><code class=\"html language-html\">&lt;img src=\"forest.jpg\" alt=\"Лес\"&gt;\n</code></pre>"},{"subject":"Основы HTML","url":"062-html.html#что-такое-мнемоника-entity","title":"<p>Что такое «мнемоника (entity)»?</p>","answer":"<p><strong>Мнемоника (entity)</strong> - это конструкция из символа <code>&amp;</code> и буквенного (или цифрового кода) после нее, предназначенная для замещения символов, которые запрещены для использования в HTML в «явном виде».</p>\n<blockquote>\n  <p>&num; имеет мнемонику <code>&amp;num;</code></p>\n</blockquote>\n<p><a href=\"#Основы-html\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"http://htmlbook.ru/html/\">htmlbook</a></li>\n<li><a href=\"https://habrahabr.ru/post/143452/\">Хабрахабр</a></li>\n</ul>"},{"subject":"Основы CSS","url":"063-css.html#что-такое-css","title":"<p>Что такое <em>«CSS»</em>?</p>","answer":"<p><strong>CSS, Cascading Style Sheets (каскадные таблицы стилей)</strong> - формальный язык описания внешнего вида документа, написанного с использованием языка разметки, который применяется к элементам web-страницы для управления их видом и положением.</p>\n<p>Основной целью разработки CSS являлось разделение описания логической структуры web-страницы, которое производится с помощью HTML или других языков разметки от описания внешнего вида этой web-страницы, которое производится с помощью CSS.</p>"},{"subject":"Основы CSS","url":"063-css.html#как-в-css-обозначаются-комментарии","title":"<p>Как в CSS обозначаются комментарии?</p>","answer":"<p>Чтобы пометить, что текст является комментарием, применяют конструкцию <code>/* ... */</code></p>"},{"subject":"Основы CSS","url":"063-css.html#что-такое-селектор","title":"<p>Что такое <em>«селектор»</em>?</p>","answer":"<p><strong>Селектор</strong> – это правило, на основании которого осуществляется выбор элементов в HTML документе для того, чтобы применить к ним определённые стили.</p>\n<pre><code class=\"css language-css\">p {\ntext-align: center;\nfont-size: 20px;\n}\n/* p – это селектор, text-align и font-size – это свойства, а center и 20px – значения. */\n</code></pre>"},{"subject":"Основы CSS","url":"063-css.html#перечислите-основные-виды-селекторов","title":"<p>Перечислите основные виды селекторов</p>","answer":"<ul>\n<li><strong>селектор <code>*</code></strong> - выбор всех элементов;</li>\n<li><strong>селектор элемента</strong> - выбор всех элементов в HTML документе, имеющих указанный тег (например: <code>div</code>);</li>\n<li><strong>селектор класса</strong> - выбор всех элементов в HTML документе, имеющих указанный класс (например: <code>.center</code>);</li>\n<li><strong>селектор идентификатора</strong> - выбор элемента в HTML документе, имеющего указанный идентификатор (например: <code>#footer</code>);</li>\n<li><strong>селекторы псевдоклассов</strong> - выбор всех элементов в HTML документе, имеющих указанный псевдокласс (например: <code>p:first-of-type</code>);</li>\n<li><strong>селекторы атрибутов</strong> - выбор элементов в зависимости от указанного атрибута элемента или его значения (например: <code>[href*=\"youtube\"]</code>).</li>\n</ul>"},{"subject":"Основы CSS","url":"063-css.html#что-такое-псевдокласс","title":"<p>Что такое псевдокласс?</p>","answer":"<p>Псевдокласс определяет динамическое состояние элементов, которое изменяется из-за действий пользователя, или же соответствует текущему положению в дереве документа. В отличие от настоящего класса, в явном виде псевдокласс в HTML не указывается, а в CSS указывается через <code>:</code> непосредственно после селектора.</p>\n<p>Наиболее известные псевдоклассы:</p>\n<ul>\n<li><code>:link</code> применяется к ссылкам, которые еще не посещались пользователем;</li>\n<li><code>:visited</code> применяется к посещенным ссылкам;</li>\n<li><code>:hover</code> применяется, когда курсор мыши находится в пределах элемента, но не активирует его;</li>\n<li><code>:active</code> применяется при активации элемента;</li>\n<li><code>:focus</code> применяется к элементу при получении им фокуса;</li>\n<li><code>:first-child</code> применяется к первому дочернему элементу селектора, который расположен в дереве элементов документа.</li>\n</ul>\n<pre><code class=\"css language-css\">a.snowman:link {\n    color: blue;\n}\na.snowman:visited {\n    color: purple;\n}\na.snowman:active {\n    color: red;\n}\na.snowman:hover {\n    text-decoration: none;\n    color: blue;\n    background-color: yellow;\n}\n</code></pre>"},{"subject":"Основы CSS","url":"063-css.html#какие-существуют-селекторы-атрибутов","title":"<p>Какие существуют селекторы атрибутов?</p>","answer":"<ul>\n<li><strong><code>[атрибут]</code></strong> - все элементы, имеющие указанный <code>атрибут</code>;</li>\n<li><strong><code>[атрибут=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого равно <code>\"значение\"</code>;</li>\n<li><strong><code>[атрибут^=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого начинается с <code>значение</code>;</li>\n<li><strong><code>[атрибут|=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого равно <code>значение</code> или начинается с <code>значение</code> следующим образом <code>значение-*</code> (<code>значение</code> с обязательным дефисом, после которого идёт остальное содержимое значения);</li>\n<li><strong><code>[атрибут$=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого заканчивается на <code>значение</code>;</li>\n<li><strong><code>[атрибут*=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого содержит подстроку <code>значение</code>;</li>\n<li><strong><code>[атрибут~=значение]</code></strong> - все элементы, имеющие <code>атрибут</code>, значение которого содержит <code>значение</code> как одно из значений через пробел.</li>\n</ul>"},{"subject":"Основы CSS","url":"063-css.html#в-чем-разница-между-my-и-my","title":"<p>В чем разница между <code>#my</code> и <code>.my</code>?</p>","answer":"<p><code>#my</code> — селектор идентификатора, а <code>.my</code> — селектор класса.</p>"},{"subject":"Основы CSS","url":"063-css.html#в-чем-разница-между-margin-и-padding","title":"<p>В чем разница между <code>margin</code> и <code>padding</code>?</p>","answer":"<p><code>margin</code> — внешний отступ, а <code>padding</code> — внутренний отступ.</p>"},{"subject":"Основы CSS","url":"063-css.html#в-чем-заключается-разница-между-значениями-0-и-auto-в-свойстве-margin","title":"<p>В чем заключается разница между значениями <code>0</code> и <code>auto</code> в свойстве <code>margin</code>?</p>","answer":"<p>В вертикальных полях — <code>auto</code> всегда означает <code>0</code>. В горизонтальных полях — <code>auto</code> означает <code>0</code> только тогда, когда свойство <code>width</code> также <code>auto</code>.</p>"},{"subject":"Основы CSS","url":"063-css.html#какое-свойство-задает-цвет-фона","title":"<p>Какое свойство задает цвет фона?</p>","answer":"<p>Цвет фона задает свойство <code>background-color</code>.</p>"},{"subject":"Основы CSS","url":"063-css.html#как-убрать-подчеркивание-для-всех-ссылок-на-странице","title":"<p>Как убрать подчеркивание для всех ссылок на странице?</p>","answer":"<pre><code class=\"css language-css\">a {\n    text-decoration: none;\n}\n</code></pre>"},{"subject":"Основы CSS","url":"063-css.html#для-чего-используется-свойство-clear","title":"<p>Для чего используется свойство <code>clear</code>?</p>","answer":"<p><code>clear</code> устанавливает, с какой стороны элемента запрещено его обтекание другими элементами.</p>"},{"subject":"Основы CSS","url":"063-css.html#как-сделать-жирным-текст-во-всех-элементах-p","title":"<p>Как сделать жирным текст во всех элементах <code>&lt;p&gt;</code>?</p>","answer":"<pre><code class=\"css language-css\">p {\n    font-weight: bold;\n}\n</code></pre>"},{"subject":"Основы CSS","url":"063-css.html#как-задать-красный-цвет-для-всех-элементов-имеющих-класс-red","title":"<p>Как задать красный цвет для всех элементов, имеющих класс <code>red</code>?</p>","answer":"<pre><code class=\"css language-css\">.red {\n    color: red;\n}\n</code></pre>"},{"subject":"Основы CSS","url":"063-css.html#что-такое-sass-и-scss","title":"<p>Что такое Sass и SCSS?</p>","answer":"<p><strong>Sass</strong> — это метаязык на основе CSS, предназначенный для увеличения уровня абстракции CSS кода и упрощения файлов каскадных таблиц стилей.</p>\n<p>Язык Sass имеет два синтаксиса:</p>\n<ul>\n<li><em>sass</em> — отличается отсутствием фигурных скобок, в нём вложенные элементы реализованы с помощью отступов;</li>\n<li><em>SCSS (Sassy CSS)</em> — использует фигурные скобки, как и сам CSS.</li>\n</ul>\n<p><a href=\"#Основы-css\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"http://myway-blog.ru/interview-frontend-web-programmer/\">myway-blog.ru</a></li>\n<li><a href=\"http://stepbystep.htmlbook.ru/?id=43\">htmlbook.ru</a></li>\n<li><a href=\"https://itchief.ru/lessons/html-and-css/css-selectors\">itchief.ru</a></li>\n</ul>"},{"subject":"Основы Javascript","url":"064-javascript.html#что-такое-javascript","title":"<p>Что такое Javascript?</p>","answer":"<p><strong>JavaScript (JS, \"джаваскрипт\")</strong> — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный,\nимперативный и функциональный стили. Является реализацией языка ECMAScript.JavaScript обычно используется как\nвстраиваемый язык для программного доступа к объектам приложений. Наиболее широкое применение находит в браузерах как\nязык сценариев для придания интерактивности веб-страницам. Основные архитектурные черты: динамическая типизация, слабая\nтипизация, автоматическое управление памятью, прототипное программирование, функции как объекты первого класса.</p>"},{"subject":"Основы Javascript","url":"064-javascript.html#что-такое-ajax-как-принципиально-устроена-эта-технология","title":"<p>Что такое <em>AJAX</em>? Как принципиально устроена эта технология?</p>","answer":"<p><strong>AJAX, Asynchronous Javascript and XML (Асинхронный Javascript и XML)</strong> — подход к построению интерактивных\nпользовательских интерфейсов web-приложений, заключающийся в «фоновом» обмене данными браузера и web-сервера. В\nрезультате при обновлении данных web-страница не перезагружается полностью и web-приложения становятся быстрее и\nудобнее.</p>\n<p>При использовании AJAX:</p>\n<ol>\n<li>Пользователь заходит на web-страницу и взаимодействует с каким-нибудь её элементом.</li>\n<li>Скрипт на языке JavaScript определяет, какая информация необходима для обновления страницы.</li>\n<li>Браузер отправляет соответствующий запрос на web-сервер.</li>\n<li>Web-сервер возвращает только ту часть документа, на которую пришёл запрос.</li>\n<li>Скрипт вносит изменения с учётом полученной информации (без полной перезагрузки страницы).</li>\n</ol>\n<p>AJAX базируется на двух основных принципах:</p>\n<ol>\n<li>использование технологии динамического обращения к серверу «на лету» (без перезагрузки страницы полностью) через динамическое создание:<ul>\n<li><em>дочерних фреймов</em>;</li>\n<li><em>тега <code>&lt;script&gt;</code></em>;</li>\n<li><em>тега <code>&lt;img&gt;</code></em>.</li></ul></li>\n<li>использование <em>DHTML</em> для динамического изменения содержания страницы;</li>\n</ol>\n<p>AJAX не является самостоятельной технологией, это концепция использования нескольких смежных технологий:</p>\n<ul>\n<li><em>(X)HTML</em>, <em>CSS</em> для подачи и стилизации информации;</li>\n<li><em>DOM-модель</em>, операции над которой производятся Javascript на стороне клиента, для обеспечения динамического отображения и взаимодействия с информацией;</li>\n<li><em>XMLHttpRequest</em> или другой транспорт (<em>IFrame</em>, <em>SCRIPT-тег</em>, <em>…</em>) для асинхронного обмена данными с web-сервером;</li>\n<li><em>JSON</em> или любой другой подходящий формат (<em>форматированный HTML</em>, <em>текст</em>, <em>XML</em>, <em>…</em>) для обмена данными.</li>\n</ul>\n<p><a href=\"#Основы-Javascript\">к оглавлению</a></p>\n<h1 id=\"\">Источники</h1>\n<ul>\n<li><a href=\"https://ru.wikipedia.org/wiki/JavaScript\">Википедия</a></li>\n</ul>"}];