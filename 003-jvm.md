[Вопросы для собеседования](README.md)

# Java Virtual Machine
+ [Что такое Java?](#что-такое-java)
+ [Почему стоить использовать Java?](#почему-стоить-использовать-java)
+ [Какие основные отличия в версиях Java?](#какие-основные-отличия-в-версиях-java)
+ [Чем различаются JRE, JVM и JDK?](#чем-различаются-jre-jvm-и-jdk)
+ [За что отвечает _JVM_?](#за-что-отвечает-jvm)
+ [Расскажите про Classloader](#расскажите-про-classloader)
+ [Расскажите о Run-Time Data Area](#расскажите-о-run-time-data-area)
+ [Как рассчитать объем, который занимают объекты в памяти?](#как-рассчитать-объем-который-занимают-объекты-в-памяти)
+ [Расскажите о Frames](#расскажите-о-frames)
+ [Что такое Execution Engine?](#что-такое-execution-engine)
+ [Для чего нужен сборщик мусора?](#для-чего-нужен-сборщик-мусора)
+ [Как работает сборщик мусора?](#как-работает-сборщик-мусора)
+ [Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?](#какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot)
+ [Опишите алгоритм работы какого-нибудь сборщика мусора реализованного в виртуальной машине HotSpot](#опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot)
+ [Что такое Safepoints (применительно к HotSpot JVM)?](#что-такое-safepoints-применительно-к-hotspot-jvm)
+ [Что такое HeapDump и TreadDump?](#что-такое-heapdump-и-treaddump)
+ [Что такое профилирование?](#что-такое-профилирование)
+ [Как обнаружить причину утечки памяти (memory leak)?](#как-обнаружить-причину-утечки-памяти-memory-leak)
+ [Какие существуют рекомендации к стилю кода на Java?](#какие-существуют-рекомендации-к-стилю-кода-на-java)
+ [Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?](#какие-языки-кроме-java-могут-быть-использованы-в-разработке-по-исполняемого-в-среде-jvm)

+ [Что такое Java?](#что-такое-java)
+ [Почему стоить использовать Java?](#почему-стоить-использовать-java)
+ [Какие основные отличия в версиях Java?](#какие-основные-отличия-в-версиях-java)
+ [Чем различаются JRE, JVM и JDK?](#чем-различаются-jre-jvm-и-jdk)
+ [За что отвечает _JVM_?](#за-что-отвечает-jvm)
+ [Расскажите про Classloader](#расскажите-про-classloader)
+ [Расскажите о Run-Time Data Area](#расскажите-о-run-time-data-area)
+ [Как рассчитать объем, который занимают объекты в памяти?](#как-рассчитать-объем-который-занимают-объекты-в-памяти)
+ [Расскажите о Frames](#расскажите-о-frames)
+ [Что такое Execution Engine?](#что-такое-execution-engine)
+ [Для чего нужен сборщик мусора?](#для-чего-нужен-сборщик-мусора)
+ [Как работает сборщик мусора?](#как-работает-сборщик-мусора)
+ [Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?](#какие-разновидности-сборщиков-мусора-реализованы-в-виртуальной-машине-hotspot)
+ [Опишите алгоритм работы какого-нибудь сборщика мусора реализованного в виртуальной машине HotSpot.](#опишите-алгоритм-работы-какого-нибудь-сборщика-мусора-реализованного-в-виртуальной-машине-hotspot)
+ [Что такое Safepoints (применительно к HotSpot JVM)?](#что-такое-safepoints-применительно-к-hotspot-jvm)
+ [Что такое HeapDump и TreadDump?](#что-такое-heapdump-и-treaddump)
+ [Что такое профилирование?](#что-такое-профилирование)
+ [Как обнаружить причину утечки памяти (memory leak)?](#как-обнаружить-причину-утечки-памяти-memory-leak)
+ [Какие существуют рекомендации к стилю кода на Java?](#какие-существуют-рекомендации-к-стилю-кода-на-java)
+ [Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?](#какие-языки-кроме-java-могут-быть-использованы-в-разработке-по-исполняемого-в-среде-jvm)

## Что такое Java?

__Java__ (произноситься как "джава") — строго типизированный объектно-ориентированный язык программирования и одноимённая платформа, разработанные компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process, язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.

Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация JVM (виртуальной Java-машины). Дата официального выпуска — 23 мая 1995 года. На текущий момент один из самых популярных языков программирования и де-факто платформа по умолчанию в разработке ПО уровня предприятия.

Основные области применения: приложения для Android-устройств, веб-сервисы и сайты, промежуточное ПО, микропрограммы для встраиваемых систем.

[к оглавлению](#java-virtual-machine)

## Почему стоить использовать Java?

+ Независимость от аппаратной архитектуры.
+ Автоматическое управление памятью.
+ Расширенные возможности обработки исключительных ситуаций.
+ Богатый набор средств фильтрации ввода-вывода.
+ Набор стандартных коллекций: массив, список, стек и т. п.
+ Наличие простых средств создания сетевых приложений (в том числе с использованием протокола RMI).
+ Наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы.
+ Встроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки (например
  Python).
+ Унифицированный доступ к базам данных:
    + на уровне отдельных SQL-запросов — на основе JDBC, SQLJ;
    + на уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе Java Data Objects (
      англ.) и Java Persistence API.
+ Поддержка обобщений (начиная с версии 1.5).
+ Поддержка лямбд, замыканий, встроенные возможности функционального программирования (с 1.8)
+ Экосистема содержит громадное количество библиотек, реализующих различные протоколы, подходы и API, как открытые так и
  проприетарные.

[к оглавлению](#java-virtual-machine)

## Какие основные отличия в версиях Java?

##### Версия 1.0 - 23 января 1996

##### Версия 1.1 - 19 февраля 1997

+ __Inner Classes__.
+ __Reflection API__.
+ __JavaBeans__.
+ __JDBC__.
+ __Collections framework__.

##### Версия 1.2 - 8 декабря 1998

+ __`strictfp` keyword__.
+ __JDBC__.

##### Версия 1.3 - 8 мая 2000

+ __HotSpot VM included__.

##### Версия 1.4 - 6 февраля 2002

+ __`assert` keyword__.
+ __NIO.2 library__  - API для работы с неблокирующим вводом-выводом.
+ __Logging API__.

##### Версия 5 - 30 сентября 2004 года

+ __Enum__ - перечислимые типы.
+ __Annotations__ - аннотации, специальные интерфейсы.
+ __Generics__ - средства обобщённого программирования.
+ __Varargs__ - методы с неопределённым числом параметров.
+ __Autoboxing/Unboxing__ — автоматическое преобразование между скалярными типами Java и соответствующими
  типами-обёртками.
+ __Static import__ - импорт статических полей и методов.
+ __Foreach__ - итератор по коллекции объектов.
+ __Javadoc comments__ - Javadoc-комментариев.

##### Версия 6 - 11 декабря 2006 года

+ __Scripting Language Support__ - общий API для скриптовых языков и встроенный JS-движок Mozilla Rhino.
+ __JDBC 4.0__.
+ __Java Compiler API__ - возможность программного вызова java-компилятора.
+ __JAXB 2.0__.
+ __PLuggable Annotations__.
+ __@Override__ - использование аннотации для маркирования методов, реализующих интерфейс или расширяющих родительский
  класс.

##### Версия 7 - 7 июля 2011 года

+ __InvokeDynamic__ - поддержка динамических языков программирования.
+ __Strings in switch__. - строки в switch-выражениях.
+ __The try-with-resources statement__ - автоматическое управление ресурсами, реализующими интерфейс
  java.lang.AutoCloseable.
+ __Diamond operator <>__ - улучшенное вычисление типов при создании обобщенных экземпляров.
+ __Simplified varargs method declaration__ - перенос предупреждения "unsafe operation" вместо объявления метода с
  переменным количеством аргументов.
+ __Binary integer literals__ - префикс _0b_ (int i = 0b0101)
+ __Underscores in numeric literals__ - подчеркивания в числах (int i = 1_000)
+ __Catching multiple exception types__ - перехват нескольких типов исключений в одном блоке catch (catch(SQLException |
  IOException e)).
+ __DualPivotQuickSort__ - в качестве стандартного алгоритма для сортировки примитивов.
+ __TimSort__ - в качестве стандартного алгоритма для сортировки объектов.
+ __Concurrency utilities__ - новый синхронизатор Phaser, включён легковесный механизм fork/join.
+ __NIO.2 library__ - добавлены пакеты java.nio.file, java.nio.file.attribute и java.nio.file.spi.

##### Версия 8 - 18 марта 2014 года

+ __Lambda expressions__ - выражения в функциональном стиле.
+ __@FunctionalInterface__ - функциональные интерфейсы.
+ __Stream API__. - возможность выполнения последовательности операций над элементами массива, а также возможность
  производить их параллельно (parallelStream).
+ __Method Reference__ - ссылки на методы и конструкторы, оператор `::`.
+ __Repeatable annotations__ - возможность использовать аннотации одного типа несколько раз над одним объектом.
+ __Interface default method__ - методы по умолчанию для интерфейсов.
+ __Annotation on Java types__ - аннотации на типы данных.
+ __Reflection for method parameters__ - рефлексия для параметров методов.
+ __Date & Time API (java.time)__ - новое api для работы с датами и временем.
+ __Remove the PermGen__ - удален _PermGen_, изменен способ хранения мета-данных классов.

##### Версия 9 - 21 сентября 2017 года

+ __HTTP/2 support__.
+ __Jshell__ - поддержка REPL-подхода (Read-Eval-Print-Loop) в Java.
+ __JigSaw project__ - поддержка модуляризации в Java.
+ __Stream API updates__.
+ __Immutable collevtions__ - создании и инициализация коллекций в одну строку.
+ __Concurrency updates__ - реализация Reactive Streams (в т.ч. класс `Flow`).
+ __class Optional__  - класс для сбора not-null объектов.
+ __Complete the removal of underscore from the set of legal identifier names__ - запрет подчёркивания в именах классов.
+ __Support for private methods in interfaces__- private и static private методы в интерфейсах.
+ __Compact strings__ - хранение строк в кодировке LATIN-1, если это возможно.

##### Версия 10 - 20 марта 2018 года

+ __Local-variable type inference__ - ключевое слово `var`, что избавляет от необходимости указывать тип локальной
  переменной явно.
+ __Stream API updates__.
+ __Concurrency updates__.

##### Версия 11 - 25 сентября 2018 года

+ __Local-Variable Syntax for Lambda Parameters__ - ключевое слово `var` в локальных Лямбда-переменных, например при
  использовании аннотаций.
+ __Launch Single-File Source-Code Programs__ - запуск приложения одной командой `java HelloWorld.java`.
+ __Remove The Java EE and CORBA Modules__ — удалены модули Java EE и COBRA.

##### Версия 12 - 19 марта 2019 года

+ __Switch Expressions__ - новая форма метки switch “case L ->” чтобы очевидным образом показать, что будет выполняться
  только код справа от метки, если эта метка – подходящая.

##### Версия 13 - 17 сентября 2019 года

+ __Text Blocks__ - Использование `"""` для создания текстовых блоков без экранирования спец. символов.
+ __Reimplement the legacy Socket API__ - новая реализацию `NioSocketImpl`. Она больше не требует нативного кода, тем
  самым упрощая перенос на разные платформы.

##### Версия 14 - 17 марта 2020 года

+ __Records__ - записи похожи на перечисления и позволяют упростить код. По сути, они заменяют классы, у которых есть
  состояние, но нет поведения - есть поля, нет методов.
+ __Pattern Matching for instanceof__.
+ __Remove the Concurrent Mark Sweep (CMS) Garbage Collector__.

[к оглавлению](#java-virtual-machine)

## Чем различаются JRE, JVM и JDK?

__JVM__, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE).
Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы
компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

__JRE__, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

__JDK__, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

Коротко: __JDK__ - среда для разработки программ на Java, включающая в себя __JRE__ - среду для обеспечения запуска Java программ, которая в свою очередь содержит __JVM__ - интерпретатор кода Java программ.

[к оглавлению](#java-virtual-machine)

## За что отвечает _JVM_?

+ Загрузка, проверка и исполнение байт-кода;
+ Предоставление среды выполнения для выполнения байт-кода;
+ Управление памятью и очисткой мусора (Garbage collection);

Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями.
Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу.

JVM работает с 2 типами данных:  примитивные типы (__primitive types__) и ссылочные типы (__reference types__).

__Примитивы__

JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина.
Типы `long` и `double`, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в `frame's local`
или стеке операндов, поскольку каждая единица составляет 32 бита.
Типы `boolean`, `byte`, `short` и `char` имеют расширенный знак (кроме `char` с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы `int`.
Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.
`boolean` значение работает как 8-битное `byte` значения, где 0 представляет значение __false__, а 1 - значение __true__.

__Типы ссылок и значения__

Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.
Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов,
которые реализуют интерфейсы соответственно.

[к оглавлению](#java-virtual-machine)

## Расскажите про Classloader

Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM.
Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах
благодаря загрузчику классов. __Делегирование является важной концепцией__, которую выполняет загрузчик. Загрузчик классов
отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках.
Эта __загрузка__ обычно выполняется __«по требованию»__, поскольку она не происходит до тех пор, пока программа не вызовет класс.
__Класс с именем может быть загружен только один раз данным загрузчиком классов.__

При запуске JVM, используются три загрузчика классов:

+ Bootstrap class loader (Загрузчик класса Bootstrap)
+ Extensions class loader (Загрузчик класса расширений)
+ System class loader (Системный загрузчик классов)

__Загрузчик класса Bootstrap__ загружает основные библиотеки Java, расположенные в папке `<JAVA_HOME>/jre/lib`.
Этот загрузчик является частью ядра JVM, написан на нативном коде.

__Загрузчик класса расширений__ загружает код в каталоги расширений
(`<JAVA_HOME>/jre/lib/ext`, или любой другой каталог, указанный системным свойством `java.ext.dirs`).

__Системный загрузчик__ загружает код, найденный в `java.class.path`, который сопоставляется с переменной среды `CLASSPATH`.
Это реализуется классом `sun.misc.Launcher$AppClassLoader`.

Загрузчик классов выполняет три основных действия в строгом порядке:

+ Загрузка: находит и импортирует двоичные данные для типа.
+ Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
    + Проверка: обеспечивает правильность импортируемого типа.
    + Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
    + Разрешение: преобразует символические ссылки из типа в прямые ссылки.
+ Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

__Пользовательский загрузчик классов__

Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM.
У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового
загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.

Что делает возможным следующее:

+ загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения,
  даже из ресурса HTTP).
  Это важная особенность для:
    + реализация скриптовых языков;
    + использование bean builders;
    + добавить пользовательскую расширение;
    + позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
+ изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
+ модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании
  аспектно-ориентированного программирования);

[к оглавлению](#java-virtual-machine)

## Расскажите о Run-Time Data Area

Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных
созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.

__The pc Register (PCR)__

Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (programm counter).
В любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока.
Если этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.

Коротко говоря: для одного потока существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.

__Java Virtual Machine Stacks__

Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames.
Стеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.

__Heap__

JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java.
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.
Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой
управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно.
JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных,
и метод управления может быть выбран в соответствии с системными требованиями разработчика.
Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена,
если большая куча становится ненужной. Память для кучи не должна быть смежной.

__Method Area__

JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов,
а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса.
Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора. Область метода может иметь
фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.

__Run-Time Constant Pool__

 A run-time constant pool существует для каждого класса или интерфейса в рантайме и представлено constant_pool таблицей в *.class файле.
 Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля,
 которые должны быть разрешены во время выполнения.  Сам run-time constant pool выполняет функцию,
 аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов.
 Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.

__Native Method Stacks__

Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).

[к оглавлению](#java-virtual-machine)

## Как рассчитать объем, который занимают объекты в памяти?

Заголовок объекта занимает 12 байт:

| Название            | Размер, байт | Описание                                      |
|---------------------|--------------|-----------------------------------------------|
| Class pointer       | 4            | Ссылка на описание класса                     |
| Mark word           | 8            | Набор флагов, описывающих состояние объекта   |

Пример приведен для x32 или x64 систем c размером Heap меньше 32 Гбайт и включенной `-XX:UseCompressedOops`. Иначе размер ссылки буде 8 байт. Также в структуре объекта есть поля. Размер объекта выравнивается по 8 байт.

Пример:

+ `new Integer()` - 12 байт (заголовок) + 4 байта (int) = 16 байт
+ `new Long()` - 12 байт (заголовок) + 8 байта (long) + 4 байта (выравнивание) = 24 байта
+ `new int[N]` - 12 байт (заголовок) + 4 байта (поле размер) + N *4 байта (значения) = 16 + N* 4 байт
+ `new byte[N]` - 12 байт (заголовок) + 4 байта (поле размер) + N *1 байта (значения) = 16 + N* 1 байт
+ `new Integer[N]` - 12 байт (заголовок) + 4 байта (поле размер) + N *4 байта (ссылки на значения) + N* 16 байт (
  значения) = 16 + N * 20 байт
+ `new String()` - 12 байт (заголовок) + 4 байта (ссылка на массив byte[]) + 4 байта (hash) + 1 байт (coder) + 3 байта (
  выравнивание)  = 24 байта

Размер объектов в можно узнать, воспользовавшись утилитой `Java Object Layout`.

[к оглавлению](#java-virtual-machine)

## Расскажите о Frames

Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода,
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame.
Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.
Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.
Таким образом, размер структуры данных frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.

Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.
Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.

Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим,
когда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame.
Текущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком,
является локальным для этого потока и на него не может ссылаться ни один другой поток.

__Локальные переменные__

Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции
и предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом.
Единичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress.
Пара локальных переменных может хранить значение типов: long или double.

Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.

Значение типа long или типа double занимает две последовательные локальные переменные.

JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных,
начиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект,
для которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.

__Стеки операндов (Operand Stacks)__

Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a
определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.

Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант
или значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов,
оперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров
для передачи в методы и для получения результатов метода.

Для примера, инструкция __iadd__  суммирует два int значения. От стека операндов требуется, чтобы два int значения были наверху стека.
Значения удаляются из стека, операция __pop__. Суммируются и их сумма помещается в стек операндов.

__Динамическое связывание (Dynamic Linking)__

Каждый frame содержит ссылку на  run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода.
Доступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла.
Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости
для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения,
связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.

__Нормальное завершение вызова метода__

Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw.
Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу.
Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).

Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов,
с соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода.
Затем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.

__Резкое завершение вызова метода__

Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе.
Выполнение команды __athrow__ также приводит к явному выбрасыванию исключения, и если исключение не перехватывается текущим методом,
приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.

[к оглавлению](#java-virtual-machine)

## Что такое Execution Engine?

Байт-код, назначенный __run-time data areas__, будет выполнен __execution engine__. Механизм выполнения считывает байт-код и выполняет его по частям.

__Interpreter__

Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.

__JIT Compiler__

JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода,
но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код.
Этот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.

+ Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.
+ Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.
+ Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.
+ Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.

__Garbage Collector__
Garbage Collector ("сборщик мусора") функционирует в фоновом режиме во время работы твоей программы, собирает ставшие ненужными объекты, которые в дальнейшем будут удалены. Таким образом, он освобождает память для создания новых объектов в будущем. На самом деле сборщик мусора не один, а несколько.

[к оглавлению](#java-virtual-machine)

## Для чего нужен сборщик мусора?

Сборщик мусора (Garbage Collector) должен делать всего две вещи:

+ Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
+ Освобождать память от мусора.

Существует два подхода к обнаружению мусора:

+ _Reference counting_;
+ _Tracing_

__Reference counting__ (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.

Главная идея подхода __Tracing__ (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (_GC Root_) или других с живых объектов. Всё остальное - мусор.

Существует 4 типа корневых точки:

+ Локальные переменные и параметры методов;
+ Потоки;
+ Статические переменные;
+ Ссылки из JNI.

Самое простое java приложение будет иметь корневые точки:

+ Локальные переменные внутри `main()` метода и параметры `main()` метода;
+ Поток, который выполняет `main()`;
+ Статические переменные класса, внутри которого находится `main()` метод.

Таким образом, если мы представим все объекты и ссылки между ними как дерево, то нам нужно будет пройти с корневых узлов (точек) по всем рёбрам. При этом узлы, до которых мы сможем добраться - не мусор, все остальные - мусор. При таком подходе циклические зависимости легко выявляются. HotSpot VM использует именно такой подход.

---
Для очистки памяти от мусора существуют два основных метода:

+ _Copying collectors_
+ _Mark-and-sweep_

При __copying collectors__ подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:

+ Объекты создаются в «from-space»;
+ Когда «from-space» заполняется, приложение приостанавливается;
+ Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
+ Когда все объекты скопированы «from-space» полностью очищается;
+ «to-space» и «from-space» меняются местами.

Главный плюс такого подхода в том, что объекты плотно забивают память. Минусы подхода:

1. Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
2. В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

Алгоритм работы __mark-and-sweep__ можно описать так:

+ Объекты создаются в памяти;
+ В момент, когда нужно запустить сборщик мусора приложение приостанавливается;
+ Сборщик проходится по дереву объектов, помечая живые объекты;
+ Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»;
+ Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list».

Минусы этого способа:

1. Приложение не работает, пока происходит сборка мусора;
2. Время остановки напрямую зависит от размеров памяти и количества объектов;
3. Если не использовать «compacting», то память будет использоваться не эффективно.

Сборщики мусора HotSpot VM используют комбинированный подход __Generational Garbage Collection__, который позволяет использовать разные алгоритмы для разных этапов сборки мусора. Этот подход опирается на том, что:

+ большинство создаваемых объектов быстро становятся мусором;
+ существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

[к оглавлению](#java-virtual-machine)

## Как работает сборщик мусора?

Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых объектов.

Объекты создаются посредством оператора `new`, тем самым присваивая объекту ссылку. Для окончания работы с объектом достаточно просто перестать на него ссылаться, например присвоив переменной ссылку на другой объект или значение `null`; прекратить выполнение метода, чтобы его локальные переменные завершили свое существование естественным образом. Объекты, на которые отсутствуют ссылки, принято называть мусором (_garbage_).

Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект, обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти. Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим посредством цепочки ссылок, начиная с корневой (_GC Root_) ссылки, т.е. ссылки, непосредственно существующей в выполняемом коде.

Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте и поэтому ей так и не потребуются «услуги» сборщика мусора.

Мусор собирается системой автоматически, без вмешательства пользователя или программиста, но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и удаления большого количества объектов существенным образом сказывается на производительности приложений и если быстродействие программы является важным фактором, следует тщательно обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем мусора, подлежащего утилизации.

[к оглавлению](#java-virtual-machine)

## Какие разновидности сборщиков мусора реализованы в виртуальной машине HotSpot?

Java HotSpot VM предоставляет разработчикам на выбор четыре различных сборщика мусора:

+ __Serial (последовательный)__ — самый простой вариант для приложений с небольшим объемом данных и не требовательных к
  задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной
  машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
+ __Parallel (параллельный)__ — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в
  некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
  Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
+ __Concurrent Mark Sweep (CMS)__ — нацелен на снижение максимальных задержек путем выполнения части работ по сборке
  мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в
  памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
+ __Garbage-First (G1)__ — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных
  серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.

[к оглавлению](#java-virtual-machine)

## Опишите алгоритм работы какого-нибудь сборщика мусора реализованного в виртуальной машине HotSpot

__Serial Garbage Collector (Последовательный сборщик мусора)__ был одним из первых сборщиков мусора в HotSpot VM. Во
время работы этого сборщика приложения приостанавливается и продолжает работать только после прекращение сборки мусора.

Память приложения делится на три пространства:

+ _Young generation_. Объекты создаются именно в этом участке памяти.
+ _Old generation_. В этот участок памяти перемещаются объекты, которые переживают «minor garbage collection».
+ _Permanent generation_. Тут хранятся метаданные об объектах, _Class data sharing (CDS)_, _пул строк (String pool)_.
  Permanent область делится на две: только для чтения и для чтения-записи. Очевидно, что в этом случае область только
  для чтения не чистится сборщиком мусора никогда. В Java 8 и выше отсутствует, пул строке переехал в основную память,
  метаданные в нативную память JVM.

Область памяти Young generation состоит из трёх областей: _Eden_ и двух меньших по размеру _Survivor spaces_ - _To
space_ и _From space_. Большинство объектов создаются в области Eden, за исключением очень больших объектов, которые не
могут быть размещены в ней и поэтому сразу размещаются в Old generation. В Survivor spaces перемещаются объекты, которые
пережили по крайней мере одну сборку мусора, но ещё не достигли порога «старости» (_tenuring threshold_), чтобы быть
перемещенными в Old generation.

Когда Young generation заполняется, то в этой области запускается процесс лёгкой сборки (_minor collection_), в отличие от процесса сборки, проводимого над всей кучей (_full collection_). Он происходит следующим образом: в начале работы одно из Survivor spaces - To space, является пустым, а другое - From space, содержит объекты, пережившие предыдущие сборки. Сборщик мусора ищет живые объекты в Eden и копирует их в To space, а затем копирует туда же и живые «молодые» (то есть не пережившие еще заданное число сборок мусора) объекты из From space. Старые объекты из From space перемещаются в Old generation. После лёгкой сборки From space и To space меняются ролями, область Eden становится пустой, а число объектов в Old generation увеличивается.

Если в процессе копирования живых объектов To space переполняется, то оставшиеся живые объекты из Eden и From space, которым не хватило места в To space, будут перемещены в Old generation, независимо от того, сколько сборок мусора они пережили.

Поскольку при использовании этого алгоритма сборщик мусора просто копирует все живые объекты из одной области памяти в другую, то такой сборщик мусора называется _copying_ (копирующий). Очевидно, что для работы копирующего сборщика мусора у приложения всегда должна быть свободная область памяти, в которую будут копироваться живые объекты, и такой алгоритм может применяться для областей памяти сравнительно небольших по отношению к общему размеру памяти приложения. Young generation как раз удовлетворяет этому условию (по умолчанию на машинах клиентского типа эта область занимает около 10% кучи (значение может варьироваться в зависимости от платформы)).

Однако для сборки мусора в Old generation, занимающем большую часть всей памяти, используется другой алгоритм.

В Old generation сборка мусора происходит с использованием алгоритма _mark-sweep-compact_, который состоит из трёх фаз. В фазе _Mark_ (пометка) сборщик мусора помечает все живые объекты, затем, в фазе _Sweep_ (очистка) все не помеченные объекты удаляются, а в фазе _Compact_ (уплотнение) все живые объекты перемещаются в начало Old generation, в результате чего свободная память после очистки представляет собой непрерывную область. Фаза уплотнения выполняется для того, чтобы избежать фрагментации и упростить процесс выделения памяти в Old generation.

Когда свободная память представляет собой непрерывную область, то для выделения памяти под создаваемый объект можно использовать очень быстрый (около десятка машинных инструкций) алгоритм _bump-the-pointer_: адрес начала свободной памяти хранится в специальном указателе, и когда поступает запрос на создание нового объекта, код проверяет, что для нового объекта достаточно места, и, если это так, то просто увеличивает указатель на размер объекта.

Последовательный сборщик мусора отлично подходит для большинства приложений, использующих до 200 мегабайт кучи, работающих на машинах клиентского типа и не предъявляющих жёстких требований к величине пауз, затрачиваемых на сборку мусора. В то же время модель «stop-the-world» может вызвать длительные паузы в работе приложения при использовании больших объёмов памяти. Кроме того, последовательный алгоритм работы не позволяет оптимально использовать вычислительные ресурсы компьютера и последовательный сборщик мусора может стать узким местом при работе приложения на многопроцессорных машинах.

[к оглавлению](#java-virtual-machine)

## Что такое Safepoints (применительно к HotSpot JVM)?

В HotSpot JVM механизм паузы «stop-the-world» называется __safepoint__. Во время safepoint все потоки, исполняющие java-код приостанавливаются. Потоки, исполняющие нативный код, могут продолжать работать пока, не будут прерваны JVM (попытка доступа к объектам Java через JNI, вызов метода Java или возврат из нативного кода в Java приостановит поток до конца safepoint). Остановка всех потоков необходима, чтобы убедиться, что safepoint-инициатор имеет эксклюзивный доступ к структурам данных JVM и может делать всё что угодно, например перемещение объектов в куче или замена кода метода, который в настоящее время выполняется (перемещение в стеке).

__Как работают safepoints?__
Протокол Safepoint в HotSpot JVM является общим. Каждый поток приложения проверяет статус safepoint и паркуется в безопасном состоянии в этой точке. Для скомпилированного кода JIT вставляет в код проверки safepoint в определенных точках (обычно после возврата вызовов или при обратном переходе цикла). Для интерпретируемого кода JVM имеет две таблицы диспетчеризации байт-кода, и если требуется safepoint, JVM переключает таблицы, чтобы включить его проверку.

Сама проверка статуса Safepoint реализована очень нетривиально. Обычная проверка переменных памяти потребует дорогостоящих барьеров памяти. Хотя проверка safepoints реализована через барьер. Затем требуется безопасная точка, JVM отключает отображение страницы с этим адресом, вызывая сбой страницы в потоке приложения (который обрабатывается обработчиком JVM). Таким образом, HotSpot поддерживает свой JITed-код, совместимый с конвейером процессора, но при этом обеспечивает правильную семантику памяти (unmap страницы создает барьер памяти для ядер обработки).

__Когда safepoint используется?__

+ Пауза GC
+ Деоптимизация кода
+ Flushing code cache
+ Class redefinition (e.g. hot swap or instrumentation)
+ Biased lock revocation
+ Various debug operation (e.g. deadlock check or stacktrace dump)

Источник: [http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html](http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html)

[к оглавлению](#java-virtual-machine)

## Что такое HeapDump и TreadDump?

__HeapDump__ - снимок текущей памяти, позволяет разобраться в потребление памяти, например, при её утечке.

__ThreadDump__ - снимок стеков всех поток, позволяет разбираться в проблемах многопоточности, например, находить взаимные блокировки.

[к оглавлению](#java-virtual-machine)

## Что такое профилирование?

__Профилирование__ — сбор характеристик работы программы, таких как время выполнения отдельных фрагментов (обычно подпрограмм), число верно предсказанных условных переходов, число кэш-промахов и т. д. Инструмент, используемый для анализа работы, называют профилировщиком или профайлером (англ. profiler). Обычно выполняется совместно с оптимизацией программы.

__Профилировщики__ - программы, производящие профилирование, делятся на 2 типа:

+ _Инструментирующие_ - модифицируют программный код, оказывают значительное влияние н производительность.
+ _Сэмплирующие_ - не влияют напрямую на исполняемый код.

[к оглавлению](#java-virtual-machine)

## Как обнаружить причину утечки памяти (memory leak)?

Как правило, следствием утечки памяти становится замедление приложения и/или появление `OutOfMemoryError: xxx`.

Что может быть причиной:

+ __Неверно сконфигурированная JVM__ - удалите все ключи jvm, и попробуйте воспроизвести проблему.
+ __Объективная нехватка памяти__ - добавьте ее в Heap (`-Xmx` / `-Xms`) и PermGen (`-XX:PermSize` / `-XX:MaxPermSize`) для версий Java 7 и ниже.
+ __Утечка в загрузчике классов (class loader)__ - ограничьте Metaspace `-XX:MaxMetaSpaceSize={unlimited}` для версий Java 8 и выше, чтобы ограничить потребление физической памяти и локализовать проблему.
+ __Ошибки проектирования__ - незакрытые потоки ввод-вывода, зависшие потоки (threads), ...

Рекомендации по диагностированию:

+ __Утилиты VisaulVM, MissonControl, jstat, jmap__ - для анализа состояния JVM в моменте.
+ __Включение GC-логов__ - `-XX:PrintGCDetails` и других. Их можно анализировать с помощью GCLogAnalyzer или GCViewer.
+ __Включение создания дампа памяти при ошибке `OutOfMememoryError: xxx`__ `- XX:HeadDumpOnOutOfMemoryError` и `-XX:HeapDumpPath=<file_name>`. Анализ дампа можно производить с помощью Memory Analyzer (MAT).

[к оглавлению](#java-virtual-machine)

## Какие существуют рекомендации к стилю кода на Java?

Рекомендации к стилю кода отражены в документе __Java Code Conventions__.

[к оглавлению](#java-virtual-machine)

## Какие языки (кроме Java) могут быть использованы в разработке ПО, исполняемого в среде JVM?

_Компилируемые в байт-код Java_:
_Scala_ — объектно-ориентированный и функциональный язык;
_Kotlin_ — объектно-ориентированный язык, используется, в том числе для разработки Android-приложений;
_Clojure_ — функциональный язык, диалект Lisp;
_Ceylon_ — объектно-ориентированный язык со строгой статической типизацией.

__Интерпретируемые__:
_Jacl_ - реализация TCL;
_Jython_ — реализация Python;
_JRuby_ — реализация Ruby;
_Groovy_ — сценарный язык;
_Nashorn_ — реализация JavaScript.

[к оглавлению](#java-virtual-machine)

[Вопросы для собеседования](README.md)
